<---EXPLANATION--->
### QMap y QHash - Métodos y Operaciones

Qt ofrece dos contenedores asociativos principales: `QMap` (ordenado por clave) y `QHash` (no ordenado, más rápido). Ambos implementan **Implicit Sharing** y proporcionan una API más expresiva que `std::map` y `std::unordered_map`.

#### Diferencias Fundamentales

| Característica | `QMap` | `QHash` |
| :--- | :--- | :--- |
| **Ordenamiento** | Claves ordenadas | Sin orden |
| **Complejidad búsqueda** | O(log n) | O(1) amortizado |
| **Requisito de clave** | `operator<` | `qHash()` + `operator==` |
| **Iteración** | Orden predecible | Orden aleatorio |
| **Uso recomendado** | Pocas inserciones, muchas búsquedas ordenadas | Muchas inserciones y búsquedas |

#### Creación e Inserción

```cpp
#include <QMap>
#include <QHash>
#include <QDebug>

void creacion() {
    // QMap - ordenado por clave
    QMap<QString, int> edades;
    edades["Ana"] = 25;
    edades["Carlos"] = 30;
    edades.insert("Elena", 28);
    
    // QHash - sin orden
    QHash<QString, int> telefonos;
    telefonos["Ana"] = 612345678;
    telefonos.insert("Carlos", 698765432);
    
    qDebug() << edades;    // Imprime ordenado por clave
    qDebug() << telefonos; // Orden no garantizado
}
```

#### `value()` - Acceso Seguro con Valor por Defecto

A diferencia de `operator[]`, `value()` no inserta la clave si no existe y permite especificar un valor por defecto.

```cpp
void accesoSeguro() {
    QMap<QString, int> mapa;
    mapa["existente"] = 42;
    
    // operator[] inserta la clave si no existe (¡peligroso!)
    int v1 = mapa["inexistente"]; // Inserta "inexistente" con valor 0
    
    // value() NO inserta y permite un default
    int v2 = mapa.value("otra_inexistente", -1); // Devuelve -1
    
    qDebug() << "Con []:" << v1;          // 0 (insertado)
    qDebug() << "Con value():" << v2;     // -1 (no insertado)
    qDebug() << "Contiene 'inexistente':" << mapa.contains("inexistente"); // true
    qDebug() << "Contiene 'otra':" << mapa.contains("otra_inexistente");  // false
}
```

#### `keys()` y `values()`

```cpp
void clavesYValores() {
    QMap<QString, int> mapa;
    mapa["C++"] = 1985;
    mapa["Java"] = 1995;
    mapa["Python"] = 1991;
    
    // Obtener todas las claves
    QList<QString> claves = mapa.keys();      // {"C++", "Java", "Python"}
    
    // Obtener todos los valores
    QList<int> valores = mapa.values();       // {1985, 1995, 1991}
    
    // Claves para un valor específico
    QList<QString> de1995 = mapa.keys(1995);  // {"Java"}
    
    // key() - clave para un valor (inversa de value())
    QString clave = mapa.key(1991);           // "Python"
    
    qDebug() << claves << valores;
}
```

#### `contains()`, `count()` y `remove()`

```cpp
void operaciones() {
    QMap<QString, int> mapa;
    mapa["uno"] = 1;
    mapa["dos"] = 2;
    mapa["tres"] = 3;
    
    // contains() - comprobar existencia
    bool existe = mapa.contains("dos");   // true
    
    // count() - número de valores para una clave
    int n = mapa.count("dos");            // 1
    
    // remove() - eliminar y devolver número de eliminados
    int eliminados = mapa.remove("dos");  // 1
    
    // take() - eliminar y devolver el valor
    int valor = mapa.take("tres");        // 3, mapa ya no tiene "tres"
    
    qDebug() << existe << eliminados << valor << mapa;
}
```

#### Iteración

```cpp
void iteracion() {
    QMap<QString, int> mapa;
    mapa["A"] = 1;
    mapa["B"] = 2;
    mapa["C"] = 3;
    
    // 1. Estilo STL (recomendado)
    for (auto it = mapa.cbegin(); it != mapa.cend(); ++it) {
        qDebug() << it.key() << ":" << it.value();
    }
    
    // 2. Range-based for con structured bindings (C++17)
    for (auto [clave, valor] : mapa.asKeyValueRange()) {
        qDebug() << clave << ":" << valor;
    }
    
    // 3. Estilo Java (legado)
    QMapIterator<QString, int> it(mapa);
    while (it.hasNext()) {
        it.next();
        qDebug() << it.key() << ":" << it.value();
    }
}
```

#### `unite()` y `insert()` para Combinar Mapas

```cpp
void combinarMapas() {
    QMap<QString, int> mapa1;
    mapa1["A"] = 1;
    mapa1["B"] = 2;
    
    QMap<QString, int> mapa2;
    mapa2["B"] = 20;  // Clave duplicada
    mapa2["C"] = 3;
    
    // insert() desde otro mapa (Qt 5)
    // Las claves de mapa2 sobreescriben las de mapa1
    mapa1.insert(mapa2);
    // mapa1 = {"A": 1, "B": 20, "C": 3}
    
    qDebug() << mapa1;
}
```

#### QMultiMap - Múltiples Valores por Clave

```cpp
void multiMap() {
    QMultiMap<QString, int> notas;
    notas.insert("Matemáticas", 8);
    notas.insert("Matemáticas", 7);
    notas.insert("Matemáticas", 9);
    notas.insert("Física", 6);
    
    // values() para una clave específica
    QList<int> notasMat = notas.values("Matemáticas"); // {8, 7, 9}
    
    // count() para una clave
    int cuantas = notas.count("Matemáticas"); // 3
    
    qDebug() << notasMat << cuantas;
}
```

#### Comparación con la STL

| Operación | Qt (`QMap`) | STL (`std::map`) |
| :--- | :--- | :--- |
| **Acceso seguro** | `value("key", default)` | `at("key")` lanza excepción |
| **Comprobar existencia** | `contains("key")` | `count("key")` o `find()` |
| **Eliminar y devolver** | `take("key")` | No disponible directamente |
| **Buscar clave por valor** | `key(valor)` | No disponible |
| **Combinar mapas** | `insert(otroMapa)` | `merge()` (C++17) |
| **Implicit Sharing** | Sí | No |

### Conclusión

`QMap` y `QHash` ofrecen una API más conveniente que sus equivalentes STL, con operaciones como `value()` con default, `take()`, y `key()`. La elección entre `QMap` y `QHash` depende de si se necesita orden (`QMap`) o velocidad (`QHash`).
<---FILES--->
Creación e Inserción
Creación e Inserción Result
`value()` - Acceso Seguro con Valor por Defecto
`value()` - Acceso Seguro con Valor por Defecto Result
`keys()` y `values()`
`keys()` y `values()` Result
`contains()`, `count()` y `remove()`
`contains()`, `count()` y `remove()` Result
Iteración
Iteración Result
QMultiMap - Múltiples Valores por Clave
QMultiMap - Múltiples Valores por Clave Result
<---Creación e Inserción--->
```cpp
#include <QMap>
#include <QHash>
#include <QDebug>

void creacion() {
    QMap<QString, int> edades;
    edades["Ana"] = 25;
    edades["Carlos"] = 30;
    edades.insert("Elena", 28);
    QHash<QString, int> telefonos;
    telefonos["Ana"] = 612345678;
    qDebug() << edades << telefonos;
}
<---Creación e Inserción Result--->
<---`value()` - Acceso Seguro con Valor por Defecto--->
```cpp
#include <QMap>
#include <QDebug>

void accesoSeguro() {
    QMap<QString, int> mapa;
    mapa["existente"] = 42;
    int v1 = mapa["inexistente"];
    int v2 = mapa.value("otra_inexistente", -1);
    qDebug() << v1 << v2;
}
<---`value()` - Acceso Seguro con Valor por Defecto Result--->
<---`keys()` y `values()`--->
```cpp
#include <QMap>
#include <QDebug>

void clavesYValores() {
    QMap<QString, int> mapa;
    mapa["C++"] = 1985;
    mapa["Java"] = 1995;
    mapa["Python"] = 1991;
    QList<QString> claves = mapa.keys();
    QList<int> valores = mapa.values();
    qDebug() << claves << valores;
}
<---`keys()` y `values()` Result--->
<---`contains()`, `count()` y `remove()`--->
```cpp
#include <QMap>
#include <QDebug>

void operaciones() {
    QMap<QString, int> mapa;
    mapa["uno"] = 1;
    mapa["dos"] = 2;
    mapa["tres"] = 3;
    bool existe = mapa.contains("dos");
    int valor = mapa.take("tres");
    qDebug() << existe << valor << mapa;
}
<---`contains()`, `count()` y `remove()` Result--->
<---Iteración--->
```cpp
#include <QMap>
#include <QDebug>

void iteracion() {
    QMap<QString, int> mapa;
    mapa["A"] = 1;
    mapa["B"] = 2;
    mapa["C"] = 3;
    for (auto it = mapa.cbegin(); it != mapa.cend(); ++it) {
        qDebug() << it.key() << ":" << it.value();
    }
}
<---Iteración Result--->
<---QMultiMap - Múltiples Valores por Clave--->
```cpp
#include <QMultiMap>
#include <QDebug>

void multiMap() {
    QMultiMap<QString, int> notas;
    notas.insert("Matemáticas", 8);
    notas.insert("Matemáticas", 7);
    notas.insert("Matemáticas", 9);
    QList<int> notasMat = notas.values("Matemáticas");
    qDebug() << notasMat;
}
<---QMultiMap - Múltiples Valores por Clave Result--->
