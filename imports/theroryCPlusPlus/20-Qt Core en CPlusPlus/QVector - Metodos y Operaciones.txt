<---EXPLANATION--->
### QVector - Métodos y Operaciones

`QVector` es el contenedor secuencial principal de Qt, equivalente a `std::vector`. En **Qt 6**, `QVector` es un alias directo de `QList`, ya que ambos fueron unificados. En **Qt 5**, `QVector` almacena datos contiguos en memoria (como `std::vector`), mientras que `QList` usa un array de punteros.

`QVector` utiliza **Implicit Sharing (Copy-on-Write)**, lo que significa que copiar un `QVector` es casi gratuito hasta que uno de los dos se modifica.

#### Creación e Inicialización

```cpp
#include <QVector>
#include <QDebug>

void creacion() {
    // Vacío
    QVector<int> v1;
    
    // Con tamaño y valor por defecto
    QVector<int> v2(5, 0);      // {0, 0, 0, 0, 0}
    
    // Con lista de inicialización
    QVector<int> v3 = {1, 2, 3, 4, 5};
    
    // Desde std::vector
    std::vector<int> stdVec = {10, 20, 30};
    QVector<int> v4 = QVector<int>(stdVec.begin(), stdVec.end());
    
    qDebug() << v2 << v3 << v4;
}
```

#### `squeeze()` - Liberar Memoria No Utilizada

`squeeze()` reduce la capacidad del vector para que coincida exactamente con su tamaño actual. Esto libera la memoria reservada de más.

```cpp
void ejemploSqueeze() {
    QVector<int> vec;
    vec.reserve(1000);           // Reserva espacio para 1000 elementos
    
    vec.append(1);
    vec.append(2);
    vec.append(3);
    
    qDebug() << "Tamaño:" << vec.size();         // 3
    qDebug() << "Capacidad:" << vec.capacity();  // 1000
    
    vec.squeeze();               // Libera la memoria no usada
    
    qDebug() << "Capacidad después de squeeze:" << vec.capacity(); // 3
}
```

**Cuándo usar `squeeze()`:**
- Después de llenar un vector que fue sobrerreservado.
- Cuando la memoria es crítica y el vector no crecerá más.
- **No usar** en vectores que seguirán creciendo (causaría realocaciones constantes).

#### `reserve()` - Pre-reservar Memoria

```cpp
void ejemploReserve() {
    QVector<int> vec;
    
    // Sin reserve: múltiples realocaciones internas
    // Con reserve: una sola alocación
    vec.reserve(10000);
    
    for (int i = 0; i < 10000; ++i) {
        vec.append(i);  // Sin realocaciones
    }
    
    qDebug() << "Tamaño:" << vec.size();        // 10000
    qDebug() << "Capacidad:" << vec.capacity(); // >= 10000
}
```

#### `fill()` - Rellenar con un Valor

```cpp
void ejemploFill() {
    QVector<int> vec(5);
    vec.fill(42);               // {42, 42, 42, 42, 42}
    
    // Con nuevo tamaño
    vec.fill(0, 3);             // {0, 0, 0} (redimensiona a 3)
    
    qDebug() << vec;
}
```

#### Inserción y Eliminación

```cpp
void insercionEliminacion() {
    QVector<int> vec = {1, 2, 3, 4, 5};
    
    // append() - añadir al final
    vec.append(6);               // {1, 2, 3, 4, 5, 6}
    
    // prepend() - añadir al inicio
    vec.prepend(0);              // {0, 1, 2, 3, 4, 5, 6}
    
    // insert() - insertar en posición
    vec.insert(3, 99);           // {0, 1, 2, 99, 3, 4, 5, 6}
    
    // remove() - eliminar en posición
    vec.remove(3);               // {0, 1, 2, 3, 4, 5, 6}
    
    // removeFirst() / removeLast()
    vec.removeFirst();           // {1, 2, 3, 4, 5, 6}
    vec.removeLast();            // {1, 2, 3, 4, 5}
    
    // removeAll() - eliminar todas las ocurrencias de un valor
    vec.append(3);
    vec.removeAll(3);            // {1, 2, 4, 5}
    
    // removeOne() - eliminar solo la primera ocurrencia
    vec.append(2);
    vec.removeOne(2);            // {1, 4, 5, 2}
    
    // takeAt() - eliminar y devolver el elemento
    int tomado = vec.takeAt(1);  // tomado = 4, vec = {1, 5, 2}
    
    qDebug() << vec << "tomado:" << tomado;
}
```

#### Búsqueda

```cpp
void busqueda() {
    QVector<int> vec = {10, 20, 30, 20, 40};
    
    // contains() - ¿existe el valor?
    bool existe = vec.contains(30);         // true
    
    // indexOf() - primera posición
    int primera = vec.indexOf(20);          // 1
    
    // lastIndexOf() - última posición
    int ultima = vec.lastIndexOf(20);       // 3
    
    // count() - número de ocurrencias
    int veces = vec.count(20);              // 2
    
    // startsWith() / endsWith()
    bool empieza = vec.startsWith(10);      // true
    bool termina = vec.endsWith(40);        // true
    
    qDebug() << existe << primera << ultima << veces;
}
```

#### `mid()` - Extraer Sub-vector

```cpp
void subVector() {
    QVector<int> vec = {10, 20, 30, 40, 50, 60};
    
    // mid(posición, longitud) - extrae un sub-vector
    QVector<int> sub = vec.mid(2, 3);  // {30, 40, 50}
    
    // Sin longitud: desde la posición hasta el final
    QVector<int> resto = vec.mid(4);   // {50, 60}
    
    qDebug() << sub << resto;
}
```

#### Conversión a/desde `std::vector`

```cpp
void conversion() {
    QVector<int> qvec = {1, 2, 3};
    
    // A std::vector
    std::vector<int> stdVec = qvec.toStdVector(); // Qt 5
    // En Qt 6: std::vector<int> stdVec(qvec.begin(), qvec.end());
    
    // Desde std::vector
    std::vector<int> origen = {4, 5, 6};
    QVector<int> destino = QVector<int>::fromStdVector(origen); // Qt 5
    // En Qt 6: QVector<int> destino(origen.begin(), origen.end());
    
    qDebug() << destino;
}
```

#### Comparación QVector vs std::vector

| Característica | `QVector` | `std::vector` |
| :--- | :--- | :--- |
| **Implicit Sharing** | Sí (COW) | No |
| **`squeeze()`** | Sí | `shrink_to_fit()` |
| **`fill()`** | Sí | `std::fill()` + iteradores |
| **`contains()`** | Sí | Requiere `std::find` |
| **`mid()`** | Sí | Requiere iteradores |
| **`removeAll()`/`removeOne()`** | Sí | `std::erase`/`std::erase_if` (C++20) |
| **Qt 6** | Alias de `QList` | Independiente |

### Conclusión

`QVector` proporciona una API más rica y expresiva que `std::vector`, con métodos como `squeeze()`, `fill()`, `contains()` y `mid()` que simplifican operaciones comunes. Su sistema de Implicit Sharing hace que las copias sean eficientes, y en Qt 6 se ha unificado con `QList` para simplificar la API.
<---FILES--->
Creación e Inicialización
Creación e Inicialización Result
`squeeze()` - Liberar Memoria No Utilizada
`squeeze()` - Liberar Memoria No Utilizada Result
`reserve()` - Pre-reservar Memoria
`reserve()` - Pre-reservar Memoria Result
`fill()` - Rellenar con un Valor
`fill()` - Rellenar con un Valor Result
Inserción y Eliminación
Inserción y Eliminación Result
Búsqueda
Búsqueda Result
`mid()` - Extraer Sub-vector
`mid()` - Extraer Sub-vector Result
<---Creación e Inicialización--->
```cpp
#include <QVector>
#include <QDebug>

void creacion() {
    QVector<int> v1;
    QVector<int> v2(5, 0);
    QVector<int> v3 = {1, 2, 3, 4, 5};
    qDebug() << v2 << v3;
}
<---Creación e Inicialización Result--->
<---`squeeze()` - Liberar Memoria No Utilizada--->
```cpp
#include <QVector>
#include <QDebug>

void ejemploSqueeze() {
    QVector<int> vec;
    vec.reserve(1000);
    vec.append(1);
    vec.append(2);
    vec.append(3);
    qDebug() << "Capacidad:" << vec.capacity(); // 1000
    vec.squeeze();
    qDebug() << "Capacidad después:" << vec.capacity(); // 3
}
<---`squeeze()` - Liberar Memoria No Utilizada Result--->
<---`reserve()` - Pre-reservar Memoria--->
```cpp
#include <QVector>
#include <QDebug>

void ejemploReserve() {
    QVector<int> vec;
    vec.reserve(10000);
    for (int i = 0; i < 10000; ++i) {
        vec.append(i);
    }
    qDebug() << "Tamaño:" << vec.size();
}
<---`reserve()` - Pre-reservar Memoria Result--->
<---`fill()` - Rellenar con un Valor--->
```cpp
#include <QVector>
#include <QDebug>

void ejemploFill() {
    QVector<int> vec(5);
    vec.fill(42);
    qDebug() << vec;
    vec.fill(0, 3);
    qDebug() << vec;
}
<---`fill()` - Rellenar con un Valor Result--->
<---Inserción y Eliminación--->
```cpp
#include <QVector>
#include <QDebug>

void insercionEliminacion() {
    QVector<int> vec = {1, 2, 3, 4, 5};
    vec.append(6);
    vec.prepend(0);
    vec.removeAll(3);
    int tomado = vec.takeAt(1);
    qDebug() << vec << "tomado:" << tomado;
}
<---Inserción y Eliminación Result--->
<---Búsqueda--->
```cpp
#include <QVector>
#include <QDebug>

void busqueda() {
    QVector<int> vec = {10, 20, 30, 20, 40};
    bool existe = vec.contains(30);
    int primera = vec.indexOf(20);
    int ultima = vec.lastIndexOf(20);
    int veces = vec.count(20);
    qDebug() << existe << primera << ultima << veces;
}
<---Búsqueda Result--->
<---`mid()` - Extraer Sub-vector--->
```cpp
#include <QVector>
#include <QDebug>

void subVector() {
    QVector<int> vec = {10, 20, 30, 40, 50, 60};
    QVector<int> sub = vec.mid(2, 3);
    QVector<int> resto = vec.mid(4);
    qDebug() << sub << resto;
}
<---`mid()` - Extraer Sub-vector Result--->
