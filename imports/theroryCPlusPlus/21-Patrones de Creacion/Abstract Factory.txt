<---EXPLANATION--->
### Abstract Factory

El patrón **Abstract Factory** (Fábrica Abstracta) es un patrón de diseño creacional que proporciona una **interfaz para crear familias de objetos relacionados** sin especificar sus clases concretas. Es como un "Factory Method elevado": en lugar de crear un solo tipo de producto, crea **múltiples productos que pertenecen a una misma familia**.

#### Problema

Imagina que estás creando una aplicación con interfaz gráfica que debe funcionar en **múltiples plataformas** (Windows, macOS, Linux). Cada plataforma tiene su propio estilo de botones, checkboxes, menús y scrollbars. Los problemas que surgen son:

- **Mezcla de estilos:** Si creas un botón de Windows y un checkbox de macOS, la interfaz se ve inconsistente.
- **Código condicional:** Terminas con `if/else` o `switch` para cada plataforma en cada punto donde creas un widget.
- **Acoplamiento fuerte:** Tu código de negocio conoce las clases concretas de cada plataforma.
- **Difícil mantenimiento:** Agregar una nueva plataforma requiere modificar código en múltiples lugares.

#### Solución

Abstract Factory resuelve esto creando una **jerarquía de fábricas** donde cada fábrica concreta produce una familia completa de productos compatibles entre sí:

1. **Interfaces de productos:** Definen qué operaciones tiene cada tipo de producto.
2. **Productos concretos:** Implementaciones específicas para cada familia.
3. **Abstract Factory:** Interfaz con un método de creación por cada tipo de producto.
4. **Concrete Factories:** Cada una produce todos los productos de una familia.

```cpp
// La fábrica abstracta declara métodos para crear cada producto
class GUIFactory {
public:
    virtual ~GUIFactory() = default;
    virtual std::unique_ptr<Boton> crearBoton() = 0;
    virtual std::unique_ptr<Checkbox> crearCheckbox() = 0;
    virtual std::unique_ptr<Menu> crearMenu() = 0;
};
```

#### Estructura

Los componentes del patrón Abstract Factory son:

- **AbstractFactory:** Interfaz que declara un conjunto de métodos para crear cada tipo de producto abstracto.
- **ConcreteFactory (WindowsFactory, MacFactory):** Implementa los métodos de creación para una familia específica de productos.
- **AbstractProduct (Boton, Checkbox):** Interfaz para cada tipo de producto.
- **ConcreteProduct (BotonWindows, BotonMac):** Implementaciones concretas de cada producto para cada familia.
- **Cliente:** Usa solo las interfaces abstractas, nunca las clases concretas.

##### Diferencia con Factory Method

| Factory Method | Abstract Factory |
|---|---|
| Crea **un** tipo de producto | Crea **familias** de productos relacionados |
| Una jerarquía de creadores | Una interfaz con múltiples métodos de creación |
| Usa herencia | Usa composición |
| Se extiende creando subclases | Se extiende creando nuevas fábricas |

#### Implementación en C++

La implementación usa interfaces puras para los productos y para la fábrica:

```cpp
// Productos abstractos
class Boton { public: virtual void click() = 0; virtual ~Boton() = default; };
class Checkbox { public: virtual void toggle() = 0; virtual ~Checkbox() = default; };

// Fábrica abstracta
class UIFactory {
public:
    virtual ~UIFactory() = default;
    virtual std::unique_ptr<Boton> crearBoton() = 0;
    virtual std::unique_ptr<Checkbox> crearCheckbox() = 0;
};

// Fábrica concreta para una familia
class MaterialFactory : public UIFactory {
    std::unique_ptr<Boton> crearBoton() override { /*...*/ }
    std::unique_ptr<Checkbox> crearCheckbox() override { /*...*/ }
};
```

> **Nota:** El cliente recibe la fábrica abstracta (generalmente por inyección de dependencias) y nunca sabe qué familia concreta está usando. Esto permite cambiar de familia sin tocar el código cliente.

#### Ventajas y Desventajas

##### Ventajas

- **Consistencia garantizada:** Todos los productos de una familia son compatibles entre sí.
- **Aislamiento de clases concretas:** El cliente solo conoce interfaces abstractas.
- **Intercambio fácil de familias:** Cambiar la fábrica concreta cambia toda la familia de productos.
- **Principio Open/Closed:** Nuevas familias se agregan sin modificar código existente.

##### Desventajas

- **Complejidad significativa:** Muchas interfaces y clases, incluso para familias pequeñas.
- **Difícil agregar nuevos productos:** Si necesitas un nuevo tipo de producto (ej. `Slider`), debes modificar la interfaz de la fábrica y todas sus implementaciones.
- **Rigidez:** La interfaz de la fábrica fija el conjunto de productos que puede crear.

#### Aplicación en Qt

Qt utiliza Abstract Factory de forma prominente:

- **`QStyleFactory::create()`:** Crea un `QStyle` completo (Fusion, Windows, macOS) que define cómo se dibujan TODOS los widgets de forma consistente.
- **`QPlatformIntegration`:** Fábrica abstracta interna de Qt que crea ventanas, contextos OpenGL, fuentes, etc., específicos de cada plataforma.
- **`QPlatformTheme`:** Crea diálogos, iconos y paletas nativos de cada plataforma.
- **Plugins de plataforma:** `xcb`, `cocoa`, `windows` — cada uno es una fábrica que produce objetos nativos de su plataforma.

```cpp
// Qt selecciona la fábrica de plataforma automáticamente
// según el sistema operativo
QStyle *estilo = QStyleFactory::create("Fusion");
QApplication::setStyle(estilo);
// Todos los widgets ahora usan el estilo Fusion consistentemente
```

<---FILES--->
Ejemplo Basico
Ejemplo Basico Result
Ejemplo Avanzado
Ejemplo Avanzado Result
Ejemplo con Qt
Ejemplo con Qt Result

<---Ejemplo Basico--->
```cpp
#include <iostream>
#include <memory>
#include <string>

// =============================================
// Productos abstractos
// =============================================
class Boton {
public:
    virtual ~Boton() = default;
    virtual void renderizar() const = 0;
    virtual void click() const = 0;
};

class Checkbox {
public:
    virtual ~Checkbox() = default;
    virtual void renderizar() const = 0;
    virtual void toggle() const = 0;
};

// =============================================
// Familia Windows
// =============================================
class BotonWindows : public Boton {
public:
    void renderizar() const override {
        std::cout << "  [Win] Boton con borde 3D" << std::endl;
    }
    void click() const override {
        std::cout << "  [Win] Click con sonido del sistema" << std::endl;
    }
};

class CheckboxWindows : public Checkbox {
public:
    void renderizar() const override {
        std::cout << "  [Win] Checkbox cuadrado clasico" << std::endl;
    }
    void toggle() const override {
        std::cout << "  [Win] Toggle con marca de verificacion" << std::endl;
    }
};

// =============================================
// Familia macOS
// =============================================
class BotonMac : public Boton {
public:
    void renderizar() const override {
        std::cout << "  [Mac] Boton redondeado con gradiente" << std::endl;
    }
    void click() const override {
        std::cout << "  [Mac] Click con animacion suave" << std::endl;
    }
};

class CheckboxMac : public Checkbox {
public:
    void renderizar() const override {
        std::cout << "  [Mac] Checkbox circular estilo Aqua" << std::endl;
    }
    void toggle() const override {
        std::cout << "  [Mac] Toggle con transicion animada" << std::endl;
    }
};

// =============================================
// Abstract Factory
// =============================================
class GUIFactory {
public:
    virtual ~GUIFactory() = default;
    virtual std::unique_ptr<Boton> crearBoton() const = 0;
    virtual std::unique_ptr<Checkbox> crearCheckbox() const = 0;
    virtual std::string nombreEstilo() const = 0;
};

// =============================================
// Fábricas concretas
// =============================================
class WindowsFactory : public GUIFactory {
public:
    std::unique_ptr<Boton> crearBoton() const override {
        return std::make_unique<BotonWindows>();
    }
    std::unique_ptr<Checkbox> crearCheckbox() const override {
        return std::make_unique<CheckboxWindows>();
    }
    std::string nombreEstilo() const override { return "Windows"; }
};

class MacFactory : public GUIFactory {
public:
    std::unique_ptr<Boton> crearBoton() const override {
        return std::make_unique<BotonMac>();
    }
    std::unique_ptr<Checkbox> crearCheckbox() const override {
        return std::make_unique<CheckboxMac>();
    }
    std::string nombreEstilo() const override { return "macOS"; }
};

// =============================================
// Código cliente - trabaja SOLO con interfaces
// =============================================
void construirInterfaz(const GUIFactory& factory) {
    std::cout << "Estilo: " << factory.nombreEstilo() << std::endl;

    auto boton = factory.crearBoton();
    auto checkbox = factory.crearCheckbox();

    boton->renderizar();
    boton->click();
    checkbox->renderizar();
    checkbox->toggle();
}

int main() {
    std::cout << "=== Abstract Factory Basico ===" << std::endl;

    std::cout << "\n--- Interfaz Windows ---" << std::endl;
    WindowsFactory winFactory;
    construirInterfaz(winFactory);

    std::cout << "\n--- Interfaz macOS ---" << std::endl;
    MacFactory macFactory;
    construirInterfaz(macFactory);

    return 0;
}
```
<---Ejemplo Basico Result--->
=== Abstract Factory Basico ===

--- Interfaz Windows ---
Estilo: Windows
  [Win] Boton con borde 3D
  [Win] Click con sonido del sistema
  [Win] Checkbox cuadrado clasico
  [Win] Toggle con marca de verificacion

--- Interfaz macOS ---
Estilo: macOS
  [Mac] Boton redondeado con gradiente
  [Mac] Click con animacion suave
  [Mac] Checkbox circular estilo Aqua
  [Mac] Toggle con transicion animada

<---Ejemplo Avanzado--->
```cpp
#include <iostream>
#include <memory>
#include <string>
#include <vector>

// =============================================
// Productos abstractos: Muebles de una tienda
// =============================================
class Silla {
public:
    virtual ~Silla() = default;
    virtual void sentarse() const = 0;
    virtual std::string material() const = 0;
};

class Mesa {
public:
    virtual ~Mesa() = default;
    virtual void colocar() const = 0;
    virtual std::string material() const = 0;
};

class Sofa {
public:
    virtual ~Sofa() = default;
    virtual void recostarse() const = 0;
    virtual std::string material() const = 0;
};

// =============================================
// Familia Moderna
// =============================================
class SillaModerna : public Silla {
public:
    void sentarse() const override {
        std::cout << "    Sentado en silla ergonomica de acero" << std::endl;
    }
    std::string material() const override { return "Acero/Cuero sintetico"; }
};

class MesaModerna : public Mesa {
public:
    void colocar() const override {
        std::cout << "    Mesa de vidrio templado colocada" << std::endl;
    }
    std::string material() const override { return "Vidrio/Acero"; }
};

class SofaModerno : public Sofa {
public:
    void recostarse() const override {
        std::cout << "    Recostado en sofa modular minimalista" << std::endl;
    }
    std::string material() const override { return "Microfibra"; }
};

// =============================================
// Familia Victoriana
// =============================================
class SillaVictoriana : public Silla {
public:
    void sentarse() const override {
        std::cout << "    Sentado en silla tallada ornamental" << std::endl;
    }
    std::string material() const override { return "Caoba/Terciopelo"; }
};

class MesaVictoriana : public Mesa {
public:
    void colocar() const override {
        std::cout << "    Mesa de roble con patas torneadas" << std::endl;
    }
    std::string material() const override { return "Roble macizo"; }
};

class SofaVictoriano : public Sofa {
public:
    void recostarse() const override {
        std::cout << "    Recostado en chesterfield con capitone" << std::endl;
    }
    std::string material() const override { return "Cuero/Roble"; }
};

// =============================================
// Abstract Factory
// =============================================
class MuebleriaFactory {
public:
    virtual ~MuebleriaFactory() = default;
    virtual std::unique_ptr<Silla> crearSilla() const = 0;
    virtual std::unique_ptr<Mesa> crearMesa() const = 0;
    virtual std::unique_ptr<Sofa> crearSofa() const = 0;
    virtual std::string estilo() const = 0;
};

class ModernaFactory : public MuebleriaFactory {
public:
    std::unique_ptr<Silla> crearSilla() const override {
        return std::make_unique<SillaModerna>();
    }
    std::unique_ptr<Mesa> crearMesa() const override {
        return std::make_unique<MesaModerna>();
    }
    std::unique_ptr<Sofa> crearSofa() const override {
        return std::make_unique<SofaModerno>();
    }
    std::string estilo() const override { return "Moderna"; }
};

class VictorianaFactory : public MuebleriaFactory {
public:
    std::unique_ptr<Silla> crearSilla() const override {
        return std::make_unique<SillaVictoriana>();
    }
    std::unique_ptr<Mesa> crearMesa() const override {
        return std::make_unique<MesaVictoriana>();
    }
    std::unique_ptr<Sofa> crearSofa() const override {
        return std::make_unique<SofaVictoriano>();
    }
    std::string estilo() const override { return "Victoriana"; }
};

// =============================================
// Cliente: Decorador de interiores
// =============================================
class DecoradorInteriores {
public:
    explicit DecoradorInteriores(const MuebleriaFactory& factory)
        : factory_(factory) {}

    void decorarSala() const {
        std::cout << "  Decorando sala estilo "
                  << factory_.estilo() << ":" << std::endl;

        auto silla = factory_.crearSilla();
        auto mesa = factory_.crearMesa();
        auto sofa = factory_.crearSofa();

        std::cout << "  Silla (" << silla->material() << "):" << std::endl;
        silla->sentarse();

        std::cout << "  Mesa (" << mesa->material() << "):" << std::endl;
        mesa->colocar();

        std::cout << "  Sofa (" << sofa->material() << "):" << std::endl;
        sofa->recostarse();
    }

private:
    const MuebleriaFactory& factory_;
};

// Función para seleccionar fábrica dinámicamente
std::unique_ptr<MuebleriaFactory> seleccionarEstilo(
        const std::string& estilo) {
    if (estilo == "moderna") {
        return std::make_unique<ModernaFactory>();
    } else if (estilo == "victoriana") {
        return std::make_unique<VictorianaFactory>();
    }
    // Por defecto, moderna
    return std::make_unique<ModernaFactory>();
}

int main() {
    std::cout << "=== Abstract Factory Avanzado ===" << std::endl;

    // Simular selección del usuario
    std::vector<std::string> estilos = {"moderna", "victoriana"};

    for (const auto& estilo : estilos) {
        std::cout << "\n--- Pedido estilo: " << estilo << " ---" << std::endl;
        auto factory = seleccionarEstilo(estilo);
        DecoradorInteriores decorador(*factory);
        decorador.decorarSala();
    }

    return 0;
}
```
<---Ejemplo Avanzado Result--->
=== Abstract Factory Avanzado ===

--- Pedido estilo: moderna ---
  Decorando sala estilo Moderna:
  Silla (Acero/Cuero sintetico):
    Sentado en silla ergonomica de acero
  Mesa (Vidrio/Acero):
    Mesa de vidrio templado colocada
  Sofa (Microfibra):
    Recostado en sofa modular minimalista

--- Pedido estilo: victoriana ---
  Decorando sala estilo Victoriana:
  Silla (Caoba/Terciopelo):
    Sentado en silla tallada ornamental
  Mesa (Roble macizo):
    Mesa de roble con patas torneadas
  Sofa (Cuero/Roble):
    Recostado en chesterfield con capitone

<---Ejemplo con Qt--->
```cpp
#include <QCoreApplication>
#include <QDebug>
#include <QString>
#include <memory>

// =============================================
// Productos abstractos: Elementos de UI
// =============================================
class BotonUI {
public:
    virtual ~BotonUI() = default;
    virtual void dibujar() const = 0;
    virtual QString estiloCSS() const = 0;
};

class PanelUI {
public:
    virtual ~PanelUI() = default;
    virtual void dibujar() const = 0;
    virtual QString estiloCSS() const = 0;
};

class IconoUI {
public:
    virtual ~IconoUI() = default;
    virtual void dibujar() const = 0;
    virtual QString recurso() const = 0;
};

// =============================================
// Familia: Tema Claro (similar a Fusion Light)
// =============================================
class BotonClaro : public BotonUI {
public:
    void dibujar() const override {
        qDebug() << "  [Claro] Boton: fondo blanco, borde gris";
    }
    QString estiloCSS() const override {
        return "background: #FFFFFF; border: 1px solid #CCC; color: #333;";
    }
};

class PanelClaro : public PanelUI {
public:
    void dibujar() const override {
        qDebug() << "  [Claro] Panel: fondo #F5F5F5, sombra suave";
    }
    QString estiloCSS() const override {
        return "background: #F5F5F5; border-radius: 8px;";
    }
};

class IconoClaro : public IconoUI {
public:
    void dibujar() const override {
        qDebug() << "  [Claro] Icono: trazos oscuros sobre fondo claro";
    }
    QString recurso() const override {
        return "qrc:/icons/light/";
    }
};

// =============================================
// Familia: Tema Oscuro (similar a este proyecto)
// =============================================
class BotonOscuro : public BotonUI {
public:
    void dibujar() const override {
        qDebug() << "  [Oscuro] Boton: fondo #2D2D2D, texto #00D1A9";
    }
    QString estiloCSS() const override {
        return "background: #2D2D2D; color: #00D1A9; border: none;";
    }
};

class PanelOscuro : public PanelUI {
public:
    void dibujar() const override {
        qDebug() << "  [Oscuro] Panel: fondo #1E1E1E, borde #333";
    }
    QString estiloCSS() const override {
        return "background: #1E1E1E; border: 1px solid #333;";
    }
};

class IconoOscuro : public IconoUI {
public:
    void dibujar() const override {
        qDebug() << "  [Oscuro] Icono: trazos teal sobre fondo oscuro";
    }
    QString recurso() const override {
        return "qrc:/icons/dark/";
    }
};

// =============================================
// Abstract Factory: Similar a QStyleFactory
// =============================================
class TemaFactory {
public:
    virtual ~TemaFactory() = default;
    virtual std::unique_ptr<BotonUI> crearBoton() const = 0;
    virtual std::unique_ptr<PanelUI> crearPanel() const = 0;
    virtual std::unique_ptr<IconoUI> crearIcono() const = 0;
    virtual QString nombre() const = 0;
};

class TemaClaroFactory : public TemaFactory {
public:
    std::unique_ptr<BotonUI> crearBoton() const override {
        return std::make_unique<BotonClaro>();
    }
    std::unique_ptr<PanelUI> crearPanel() const override {
        return std::make_unique<PanelClaro>();
    }
    std::unique_ptr<IconoUI> crearIcono() const override {
        return std::make_unique<IconoClaro>();
    }
    QString nombre() const override { return "Claro"; }
};

class TemaOscuroFactory : public TemaFactory {
public:
    std::unique_ptr<BotonUI> crearBoton() const override {
        return std::make_unique<BotonOscuro>();
    }
    std::unique_ptr<PanelUI> crearPanel() const override {
        return std::make_unique<PanelOscuro>();
    }
    std::unique_ptr<IconoUI> crearIcono() const override {
        return std::make_unique<IconoOscuro>();
    }
    QString nombre() const override { return "Oscuro"; }
};

// Selector de tema (simula QStyleFactory::create)
std::unique_ptr<TemaFactory> crearTema(const QString& nombre) {
    if (nombre.toLower() == "claro") {
        return std::make_unique<TemaClaroFactory>();
    }
    return std::make_unique<TemaOscuroFactory>();
}

// =============================================
// Aplicación que usa la fábrica
// =============================================
void construirVentana(const TemaFactory& tema) {
    qDebug() << "Construyendo ventana con tema:" << tema.nombre();

    auto panel = tema.crearPanel();
    auto boton = tema.crearBoton();
    auto icono = tema.crearIcono();

    panel->dibujar();
    qDebug() << "  CSS:" << panel->estiloCSS();

    boton->dibujar();
    qDebug() << "  CSS:" << boton->estiloCSS();

    icono->dibujar();
    qDebug() << "  Recurso:" << icono->recurso();
}

int main(int argc, char *argv[]) {
    QCoreApplication app(argc, argv);

    qDebug() << "=== Abstract Factory con Qt ===";

    // Crear interfaz con tema claro
    qDebug() << "\n--- Tema Claro ---";
    auto temaClaro = crearTema("claro");
    construirVentana(*temaClaro);

    // Cambiar a tema oscuro (como en QML-SnippetsExamples)
    qDebug() << "\n--- Tema Oscuro ---";
    auto temaOscuro = crearTema("oscuro");
    construirVentana(*temaOscuro);

    // Nota sobre Qt real
    qDebug() << "\n--- Nota sobre Qt ---";
    qDebug() << "En Qt real, QStyleFactory::create('Fusion')";
    qDebug() << "actua como Abstract Factory para todos los";
    qDebug() << "elementos visuales de la aplicacion.";

    return 0;
}
```
<---Ejemplo con Qt Result--->
=== Abstract Factory con Qt ===

--- Tema Claro ---
Construyendo ventana con tema: "Claro"
  [Claro] Panel: fondo #F5F5F5, sombra suave
  CSS: "background: #F5F5F5; border-radius: 8px;"
  [Claro] Boton: fondo blanco, borde gris
  CSS: "background: #FFFFFF; border: 1px solid #CCC; color: #333;"
  [Claro] Icono: trazos oscuros sobre fondo claro
  Recurso: "qrc:/icons/light/"

--- Tema Oscuro ---
Construyendo ventana con tema: "Oscuro"
  [Oscuro] Panel: fondo #1E1E1E, borde #333
  CSS: "background: #1E1E1E; border: 1px solid #333;"
  [Oscuro] Boton: fondo #2D2D2D, texto #00D1A9
  CSS: "background: #2D2D2D; color: #00D1A9; border: none;"
  [Oscuro] Icono: trazos teal sobre fondo oscuro
  Recurso: "qrc:/icons/dark/"

--- Nota sobre Qt ---
En Qt real, QStyleFactory::create('Fusion')
actua como Abstract Factory para todos los
elementos visuales de la aplicacion.
