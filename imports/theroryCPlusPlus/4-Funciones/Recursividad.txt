<---EXPLANATION--->
### Recursividad en C++

La recursividad es una técnica de programación en la que una función se llama a sí misma para resolver subproblemas más pequeños de un problema más grande. Esta técnica puede simplificar la resolución de problemas que tienen una estructura repetitiva o fractal, como problemas matemáticos, algoritmos de búsqueda y problemas relacionados con estructuras de datos.

#### Conceptos Básicos de Recursividad

1. **Caso Base:** Es la condición que termina la recursión. Sin un caso base, la función recursiva se llamaría a sí misma indefinidamente, lo que llevaría a un desbordamiento de pila.
2. **Caso Recursivo:** Es la parte de la función donde se hace la llamada recursiva. Esta llamada divide el problema en subproblemas más pequeños.

#### Ejemplo Clásico: Factorial de un Número

El factorial de un número `n` (denotado como `n!`) se define como el producto de todos los números enteros positivos hasta `n`. Matemáticamente, se define como:
- `0! = 1`
- `n! = n * (n - 1)!` para `n > 0`

##### Implementación Recursiva del Factorial

```cpp
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n == 0) { // Caso base
        return 1;
    } else { // Caso recursivo
        return n * factorial(n - 1);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " es " << factorial(numero) << endl;
    return 0;
}
```

En este ejemplo:
- **Caso Base:** `if (n == 0) return 1;` detiene la recursión cuando `n` es 0.
- **Caso Recursivo:** `return n * factorial(n - 1);` llama a la función con `n - 1`.

#### Ejemplo: Serie de Fibonacci

La serie de Fibonacci es una secuencia donde cada número es la suma de los dos anteriores. Matemáticamente, se define como:
- `F(0) = 0`
- `F(1) = 1`
- `F(n) = F(n - 1) + F(n - 2)` para `n > 1`

##### Implementación Recursiva de Fibonacci

```cpp
#include <iostream>
using namespace std;

int fibonacci(int n) {
    if (n <= 1) { // Casos base
        return n;
    } else { // Caso recursivo
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci es " << fibonacci(numero) << endl;
    return 0;
}
```

En este ejemplo:
- **Casos Base:** `if (n <= 1) return n;` detiene la recursión cuando `n` es 0 o 1.
- **Caso Recursivo:** `return fibonacci(n - 1) + fibonacci(n - 2);` llama a la función con `n - 1` y `n - 2`.

#### Recursividad de Cola

La recursividad de cola es una forma especial de recursión donde la llamada recursiva es la última operación que se realiza. Los compiladores pueden optimizar la recursividad de cola para evitar el desbordamiento de pila.

##### Ejemplo de Recursividad de Cola

```cpp
#include <iostream>
using namespace std;

int factorialCola(int n, int acumulador = 1) {
    if (n == 0) { // Caso base
        return acumulador;
    } else { // Caso recursivo de cola
        return factorialCola(n - 1, n * acumulador);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " (usando recursividad de cola) es " << factorialCola(numero) << endl;
    return 0;
}
```

En este ejemplo:
- **Caso Base:** `if (n == 0) return acumulador;` detiene la recursión cuando `n` es 0.
- **Caso Recursivo de Cola:** `return factorialCola(n - 1, n * acumulador);` pasa el cálculo parcial al siguiente llamado.

#### Consideraciones y Buenas Prácticas

1. **Evitar Desbordamientos de Pila:** La recursividad profunda puede llevar a un desbordamiento de pila. Utiliza recursividad de cola cuando sea posible y considera algoritmos iterativos para problemas grandes.
2. **Optimización:** Algunos problemas recursivos pueden beneficiarse de la memoización, donde se almacenan los resultados de subproblemas ya resueltos para evitar cálculos redundantes.
3. **Claridad del Código:** Asegúrate de que los casos base y recursivos estén claramente definidos y documentados para facilitar el mantenimiento y la comprensión del código.

#### Ejemplo Completo con Memoización

Memoización es una técnica de optimización que almacena los resultados de subproblemas para evitar cálculos redundantes.

##### Implementación de Fibonacci con Memoización

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> memo(100, -1); // Inicializar con -1

int fibonacciMemo(int n) {
    if (n <= 1) { // Casos base
        return n;
    }
    if (memo[n] != -1) { // Verificar si el resultado ya está calculado
        return memo[n];
    }
    // Calcular y almacenar el resultado
    memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
    return memo[n];
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci (con memoización) es " << fibonacciMemo(numero) << endl;
    return 0;
}
```

### Recursividad en Tiempo de Compilación con `constexpr`

C++ moderno permite que las funciones recursivas se evalúen en tiempo de compilación utilizando `constexpr`. Esto significa que el compilador calcula el resultado durante la compilación en lugar de en tiempo de ejecución, lo que elimina completamente el costo de la recursión. Los resultados de funciones `constexpr` pueden usarse donde se requiere un valor constante, como tamaños de arrays o parámetros de plantillas.

##### Ejemplo de Recursividad `constexpr`

```cpp
#include <iostream>
#include <array>
using namespace std;

constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}

constexpr int fibonacci(int n) {
    return (n <= 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    // Evaluados en tiempo de compilación
    constexpr int fact5 = factorial(5);    // 120
    constexpr int fib10 = fibonacci(10);   // 55

    // Usar como tamaño de array (requiere constexpr)
    array<int, factorial(4)> arr; // array de 24 elementos

    cout << "Factorial de 5: " << fact5 << endl;
    cout << "Fibonacci de 10: " << fib10 << endl;
    return 0;
}
```

### Fold Expressions como Alternativa (C++17)

Las **fold expressions** (expresiones de plegado), introducidas en C++17, permiten aplicar un operador a todos los elementos de un paquete de parámetros de plantilla sin necesidad de recursión explícita. Son una alternativa moderna y más concisa a los patrones recursivos clásicos con plantillas variádicas que se usaban antes de C++17.

Con fold expressions, lo que antes requería una función base y una función recursiva se puede expresar en una sola línea usando la sintaxis `(args op ...)` o `(... op args)`.

##### Ejemplo de Fold Expressions

```cpp
#include <iostream>
using namespace std;

// Recursión clásica con templates (pre-C++17)
template<typename T>
T sumarTodo(T valor) { return valor; }

template<typename T, typename... Args>
T sumarTodo(T primero, Args... resto) {
    return primero + sumarTodo(resto...);
}

// Fold expression (C++17) - reemplaza la recursión
template<typename... Args>
auto sumarFold(Args... args) {
    return (args + ...); // Fold expression
}

template<typename... Args>
void imprimirTodo(Args... args) {
    ((cout << args << " "), ...); // Fold expression con comma
    cout << endl;
}

int main() {
    cout << "Suma recursiva: " << sumarTodo(1, 2, 3, 4, 5) << endl;
    cout << "Suma fold: " << sumarFold(1, 2, 3, 4, 5) << endl;
    imprimirTodo("Hola", 42, 3.14, "mundo");
    return 0;
}
```

### Conclusión

La recursividad es una herramienta poderosa en C++ que permite resolver problemas complejos dividiéndolos en subproblemas más simples. Entender y aplicar correctamente los casos base y recursivos es crucial para evitar errores y optimizar el rendimiento. La recursividad de cola y la memoización son técnicas avanzadas que pueden mejorar la eficiencia y evitar problemas comunes como el desbordamiento de pila. Con una comprensión sólida de la recursividad, los desarrolladores pueden abordar una amplia gama de problemas algorítmicos de manera efectiva.
<---FILES--->
Implementación Recursiva del Factorial
Implementación Recursiva del Factorial Result
Implementación Recursiva de Fibonacci
Implementación Recursiva de Fibonacci Result
Ejemplo de Recursividad de Cola
Ejemplo de Recursividad de Cola Result
Implementación de Fibonacci con Memoización
Implementación de Fibonacci con Memoización Result
Ejemplo de Recursividad `constexpr`
Ejemplo de Recursividad `constexpr` Result
Ejemplo de Fold Expressions
Ejemplo de Fold Expressions Result
<---Implementación Recursiva del Factorial--->
```cpp
#include <iostream>
using namespace std;

int factorial(int n) {
    if (n == 0) { // Caso base
        return 1;
    } else { // Caso recursivo
        return n * factorial(n - 1);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " es " << factorial(numero) << endl;
    return 0;
}
<---Implementación Recursiva del Factorial Result--->
<---Implementación Recursiva de Fibonacci--->
```cpp
#include <iostream>
using namespace std;

int fibonacci(int n) {
    if (n <= 1) { // Casos base
        return n;
    } else { // Caso recursivo
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci es " << fibonacci(numero) << endl;
    return 0;
}
<---Implementación Recursiva de Fibonacci Result--->
<---Ejemplo de Recursividad de Cola--->
```cpp
#include <iostream>
using namespace std;

int factorialCola(int n, int acumulador = 1) {
    if (n == 0) { // Caso base
        return acumulador;
    } else { // Caso recursivo de cola
        return factorialCola(n - 1, n * acumulador);
    }
}

int main() {
    int numero = 5;
    cout << "El factorial de " << numero << " (usando recursividad de cola) es " << factorialCola(numero) << endl;
    return 0;
}
<---Ejemplo de Recursividad de Cola Result--->
<---Implementación de Fibonacci con Memoización--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> memo(100, -1); // Inicializar con -1

int fibonacciMemo(int n) {
    if (n <= 1) { // Casos base
        return n;
    }
    if (memo[n] != -1) { // Verificar si el resultado ya está calculado
        return memo[n];
    }
    // Calcular y almacenar el resultado
    memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);
    return memo[n];
}

int main() {
    int numero = 10;
    cout << "El término " << numero << " de la serie de Fibonacci (con memoización) es " << fibonacciMemo(numero) << endl;
    return 0;
}
<---Implementación de Fibonacci con Memoización Result--->
<---Ejemplo de Recursividad `constexpr`--->
```cpp
#include <iostream>
#include <array>
using namespace std;

constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}

constexpr int fibonacci(int n) {
    return (n <= 1) ? n : fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    // Evaluados en tiempo de compilación
    constexpr int fact5 = factorial(5);    // 120
    constexpr int fib10 = fibonacci(10);   // 55

    // Usar como tamaño de array (requiere constexpr)
    array<int, factorial(4)> arr; // array de 24 elementos

    cout << "Factorial de 5: " << fact5 << endl;
    cout << "Fibonacci de 10: " << fib10 << endl;
    return 0;
}
<---Ejemplo de Recursividad `constexpr` Result--->
<---Ejemplo de Fold Expressions--->
```cpp
#include <iostream>
using namespace std;

// Recursión clásica con templates (pre-C++17)
template<typename T>
T sumarTodo(T valor) { return valor; }

template<typename T, typename... Args>
T sumarTodo(T primero, Args... resto) {
    return primero + sumarTodo(resto...);
}

// Fold expression (C++17) - reemplaza la recursión
template<typename... Args>
auto sumarFold(Args... args) {
    return (args + ...); // Fold expression
}

template<typename... Args>
void imprimirTodo(Args... args) {
    ((cout << args << " "), ...); // Fold expression con comma
    cout << endl;
}

int main() {
    cout << "Suma recursiva: " << sumarTodo(1, 2, 3, 4, 5) << endl;
    cout << "Suma fold: " << sumarFold(1, 2, 3, 4, 5) << endl;
    imprimirTodo("Hola", 42, 3.14, "mundo");
    return 0;
}
<---Ejemplo de Fold Expressions Result--->
