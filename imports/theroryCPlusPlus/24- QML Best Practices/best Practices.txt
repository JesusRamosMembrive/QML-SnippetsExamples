<---EXPLANATION--->
### Strong Typing en QML

En QML, ‚Äústrong typing‚Äù significa declarar expl√≠citamente el tipo de cada propiedad, se√±al y funci√≥n, en lugar de usar var o depender de coerciones din√°micas del motor JavaScript.

Aunque QML est√° basado en JavaScript (din√°mico), el sistema de tipos de Qt (meta-object system) permite un modelo fuertemente tipado que mejora:

Rendimiento

Seguridad en tiempo de compilaci√≥n

Soporte del tooling (qmllint, qmltc, QML Language Server)

## Strong Typing en QML

En QML, ‚Äústrong typing‚Äù significa **declarar expl√≠citamente el tipo de cada propiedad, se√±al y funci√≥n**, en lugar de usar `var` o depender de coerciones din√°micas del motor JavaScript.

Aunque QML est√° basado en JavaScript (din√°mico), el sistema de tipos de Qt (meta-object system) permite un **modelo fuertemente tipado** que mejora:

* Rendimiento
* Seguridad en tiempo de compilaci√≥n
* Soporte del tooling (qmllint, qmltc, QML Language Server)
* Integraci√≥n con C++

---

## 1. Tipado d√©bil vs fuerte en QML

### ‚ùå D√©bil (din√°mico)

```qml
Item {
    property var value: 10
}
```

Problemas:

* Puede almacenar cualquier tipo.
* Cambios de tipo en runtime.
* Menor optimizaci√≥n.
* Errores detectados tarde.

Ejemplo peligroso:

```qml
value = "hello"
value = 42
value = Qt.rect(0,0,10,10)
```

El motor lo permite.

---

### ‚úÖ Fuerte (recomendado)

```qml
Item {
    property int value: 10
}
```

Ahora:

* Solo acepta `int`
* Error inmediato si asignas otro tipo
* Mejor optimizaci√≥n por el engine

---

## 2. Tipos b√°sicos recomendados

En QML debes usar siempre:

| Tipo QML                | Equivalente       |
| ----------------------- | ----------------- |
| `int`                   | entero 32 bits    |
| `real`                  | double            |
| `bool`                  | boolean           |
| `string`                | QString           |
| `color`                 | QColor            |
| `url`                   | QUrl              |
| `date`                  | QDateTime         |
| `point`, `rect`, `size` | tipos geom√©tricos |
| `list<Type>`            | lista tipada      |

---

## 3. Tipado en propiedades

### ‚úî Correcto

```qml
Rectangle {
    property int count: 0
    property real opacityFactor: 0.8
    property string title: "Dashboard"
    property color background: "#1A1D23"
}
```

### ‚ùå Evitar

```qml
property var count
property var config
property var model
```

Salvo que realmente necesites polimorfismo din√°mico.

---

## 4. Tipado en funciones (QML moderno)

Desde Qt 6 puedes tipar par√°metros y retorno:

```qml
function add(a: int, b: int): int {
    return a + b
}
```

Beneficios:

* Detecci√≥n est√°tica de errores
* Mejor integraci√≥n con C++
* Mejores diagn√≥sticos en QML Language Server

---

## 5. Tipado en signals

```qml
signal valueChanged(newValue: int)
```

En lugar de:

```qml
signal valueChanged(newValue)
```

Esto evita errores silenciosos.

---

## 6. Listas tipadas

Muy importante para modelos:

```qml
property list<int> values: [1, 2, 3]
```

O para objetos:

```qml
property list<Item> childrenItems
```

Evita:

```qml
property var items
```

---

## 7. Strong typing + C++

Aqu√≠ es donde realmente gana valor.

Si tienes en C++:

```cpp
Q_PROPERTY(int count READ count WRITE setCount NOTIFY countChanged)
```

En QML:

```qml
property int count: backend.count
```

El sistema mantiene consistencia fuerte entre ambos mundos.

---

## 8. Beneficios reales en producci√≥n

### 1Ô∏è‚É£ Rendimiento

El motor puede optimizar bindings porque:

* Sabe el tipo
* No necesita hacer coerciones din√°micas
* Reduce boxing/unboxing

Esto importa en:

* UIs complejas
* Dashboards industriales
* Gr√°ficos en tiempo real
* Aplicaciones embebidas

En tu contexto (Qt + c√°maras IR + visualizaci√≥n), esto **s√≠ impacta**.

---

### 2Ô∏è‚É£ qmltc / compilaci√≥n AOT

Qt 6 permite compilar QML a C++.

Eso requiere tipado fuerte.

Si usas `var` por todas partes, pierdes muchas ventajas del compilador.

---

### 3Ô∏è‚É£ qmllint y tooling

Con strong typing:

* Detecci√≥n de tipos incorrectos
* Detecci√≥n de propiedades inexistentes
* Mejor autocompletado

---

## 9. Cu√°ndo usar `var`

Solo cuando:

* Manejas JSON din√°mico
* Recibes datos externos no estructurados
* Haces meta-programaci√≥n
* Necesitas polimorfismo real

Ejemplo v√°lido:

```qml
property var jsonConfig: ({})
```

Pero incluso aqu√≠, en sistemas grandes, es mejor:

* Parsear
* Mapear a un objeto tipado
* Usar una Store bien definida

---

## 10. Error conceptual com√∫n

Muchos desarrolladores creen que:

> ‚ÄúQML es JavaScript, as√≠ que uso var para todo‚Äù

Eso es un error arquitect√≥nico.

QML es declarativo + fuertemente integrado con el sistema de tipos de Qt.

Si lo usas como JS suelto:

* Pierdes robustez
* Pierdes tooling
* Introduces errores silenciosos
* Dificultas mantenimiento

---

## 11. Recomendaciones pr√°cticas (nivel producci√≥n)

Para tu perfil t√©cnico y objetivos:

1. Evita `var` salvo necesidad real.
2. Tipar siempre se√±ales.
3. Tipar funciones.
4. Usar `required property` cuando aplique.
5. Alinear tipos QML con Q_PROPERTY en C++.
6. Activar `qmllint` en CI.
7. Evaluar `qmltc` en proyectos grandes.

---

## 12. Ejemplo completo correcto

```qml
// Counter.qml
import QtQuick

Item {
    id: root

    required property int initialValue
    property int value: initialValue

    signal valueChanged(newValue: int)

    function increment(step: int): void {
        value += step
        valueChanged(value)
    }
}
```

Uso:

```qml
Counter {
    initialValue: 10
    onValueChanged: console.log("New value:", newValue)
}
```

Todo tipado.
Cero ambig√ºedad.
M√°xima claridad.

---

## Conclusi√≥n

Strong typing en QML no es una recomendaci√≥n est√©tica.
Es una decisi√≥n arquitect√≥nica.

En sistemas industriales, UI complejas o aplicaciones que integran C++ (como en tu caso), no usarlo es t√©cnicamente inferior.

Si quieres, podemos profundizar en:

* Strong typing + Models
* Strong typing + Singleton stores (Neptune-like)
* Strong typing + QML/C++ boundary
* Impacto real en performance en sistemas embebidos

Elige el siguiente nivel.




## Avoid Duck Typing en QML

En QML, ‚Äúavoid duck typing‚Äù significa **no depender de que un objeto ‚Äútenga ciertas propiedades‚Äù en runtime sin que exista un contrato tipado expl√≠cito**.

Duck typing =

> ‚ÄúSi parece un pato y camina como un pato, entonces es un pato.‚Äù

En JavaScript esto es habitual.
En QML de producci√≥n (Qt 6, C++ integration, tooling moderno) es una mala pr√°ctica arquitect√≥nica.

---

# 1. ¬øQu√© es duck typing en QML?

Ejemplo t√≠pico:

```qml
function process(item) {
    item.value += 1
    item.reset()
}
```

Aqu√≠:

* `item` no tiene tipo
* No existe contrato
* Se asume que tiene `.value`
* Se asume que tiene `.reset()`

Si no lo tiene ‚Üí error en runtime.

Esto es **duck typing**.

---

# 2. Por qu√© es problem√°tico en QML

En un sistema serio (industrial UI, instrumentaci√≥n, dashboards, embebido):

### ‚ùå 1. Errores tard√≠os

Falla solo cuando se ejecuta.

### ‚ùå 2. Sin validaci√≥n est√°tica

qmllint no puede ayudarte.

### ‚ùå 3. Sin autocompletado

El Language Server pierde informaci√≥n.

### ‚ùå 4. Peor optimizaci√≥n

El engine no puede inferir tipos.

### ‚ùå 5. Rompe contrato C++/QML

Si C++ expone Q_PROPERTY tipadas, no tiene sentido ignorarlo.

---

# 3. Ejemplo real de mala pr√°ctica

```qml
property var backend

Component.onCompleted: {
    backend.start()
}
```

Si `backend` no tiene `start()`:

* Crash silencioso
* Dif√≠cil debugging
* No detectable en an√°lisis est√°tico

Esto es arquitectura d√©bil.

---

# 4. Alternativa correcta: Strong contracts

## ‚úî Tipado expl√≠cito

```qml
property Backend backend
```

Donde `Backend` es un tipo registrado desde C++:

```cpp
class Backend : public QObject {
    Q_OBJECT
    Q_INVOKABLE void start();
};
```

Ahora:

* Si `start()` no existe ‚Üí error inmediato
* Tooling funciona
* Contrato claro

---

# 5. Duck typing con se√±ales (error frecuente)

### ‚ùå Incorrecto

```qml
signal dataReady(data)
```

El par√°metro puede ser cualquier cosa.

### ‚úî Correcto

```qml
signal dataReady(data: int)
```

O si es objeto:

```qml
signal dataReady(data: BackendData)
```

---

# 6. Duck typing en modelos

### ‚ùå Muy com√∫n

```qml
delegate: Text {
    text: model.name
}
```

Si el modelo cambia y ya no tiene `name`:

‚Üí fallo silencioso

### ‚úî Mejor

Usar `required property`

```qml
delegate: Item {
    required property string name
    Text { text: name }
}
```

Ahora el delegado exige contrato.

---

# 7. Duck typing con `var` (el mayor problema)

```qml
property var config
```

Luego:

```qml
if (config.enabled)
    start()
```

Si `config` no tiene `enabled`:

‚Üí undefined
‚Üí comportamiento inesperado

---

# 8. C√≥mo eliminar duck typing en proyectos serios

## 1Ô∏è‚É£ Usar tipos concretos en properties

```qml
property int
property real
property string
property color
property url
```

## 2Ô∏è‚É£ Registrar tipos C++ bien definidos

```cpp
qmlRegisterType<Backend>("App", 1, 0, "Backend");
```

Y usar:

```qml
property Backend backend
```

---

## 3Ô∏è‚É£ Usar `required property` en delegados

Esto es clave en Qt 6.

```qml
required property string title
required property int value
```

---

## 4Ô∏è‚É£ Tipar funciones

```qml
function compute(value: int): real {
    return value * 1.5
}
```

---

## 5Ô∏è‚É£ Tipar listas

```qml
property list<int> values
property list<Backend> devices
```

---

# 9. Caso pr√°ctico: Dashboard industrial

### ‚ùå Arquitectura d√©bil

```qml
function updateDevice(device) {
    device.temperature = 42
    device.refresh()
}
```

No hay contrato.

---

### ‚úî Arquitectura robusta

```qml
function updateDevice(device: Device): void {
    device.temperature = 42
    device.refresh()
}
```

Si `Device` est√° registrado:

* Validaci√≥n est√°tica
* Mejor tooling
* M√°s mantenible

---

# 10. Cu√°ndo duck typing puede ser aceptable

Solo en:

* JSON din√°mico externo
* Prototipado r√°pido
* C√≥digo experimental

Pero en producci√≥n:

> Siempre modelar datos y contratos.

---

# 11. Relaci√≥n con qmltc y AOT

Duck typing impide:

* Compilaci√≥n eficiente
* An√°lisis est√°tico fuerte
* Eliminaci√≥n de checks din√°micos

Si quieres QML cercano a C++ en robustez,
duck typing es un obst√°culo.

---

# 12. Error conceptual frecuente

Muchos desarrolladores piensan:

> ‚ÄúQML es JS, as√≠ que escribo JS din√°mico‚Äù

Incorrecto.

QML es:

* Declarativo
* Tipado
* Integrado con C++
* Dise√±ado para tooling

Si lo usas como JS suelto, pierdes sus ventajas.

---

# 13. Resumen t√©cnico

| Duck Typing                | Strong Contract    |
| -------------------------- | ------------------ |
| `var`                      | tipo expl√≠cito     |
| par√°metros sin tipo        | par√°metros tipados |
| se√±ales sin tipo           | se√±ales tipadas    |
| acceso libre a propiedades | required property  |
| errores runtime            | errores est√°ticos  |

---

## Conclusi√≥n

Avoid duck typing no es una recomendaci√≥n estil√≠stica.
Es una decisi√≥n de dise√±o arquitect√≥nico.

En sistemas industriales, IR cameras, UI complejas o aplicaciones embebidas (tu contexto real), usar duck typing:

* Reduce confiabilidad
* Aumenta deuda t√©cnica
* Empeora tooling
* Limita optimizaci√≥n

# Declarative Bindings Rather Than Imperative Assignments (QML)

Este principio es **central** en QML.
Si no lo interiorizas, acabas escribiendo ‚ÄúJavaScript con UI‚Äù en lugar de aprovechar el motor declarativo.

---

# 1. Modelo mental correcto

QML no est√° pensado para:

> ‚ÄúCuando pasa X, entonces asigno Y‚Äù

Est√° pensado para:

> ‚ÄúY depende de X‚Äù

Eso cambia completamente la arquitectura.

---

# 2. Imperativo (incorrecto en la mayor√≠a de casos)

```qml
Rectangle {
    id: rect
    width: 100
    height: 100

    MouseArea {
        anchors.fill: parent
        onClicked: {
            rect.color = "red"
        }
    }
}
```

Aqu√≠ est√°s:

* Ejecutando c√≥digo
* Mutando estado
* Rompiendo posible binding previo
* Introduciendo dependencia manual

Es un enfoque reactivo manual.

---

# 3. Declarativo (correcto)

```qml
Rectangle {
    id: rect
    width: 100
    height: 100

    property bool pressed: false
    color: pressed ? "red" : "blue"

    MouseArea {
        anchors.fill: parent
        onPressed: rect.pressed = true
        onReleased: rect.pressed = false
    }
}
```

Ahora:

* `color` no se asigna
* `color` depende de `pressed`
* El motor mantiene coherencia autom√°ticamente

Eso es un **binding declarativo**.

---

# 4. Qu√© es realmente un binding

Cuando escribes:

```qml
color: pressed ? "red" : "blue"
```

No est√°s asignando un valor.
Est√°s registrando una **expresi√≥n reactiva**.

El motor:

1. Analiza dependencias (`pressed`)
2. Construye un grafo
3. Recalcula autom√°ticamente cuando cambia

---

# 5. Problema grave: romper bindings sin querer

Caso cl√°sico:

```qml
color: someCondition ? "red" : "blue"
```

Luego en alg√∫n sitio:

```qml
rect.color = "green"
```

Acabas de romper el binding.

Desde ese momento:

* `color` deja de depender de `someCondition`
* El sistema deja de ser declarativo
* Debugging dif√≠cil

Este error es muy com√∫n.

---

# 6. Regla de oro

> No reasignes propiedades que ya tienen binding.

Si necesitas cambiar comportamiento:

* Cambia la fuente
* No cambies el resultado

---

# 7. Ejemplo t√≠pico de arquitectura mala

```qml
Text {
    id: label
    text: "Idle"
}

Connections {
    target: backend
    function onStateChanged(newState) {
        if (newState === 0)
            label.text = "Idle"
        else if (newState === 1)
            label.text = "Running"
        else
            label.text = "Error"
    }
}
```

Esto es imperativo.

---

# 8. Reescritura declarativa

```qml
Text {
    text: {
        switch (backend.state) {
        case 0: return "Idle"
        case 1: return "Running"
        default: return "Error"
        }
    }
}
```

Ahora:

* `text` depende de `backend.state`
* No hay mutaciones
* No hay riesgo de incoherencia

---

# 9. Caso real: UI industrial (tu contexto)

Sup√≥n que tienes:

* C√°mara IR
* Estado de adquisici√≥n
* Nivel de ganancia
* Temperatura del sensor

Mal enfoque:

```qml
onTemperatureChanged: {
    if (temperature > 80)
        warning.visible = true
    else
        warning.visible = false
}
```

Correcto:

```qml
warning.visible: temperature > 80
```

Eso es robusto.
Eso escala.
Eso mantiene coherencia.

---

# 10. ¬øCu√°ndo s√≠ usar imperativo?

Solo cuando:

* Necesitas efectos laterales
* L√≥gica transaccional
* Inicializaci√≥n compleja
* Interacci√≥n con C++
* Animaciones controladas manualmente

Pero nunca para estado derivado.

---

# 11. Arquitectura recomendada (nivel serio)

Separar:

### üîπ Estado base (source of truth)

```qml
property int state
property real temperature
property bool connected
```

### üîπ Estado derivado (solo bindings)

```qml
property bool isOverheated: temperature > 80
property bool canStart: connected && state === 0
```

### üîπ UI depende de estado derivado

```qml
Button {
    enabled: canStart
}
```

Eso elimina l√≥gica imperativa dispersa.

---

# 12. Binding avanzado: Qt.binding()

Si necesitas restaurar un binding roto:

```qml
rect.color = Qt.binding(function() {
    return pressed ? "red" : "blue"
})
```

Pero si necesitas esto, probablemente tu arquitectura ya est√° mal.

---

# 13. Errores t√≠picos que debes evitar

## ‚ùå 1. L√≥gica en `onXChanged` que solo actualiza otra propiedad

Eso deber√≠a ser binding.

---

## ‚ùå 2. Cascadas manuales

```qml
onAChanged: b = computeFromA()
onBChanged: c = computeFromB()
```

Esto es fr√°gil.

---

## ‚úî Alternativa

```qml
property int b: computeFromA(a)
property int c: computeFromB(b)
```

El motor gestiona dependencias.

---

# 14. Impacto en rendimiento

Bindings declarativos:

* Se eval√∫an solo cuando cambian dependencias
* Est√°n optimizados en C++
* Son m√°s eficientes que JS imperativo repetitivo

En sistemas de alto refresco (video IR, gr√°ficos en tiempo real), esto importa.

---

# 15. Relaci√≥n con otros principios

Este principio est√° directamente conectado con:

* Strong typing
* Avoid duck typing
* Unidirectional data flow
* Single source of truth
* Arquitectura tipo Store

Si los combinas, tu QML se vuelve:

* Predecible
* Escalable
* Analizable est√°ticamente
* Optimizable

---

# 16. Patr√≥n recomendado para ti (nivel avanzado)

Dado tu perfil y tus proyectos Qt/C++:

1. C++ mantiene estado real.
2. QML solo declara dependencias.
3. Cero l√≥gica imperativa de UI.
4. Cero mutaciones cruzadas.

Eso te acerca a una arquitectura tipo:

* Neptune 3 UI
* MVVM fuerte
* Store-based design

---

# Resumen t√©cnico

| Imperativo             | Declarativo           |
| ---------------------- | --------------------- |
| Mutaci√≥n manual        | Dependencia declarada |
| onXChanged actualiza Y | Y depende de X        |
| Estado disperso        | Estado derivado       |
| Dif√≠cil debugging      | Flujo predecible      |
| Rompe bindings         | Mantiene reactividad  |

---

## Conclusi√≥n

Declarative bindings no es estilo.
Es la esencia del motor QML.

Si empiezas a escribir demasiados `onXChanged`,
est√°s programando contra el framework.

# Property Evaluation and Signal Emission Order Must Not Be Relied On (QML)

Este principio es cr√≠tico en QML y suele ignorarse hasta que aparece un bug no determinista.

> No debes basar tu l√≥gica en el orden en que se eval√∫an bindings ni en el orden en que se emiten se√±ales.

El motor QML es reactivo y dirigido por un grafo de dependencias.
No es un flujo imperativo secuencial garantizado.

---

# 1. El problema real

Muchos desarrolladores asumen impl√≠citamente que:

* Primero cambia A
* Luego cambia B
* Luego se ejecuta onAChanged
* Luego onBChanged

Eso **no est√° garantizado**.

El motor:

* Recalcula bindings seg√∫n dependencias
* Puede reordenar evaluaciones
* Puede agrupar cambios
* Puede optimizar ciclos

Especialmente en Qt 6 con optimizaciones m√°s agresivas.

---

# 2. Ejemplo cl√°sico incorrecto

```qml
Item {
    property int a: 0
    property int b: a + 1

    onAChanged: {
        console.log("A changed, B is:", b)
    }
}
```

Aqu√≠ est√°s asumiendo que cuando `onAChanged` se ejecuta:

* `b` ya se ha recalculado.

Eso **no es contractual**.

Puede funcionar hoy.
Puede romper ma√±ana.

---

# 3. Caso m√°s peligroso: l√≥gica dependiente del orden

```qml
Item {
    property int a: 0
    property int b: 0

    onAChanged: {
        b = a + 1
    }

    onBChanged: {
        if (b > 10)
            a = 0
    }
}
```

Esto introduce:

* Dependencia circular
* Comportamiento no determinista
* Posibles loops
* Orden dependiente del motor

Es fr√°gil.

---

# 4. Qu√© hace realmente el motor

Cuando cambia una propiedad:

1. Marca dependencias como ‚Äúdirty‚Äù
2. Eval√∫a grafo
3. Ejecuta handlers
4. Puede colapsar evaluaciones

No es una secuencia lineal simple.

---

# 5. Soluci√≥n: eliminar dependencia del orden

## ‚ùå Incorrecto (orden impl√≠cito)

```qml
onXChanged: {
    y = computeFromX()
}
```

## ‚úî Correcto (declarativo)

```qml
property int y: computeFromX(x)
```

Ahora:

* No importa cu√°ndo se eval√∫e
* y siempre es coherente con x
* No dependes del orden de se√±ales

---

# 6. Otro ejemplo realista (UI industrial)

Sup√≥n:

```qml
property real temperature
property bool overheated

onTemperatureChanged: {
    overheated = temperature > 80
}
```

Est√°s confiando en:

* Que temperature cambie antes
* Que overheated se asigne despu√©s
* Que no haya interferencias

Correcto:

```qml
property bool overheated: temperature > 80
```

Orden irrelevante.
Estado consistente.

---

# 7. Problema con m√∫ltiples dependencias

Ejemplo incorrecto:

```qml
property int a
property int b
property int sum

onAChanged: sum = a + b
onBChanged: sum = a + b
```

Est√°s asumiendo:

* Que no se ejecutar√°n en orden inesperado
* Que no habr√° evaluaciones intermedias inconsistentes

Correcto:

```qml
property int sum: a + b
```

---

# 8. Signal emission order

Si tienes:

```qml
Connections {
    target: backend

    function onStateChanged() {
        updateUI()
    }

    function onTemperatureChanged() {
        updateWarning()
    }
}
```

No puedes asumir que:

* onStateChanged se ejecuta antes que onTemperatureChanged
* O viceversa

Especialmente si ambos cambios vienen de C++ en una misma transacci√≥n.

---

# 9. Error conceptual frecuente

Muchos piensan:

> ‚ÄúSi llamo setA() en C++, luego setB(), en QML se ver√°n en ese orden.‚Äù

No necesariamente.

Qt puede:

* Emitir se√±ales
* Procesarlas en el event loop
* Agrupar evaluaciones

El orden observable puede variar.

---

# 10. Patr√≥n correcto: estado derivado puro

Siempre que una propiedad dependa de otras:

‚Üí binding declarativo

Nunca:

‚Üí asignaci√≥n en onXChanged

---

# 11. Cuando s√≠ usar onXChanged

Solo para:

* Logging
* Efectos secundarios (I/O, animaciones)
* Interacci√≥n externa
* Debug

Nunca para mantener coherencia interna de estado.

---

# 12. Caso cr√≠tico: inicializaci√≥n

Este bug es muy com√∫n:

```qml
Component.onCompleted: {
    derived = compute(base)
}
```

Pero si `base` cambia despu√©s:

‚Üí derived queda inconsistente.

Correcto:

```qml
property int derived: compute(base)
```

---

# 13. Impacto en sistemas grandes

En proyectos complejos (c√°maras IR, dashboards en tiempo real, integraci√≥n OPC UA, etc.):

Confiar en orden:

* Introduce bugs intermitentes
* Dificulta testeo
* Rompe con optimizaciones futuras
* Hace que el sistema sea no determinista

---

# 14. Regla arquitect√≥nica

Estado base ‚Üí propiedades simples
Estado derivado ‚Üí bindings
Efectos secundarios ‚Üí handlers

Nunca mezclar.

---

# 15. Se√±ales en C++ (muy importante)

Si en C++ haces:

```cpp
setA(10);
setB(20);
```

Y ambos emiten se√±ales:

QML puede recibirlos:

* Separadamente
* En orden no esperado
* Incluso colapsados

Si tu l√≥gica depende del orden, est√°s mal dise√±ado.

---

# 16. Versi√≥n robusta del ejemplo anterior

En vez de:

```qml
onAChanged: sum = a + b
onBChanged: sum = a + b
```

Haz:

```qml
property int sum: a + b
```

Y si necesitas efecto:

```qml
onSumChanged: {
    console.log("Sum updated:", sum)
}
```

---

# 17. Conexi√≥n con principios anteriores

Este principio est√° ligado a:

* Declarative bindings
* Strong typing
* Avoid duck typing
* Single source of truth
* Unidirectional data flow

Todos forman un bloque coherente.

---

# 18. Resumen t√©cnico

No debes confiar en:

* Orden de evaluaci√≥n de bindings
* Orden de ejecuci√≥n de onXChanged
* Orden de emisi√≥n de se√±ales
* Orden de se√±ales C++ ‚Üí QML

Debes confiar en:

* Grafo declarativo
* Dependencias expl√≠citas
* Estado derivado puro

---

# Conclusi√≥n

Si tu dise√±o depende del orden de se√±ales o evaluaci√≥n,
est√°s programando contra el modelo de ejecuci√≥n de QML.

QML es reactivo y basado en dependencias, no secuencial.



# Use Typed List Properties (QML)

‚ÄúTyped list properties‚Äù significa **declarar listas con un tipo expl√≠cito** en QML, en lugar de usar `var` o listas heterog√©neas. En Qt/QML esto impacta directamente en:

* **robustez** (contratos claros)
* **tooling** (qmllint / autocompletado / QML LS)
* **rendimiento** (menos checks din√°micos)
* **integraci√≥n C++/QML** (modelos y APIs predecibles)

---

## 1. Qu√© NO es una lista tipada (anti-patr√≥n)

```qml
Item {
    property var items: []
}
```

Problemas:

* `items` puede contener cualquier cosa (mezcla de tipos).
* Errores se descubren tarde (runtime).
* Tooling pierde capacidad de an√°lisis.
* Es un im√°n para duck typing.

Otro anti-patr√≥n com√∫n:

```qml
property var points: [Qt.point(0,0), "oops", 123]
```

Eso compila y luego te explota cuando lo usas.

---

## 2. Qu√© es una lista tipada en QML

### 2.1 `list<T>` (Qt 6 / QML moderno)

```qml
Item {
    property list<int> values: [1, 2, 3]
    property list<real> gains: [0.5, 1.0, 1.5]
    property list<string> names: ["cam1", "cam2"]
}
```

Ventajas:

* Contrato: **solo esos tipos**.
* Mejor diagn√≥stico.
* Menos coerci√≥n din√°mica.

> Nota: En QML, `real` es el tipo de coma flotante ‚Äústandard‚Äù (double).

---

### 2.2 Listas de objetos QML

Puedes tipar listas de elementos QML/QtQuick:

```qml
import QtQuick

Item {
    property list<Item> nodes: []
}
```

Y luego almacenar instancias de `Item` (u otros tipos compatibles).

---

## 3. Caso clave: `default property list<T>` (composici√≥n)

Este patr√≥n es muy potente para APIs declarativas (tipo ‚Äúlayout/container‚Äù).

```qml
import QtQuick

Item {
    id: root
    default property list<Item> content

    // root.content contiene los Items declarados dentro
}
```

Uso:

```qml
MyContainer {
    Rectangle { width: 10; height: 10 }
    Text { text: "Hello" }
}
```

Aqu√≠, todo lo que metas dentro se agrega a `content` con tipo `Item`.

---

## 4. Diferencia importante: `list<T>` vs `children`

`children` ya es una lista de hijos (Items) manejada por Qt, pero:

* No siempre quieres mezclar ‚Äúhijos visuales‚Äù con ‚Äúcolecci√≥n l√≥gica‚Äù.
* `children` incluye cosas que no esperas (por ejemplo, elementos creados internamente).

Crear tu propia lista tipada te permite un contrato claro:

```qml
property list<Item> sensorsUI
```

---

## 5. Typed list properties vs Model (no confundas conceptos)

**Lista tipada** (`list<T>`) es una colecci√≥n simple.

Para UI repetitiva con delegates, a menudo conviene un **modelo**:

* `ListModel` (QML)
* `QAbstractListModel` (C++)

Regla pr√°ctica:

* Si solo necesitas ‚Äúagrupar referencias‚Äù ‚Üí `property list<T>`.
* Si necesitas ‚Äúrepresentar datos para views‚Äù (ListView/Repeater) ‚Üí modelo.

Ejemplo: UI repetitiva ‚Üí mejor un modelo, no una lista de Items.

---

## 6. Ejemplos reales √∫tiles (producci√≥n)

### 6.1 Lista tipada de IDs o nombres

```qml
Item {
    property list<string> cameraIds: ["IR_0", "IR_1", "IR_2"]
}
```

### 6.2 Lista tipada de puntos para dibujar

```qml
Item {
    property list<point> polyline: [
        Qt.point(0, 0),
        Qt.point(50, 20),
        Qt.point(80, 60)
    ]
}
```

### 6.3 Lista tipada de ‚Äúdispositivos‚Äù (tipo registrado desde C++)

Si registras un tipo `Device`:

```cpp
qmlRegisterType<Device>("App", 1, 0, "Device");
```

En QML:

```qml
import App 1.0

Item {
    property list<Device> devices: []
}
```

Ahora `devices` solo admite `Device`.

---

## 7. Errores t√≠picos y c√≥mo corregirlos

### Error 1: usar `var` por comodidad

**Correcci√≥n:** si sabes el tipo, tipa.

```qml
// mal
property var thresholds: []

// bien
property list<real> thresholds: [0.2, 0.5, 0.8]
```

---

### Error 2: mezclar ‚Äúdatos‚Äù y ‚ÄúUI objects‚Äù

Lista de `Item` deber√≠a contener UI, no datos puros.

* Datos ‚Üí `list<int>`, `list<real>`, `list<string>`, o modelo.
* UI objects ‚Üí `list<Item>` o tipo derivado.

---

### Error 3: pensar que `list<T>` es mutable como JS

Las `list<T>` en QML no se manipulan igual que un array JS. Dependiendo del caso, es mejor:

* construir la lista completa y asignarla
* o usar un `ListModel` / `QAbstractListModel` si necesitas inserciones/eliminaciones frecuentes con notificaci√≥n.

---

## 8. Patr√≥n recomendado: lista tipada + propiedad derivada

Evita recalcular manualmente.

```qml
Item {
    property list<real> values: [1.0, 2.0, 3.0]
    property real average: {
        if (values.length === 0) return 0
        let sum = 0
        for (let i = 0; i < values.length; ++i) sum += values[i]
        return sum / values.length
    }
}
```

Aqu√≠ `average` es declarativo (binding), no imperativo.

---

## 9. Pros / Contras (criterio de elecci√≥n)

### ‚úÖ Pros

* Contrato expl√≠cito (menos duck typing).
* Mejor tooling y mantenimiento.
* Mejor optimizaci√≥n.
* APIs QML m√°s ‚Äúdeclarativas‚Äù.

### ‚ö†Ô∏è Contras

* Menos flexible si realmente necesitas heterogeneidad.
* Para colecciones din√°micas complejas, un modelo es superior.

---

## 10. Checklist para aplicarlo bien

* [ ] Evitar `property var list = []` si hay tipo claro.
* [ ] Usar `property list<T>` para colecciones simples.
* [ ] Usar `default property list<Item>` para composici√≥n declarativa.
* [ ] Para views, preferir `ListModel` / `QAbstractListModel`.
* [ ] No mezclar datos y UI en la misma colecci√≥n.

---



# Use `required` Properties in Components and Delegates (QML)

`required` es una caracter√≠stica (Qt 6) para declarar **propiedades obligatorias**: el componente **no puede instanciarse** sin que esas propiedades reciban un valor (normalmente por binding) en el punto de uso.

Esto es una herramienta de dise√±o para:

* imponer **contratos expl√≠citos**
* eliminar **duck typing**
* detectar fallos **al cargar QML** (no tarde en runtime)
* endurecer delegates frente a cambios de modelo

---

## 1. Problema que resuelve

### ‚ùå Delegate fr√°gil (sin contrato)

```qml
delegate: Text {
    text: model.name
}
```

Si ma√±ana el modelo cambia `name` por `displayName`:

* `model.name` pasa a `undefined`
* UI ‚Äúfunciona‚Äù pero ense√±a vac√≠o
* bug silencioso

Esto es deuda t√©cnica.

---

## 2. Delegate robusto con `required`

### ‚úÖ Delegate con contrato

```qml
delegate: Item {
    required property string name
    required property int age

    Row {
        Text { text: name }
        Text { text: age.toString() }
    }
}
```

Uso (ejemplo con `ListView` + `ListModel`):

```qml
ListView {
    model: ListModel {
        ListElement { name: "Alice"; age: 30 }
        ListElement { name: "Bob";   age: 28 }
    }

    delegate: Item {
        required property string name
        required property int age
        // ...
    }
}
```

Ahora, si el modelo no proporciona `name` o `age`, QML lo considera un **error** (fallo temprano).

---

## 3. `required` en componentes reutilizables

### 3.1 Sin `required` (API blanda)

```qml
// WarningBadge.qml
import QtQuick

Rectangle {
    property string text: ""
    property color badgeColor: "red"
}
```

Puedes instanciarlo sin `text` y te quedas con un componente ‚Äúvac√≠o‚Äù.

### 3.2 Con `required` (API dura)

```qml
// WarningBadge.qml
import QtQuick

Rectangle {
    required property string text
    property color badgeColor: "red"

    Text {
        anchors.centerIn: parent
        text: parent.text
    }
}
```

Uso correcto:

```qml
WarningBadge {
    text: "Overheat"
}
```

Si alguien olvida `text`, se detecta al cargar.

---

## 4. `required` en `Component` + `Loader`

Cuando tienes componentes cargados din√°micamente, `required` te evita instancias incompletas.

```qml
Component {
    id: cardComponent
    Rectangle {
        required property string title
        required property int value
        // ...
    }
}

Loader {
    sourceComponent: cardComponent
    onLoaded: {
        item.title = "Temp"   // OJO: esto es imperativo y adem√°s llega tarde
        item.value = 42
    }
}
```

**Cr√≠tica importante:** asignar despu√©s en `onLoaded` es lo contrario de un contrato declarativo. Si el componente tiene `required`, lo ideal es **pasar propiedades antes** (ver siguiente secci√≥n).

---

## 5. C√≥mo ‚Äúpasar‚Äù required properties correctamente

### 5.1 Patr√≥n recomendado: `Loader` + `setSource()` con `properties` (Qt 6)

En Qt 6, `Loader.setSource(url, properties)` (o `setSourceComponent`) permite inyectar propiedades en creaci√≥n.

Ejemplo conceptual:

```qml
Loader {
    id: loader
    sourceComponent: cardComponent
    Component.onCompleted: {
        loader.setSourceComponent(cardComponent, {
            "title": "Temp",
            "value": 42
        })
    }
}
```

Esto satisface `required` **en creaci√≥n**, no despu√©s.

> Si tu versi√≥n concreta de Qt o tu estilo arquitect√≥nico no usa `setSourceComponent` con map, entonces la alternativa es no usar `required` para ese caso o refactorizar a composici√≥n declarativa (m√°s t√≠pico).

### 5.2 Alternativa: composici√≥n directa (mejor en UI declarativa)

```qml
Rectangle {
    Card {
        title: "Temp"
        value: 42
    }
}
```

---

## 6. `required` + tipos: obligaci√≥n doble

`required` sin tipado es menos √∫til. El combo correcto es:

```qml
required property int index
required property string displayName
required property real temperature
```

Esto elimina:

* ausencia del valor
* tipo incorrecto

---

## 7. `required` y Delegates: contrato contra ‚Äúmodel drift‚Äù

El mejor caso de uso es delegates, porque el modelo cambia con frecuencia.

### ‚úÖ Delegate blindado

```qml
delegate: Row {
    required property string label
    required property real value

    Text { text: label }
    Text { text: value.toFixed(1) }
}
```

Si alguien cambia el modelo, el delegate falla temprano, no ‚Äúmiente‚Äù mostrando vac√≠o.

---

## 8. Errores t√≠picos con `required`

### Error 1: intentar asignar la required property dentro del propio componente

```qml
Rectangle {
    required property string title
    Component.onCompleted: title = "default" // MAL
}
```

Esto contradice el contrato: la idea es que **el usuario del componente** lo provea.

Si necesitas default, entonces **no es required** (o necesitas dos propiedades: una required que alimenta otra derivada con fallback expl√≠cito, pero eso ya es dise√±o de API).

---

### Error 2: mezclar `required` con `var`

```qml
required property var data // flojo
```

Si es required, normalmente sabes el tipo. Si no lo sabes, probablemente est√°s aceptando JSON din√°mico y tu componente ya no es ‚Äúcontract-driven‚Äù.

---

### Error 3: romper el flujo declarativo con asignaciones tard√≠as

Si usas `required`, no la ‚Äúrellenes‚Äù a posteriori con `onLoaded`.

---

## 9. Criterios de uso (pragm√°ticos)

Usa `required` cuando:

* el componente no tiene sentido sin ese dato (ej: `title`, `model`, `backend`, `deviceId`)
* el delegate depende de roles concretos
* quieres que el fallo sea inmediato y visible

No lo uses cuando:

* el componente puede tener defaults √∫tiles
* la propiedad es opcional
* el valor llega asincr√≥nico y no controlas la creaci√≥n (en ese caso dise√±a un ‚Äúplaceholder state‚Äù en lugar de `required`)

---

## 10. Patr√≥n recomendado de ‚Äúplaceholder‚Äù (cuando el dato llega tarde)

En lugar de `required`, si el dato llega despu√©s:

```qml
Item {
    property string title: ""
    readonly property bool ready: title.length > 0

    Text { text: ready ? title : "Loading..." }
}
```

Esto es expl√≠cito y evita falsos contratos.

---

## 11. Resumen operativo

* `required property T x` = contrato obligatorio en creaci√≥n.
* En delegates, evita ‚ÄúUI silenciosamente rota‚Äù.
* En componentes reutilizables, endurece la API y reduce errores de wiring.
* No lo combines con asignaci√≥n tard√≠a imperativa: eso es un antipatr√≥n.

---

# Use String Interpolation (QML / JavaScript)

En QML (Qt 6), usar **string interpolation** significa utilizar *template literals* de JavaScript:

```js
`texto ${expresi√≥n} texto`
```

en lugar de concatenaci√≥n cl√°sica con `+`.

No es una preferencia est√©tica.
Tiene implicaciones en:

* legibilidad
* mantenimiento
* reducci√≥n de errores
* claridad declarativa
* menor ruido sint√°ctico en bindings

---

# 1. Problema con concatenaci√≥n cl√°sica

### ‚ùå Concatenaci√≥n manual

```qml
Text {
    text: "Temperature: " + temperature + " ¬∞C"
}
```

Problemas:

* Menos legible
* Conversi√≥n impl√≠cita poco clara
* F√°cil introducir espacios err√≥neos
* Dif√≠cil escalar a m√∫ltiples variables

Ejemplo m√°s complejo:

```qml
text: "Device " + id + " | State: " + state + " | FPS: " + fps.toFixed(1)
```

Esto degrada r√°pidamente.

---

# 2. Forma correcta: Template literals

### ‚úÖ Interpolaci√≥n

```qml
Text {
    text: `Temperature: ${temperature} ¬∞C`
}
```

Ejemplo complejo:

```qml
Text {
    text: `Device ${deviceId} | State: ${state} | FPS: ${fps.toFixed(1)}`
}
```

M√°s claro.
M√°s mantenible.
M√°s declarativo.

---

# 3. Ventajas t√©cnicas reales

## 3.1 Legibilidad estructural

Comparaci√≥n:

```qml
// concatenaci√≥n
"Gain: " + gain + " | Offset: " + offset

// interpolaci√≥n
`Gain: ${gain} | Offset: ${offset}`
```

La interpolaci√≥n:

* Elimina ruido visual
* Reduce errores de orden
* Evita olvidar espacios

---

## 3.2 Mejor manejo de expresiones

```qml
text: `Average: ${(sum / count).toFixed(2)}`
```

Con concatenaci√≥n ser√≠a:

```qml
text: "Average: " + (sum / count).toFixed(2)
```

Interpolaci√≥n mantiene estructura natural.

---

## 3.3 Multil√≠nea

```qml
text: `
Device: ${deviceId}
Temperature: ${temperature} ¬∞C
Status: ${status}
`
```

Esto es imposible con concatenaci√≥n limpia.

---

# 4. Interpolaci√≥n dentro de bindings declarativos

QML bindings funcionan perfectamente con template literals:

```qml
property string statusLabel: `State: ${backend.state}`
```

Esto sigue siendo un binding reactivo.

---

# 5. Caso real: UI industrial (tu contexto)

Sup√≥n que tienes:

* frame rate
* temperatura
* ganancia
* estado

### ‚ùå Imperativo + concatenaci√≥n

```qml
onDataUpdated: {
    label.text = "FPS: " + fps + " | Temp: " + temp + " | Gain: " + gain
}
```

Mal por:

* imperativo
* concatenaci√≥n
* romper binding

### ‚úÖ Declarativo + interpolaci√≥n

```qml
Text {
    text: `FPS: ${fps} | Temp: ${temperature} ¬∞C | Gain: ${gain}`
}
```

Robusto.
Reactivo.
Claro.

---

# 6. Casos donde es especialmente recomendable

## 6.1 Logs

```qml
console.log(`Device ${id} changed state to ${state}`)
```

## 6.2 URLs din√°micas

```qml
property url endpoint: `http://${host}:${port}/api`
```

## 6.3 Keys o identificadores

```qml
property string key: `${deviceId}_${channel}`
```

---

# 7. Errores comunes

## ‚ùå Usar comillas normales en vez de backticks

Incorrecto:

```qml
text: "Value: ${value}"
```

Esto NO interpola.

Correcto:

```qml
text: `Value: ${value}`
```

---

## ‚ùå Mezclar concatenaci√≥n e interpolaci√≥n

```qml
text: "Value: " + `${value}`  // innecesario
```

Si usas template literal, √∫salo completo.

---

## ‚ùå Abusar de l√≥gica compleja dentro de `${}`

Esto es mala pr√°ctica:

```qml
text: `${computeVeryComplexThing(a, b, c)}`
```

Mejor:

```qml
property string displayText: computeVeryComplexThing(a, b, c)
Text { text: displayText }
```

Mant√©n bindings limpios.

---

# 8. Rendimiento

No hay penalizaci√≥n relevante respecto a concatenaci√≥n.

El coste real viene de:

* complejidad de la expresi√≥n
* n√∫mero de re-evaluaciones
* dependencias del binding

No del uso de interpolaci√≥n.

---

# 9. Relaci√≥n con principios anteriores

String interpolation encaja con:

* Declarative bindings
* Strong typing
* Evitar l√≥gica imperativa innecesaria
* C√≥digo expresivo y mantenible

Es coherente con una arquitectura declarativa fuerte.

---

# 10. Regla pr√°ctica para proyectos serios

En QML moderno:

* Nunca uses `+` para strings salvo casos extremadamente simples.
* Siempre usa template literals.
* Mant√©n las expresiones cortas.
* Extrae l√≥gica compleja a propiedades derivadas.

---

# 11. Ejemplo final bien dise√±ado

```qml
Item {
    property string deviceId
    property real temperature
    property real fps
    property int state

    readonly property string statusText:
        `Device ${deviceId} | FPS ${fps.toFixed(1)} | Temp ${temperature.toFixed(1)} ¬∞C | State ${state}`

    Text {
        text: statusText
    }
}
```

Estado base ‚Üí propiedades simples
Estado derivado ‚Üí interpolaci√≥n declarativa
UI ‚Üí depende solo de estado derivado

Sin imperativo.
Sin concatenaci√≥n.
Sin orden impl√≠cito.

---

# Use Explicit URL Resolution (QML)

En QML, ‚ÄúUse Explicit URL Resolution‚Äù significa **no depender de la resoluci√≥n impl√≠cita de rutas relativas**, sino declarar de forma clara y determinista c√≥mo se resuelven los recursos (`url`, `source`, `Loader`, `Image`, `FontLoader`, etc.).

Esto es especialmente cr√≠tico en:

* proyectos grandes con muchos m√≥dulos QML
* aplicaciones que usan `qmldir` / m√≥dulos versionados
* `qrc` (Qt Resource System)
* despliegues multiplataforma
* `qmltc` / compilaci√≥n AOT

---

# 1. El problema: resoluci√≥n impl√≠cita ambigua

QML resuelve rutas relativas seg√∫n:

1. El archivo actual
2. El `baseUrl` del motor
3. El m√≥dulo desde el que se importa
4. El sistema de recursos (`qrc:`)

Ejemplo ambiguo:

```qml
Image {
    source: "icons/warning.png"
}
```

¬øDesde d√≥nde se resuelve?

* Desde el archivo actual.
* Pero si mueves el archivo, se rompe.
* Si cambias estructura modular, se rompe.
* Si compilas con `qmltc`, puede comportarse diferente.

Eso introduce fragilidad.

---

# 2. Enfoque correcto: URLs expl√≠citas

## 2.1 Usar `qrc:/` expl√≠cito

Si el recurso est√° en el sistema de recursos:

```qml
Image {
    source: "qrc:/icons/warning.png"
}
```

Esto es:

* Determinista
* Independiente de la ubicaci√≥n del archivo
* Seguro frente a refactorizaciones

---

## 2.2 Usar `Qt.resolvedUrl()`

Cuando necesitas mantener relativa pero expl√≠cita:

```qml
Image {
    source: Qt.resolvedUrl("icons/warning.png")
}
```

Esto fuerza la resoluci√≥n contra el archivo actual de manera expl√≠cita.

√ötil cuando el componente puede cargarse din√°micamente.

---

## 2.3 Usar `import` modular correcto

Si tienes un m√≥dulo QML:

```
MyApp/
  assets/
  components/
  qmldir
```

Mejor importar el m√≥dulo:

```qml
import MyApp 1.0
```

Y referenciar recursos desde el m√≥dulo con rutas claras.

---

# 3. Caso cr√≠tico: `Loader`

### ‚ùå Impl√≠cito

```qml
Loader {
    source: "MyPage.qml"
}
```

Esto depende del contexto actual.

---

### ‚úÖ Expl√≠cito

Si es recurso:

```qml
Loader {
    source: "qrc:/pages/MyPage.qml"
}
```

Si es relativo al archivo actual:

```qml
Loader {
    source: Qt.resolvedUrl("MyPage.qml")
}
```

---

# 4. Caso real: proyectos industriales grandes

En aplicaciones con:

* M√∫ltiples carpetas
* Plugins QML
* Subm√≥dulos
* Backend C++ que crea QQmlComponent

La resoluci√≥n impl√≠cita puede fallar porque:

* El `baseUrl` cambia
* El componente se carga desde C++
* El contexto no es el que cre√≠as

Ejemplo t√≠pico en C++:

```cpp
QQmlComponent comp(&engine, QUrl("MyPage.qml"));
```

Si no es expl√≠cito, puede no encontrar el archivo en producci√≥n.

Correcto:

```cpp
QQmlComponent comp(&engine, QUrl("qrc:/pages/MyPage.qml"));
```

---

# 5. Diferencia entre tipos de URL

En QML, `url` es un tipo real, no un string.

Ejemplo:

```qml
property url endpoint: "http://localhost:8080/api"
```

Evita:

```qml
property string endpoint
```

Si es una URL, usa `url`.

Esto permite validaci√≥n y coherencia sem√°ntica.

---

# 6. Evitar dependencias ocultas de estructura

Sup√≥n:

```
views/
  Dashboard.qml
  components/
    Gauge.qml
```

Dentro de `Gauge.qml`:

```qml
Image { source: "../icons/needle.png" }
```

Esto es fr√°gil.

Si mueves `Gauge.qml`, se rompe.

Mejor:

```qml
Image { source: "qrc:/icons/needle.png" }
```

---

# 7. Relaci√≥n con qmltc y compilaci√≥n est√°tica

Con Qt 6 y `qmltc`:

* Las rutas impl√≠citas pueden no resolverse como esperas.
* Los m√≥dulos deben ser deterministas.
* El uso expl√≠cito mejora el an√°lisis est√°tico.

En sistemas donde quieres m√°xima robustez (por ejemplo UI para c√°maras IR, herramientas industriales, etc.), esto importa.

---

# 8. Caso especial: recursos externos vs internos

Si cargas im√°genes desde red:

```qml
Image {
    source: `http://${host}:${port}/image`
}
```

Aqu√≠ s√≠ tiene sentido interpolaci√≥n din√°mica.

Pero si es asset interno:

‚Üí usa `qrc:/`.

No mezcles ambos conceptos.

---

# 9. Patr√≥n recomendado (estructura limpia)

## 9.1 Recursos siempre en `qrc`

* icons
* fonts
* im√°genes
* QML est√°tico

Y siempre referenciados como:

```qml
"qrc:/icons/..."
```

---

## 9.2 Componentes din√°micos siempre con URL expl√≠cita

```qml
Loader {
    source: Qt.resolvedUrl("SubView.qml")
}
```

o

```qml
source: "qrc:/views/SubView.qml"
```

---

# 10. Errores t√≠picos

### ‚ùå Usar rutas relativas profundas

```qml
source: "../../../../../icons/x.png"
```

Eso es una bomba futura.

---

### ‚ùå Confiar en el working directory

En producci√≥n, el working directory puede cambiar.

---

### ‚ùå Usar string en vez de `url`

Si algo es conceptualmente una URL, tiparlo como `url`.

---

# 11. Resumen t√©cnico

No conf√≠es en:

* resoluci√≥n impl√≠cita
* ubicaci√≥n actual del archivo
* baseUrl del engine
* working directory

Conf√≠a en:

* `qrc:/`
* `Qt.resolvedUrl()`
* tipos `url`
* m√≥dulos bien definidos

---

# 12. Regla arquitect√≥nica fuerte

En proyectos medianos/grandes:

* Ning√∫n recurso cr√≠tico debe depender de rutas relativas ambiguas.
* Ning√∫n Loader debe usar rutas impl√≠citas.
* Toda URL importante debe ser determinista.

---

# Delegates Should Not Store State (QML)

Este principio es cr√≠tico en cualquier UI basada en `ListView`, `GridView`, `Repeater`, etc.

> Un delegate no es una entidad de datos.
> Es una representaci√≥n visual temporal de un elemento del modelo.

Si un delegate almacena estado interno, introduces:

* incoherencias
* bugs intermitentes
* problemas con reciclado (view recycling)
* p√©rdida de sincronizaci√≥n con el modelo

---

# 1. Por qu√© este principio existe

En `ListView` y similares:

* Los delegates se **crean y destruyen din√°micamente**
* Se **reciclan** cuando haces scroll
* No existe una instancia fija por elemento del modelo

Por tanto:

> El delegate no es el due√±o del estado.

---

# 2. Error cl√°sico

```qml
ListView {
    model: myModel

    delegate: Item {
        property bool selected: false

        MouseArea {
            anchors.fill: parent
            onClicked: selected = !selected
        }

        Rectangle {
            color: selected ? "blue" : "white"
        }
    }
}
```

Esto parece correcto.

Pero cuando haces scroll:

* El delegate se recicla.
* `selected` puede quedarse en `true`.
* El elemento visual ahora representa otro √≠ndice.
* Resultado: selecci√≥n incorrecta.

Bug t√≠pico.

---

# 3. Regla fundamental

> El estado pertenece al modelo, no al delegate.

---

# 4. Soluci√≥n correcta: mover estado al modelo

### 4.1 Con `ListModel` QML

```qml
ListModel {
    id: myModel
    ListElement { name: "A"; selected: false }
    ListElement { name: "B"; selected: false }
}
```

Delegate:

```qml
delegate: Item {
    required property bool selected
    required property string name

    MouseArea {
        anchors.fill: parent
        onClicked: {
            myModel.setProperty(index, "selected", !selected)
        }
    }

    Rectangle {
        color: selected ? "blue" : "white"
    }
}
```

Ahora:

* El estado vive en el modelo.
* El delegate solo refleja estado.
* El reciclado no rompe nada.

---

# 5. Con modelo C++ (`QAbstractListModel`)

Lo correcto es exponer el rol `selected`.

En C++:

```cpp
enum Roles {
    NameRole = Qt::UserRole + 1,
    SelectedRole
};
```

Delegate:

```qml
delegate: Item {
    required property bool selected
    required property string name

    Rectangle {
        color: selected ? "blue" : "white"
    }
}
```

El estado est√° centralizado.

---

# 6. Qu√© s√≠ puede tener un delegate

El delegate puede tener:

* estado puramente visual ef√≠mero
* animaciones
* hover temporal
* propiedades derivadas

Ejemplo v√°lido:

```qml
property bool hovered: false
```

Si solo controla efecto visual temporal y no representa estado l√≥gico persistente.

---

# 7. Diferencia clave: estado persistente vs ef√≠mero

| Tipo de estado        | ¬øDebe ir en delegate? |
| --------------------- | --------------------- |
| Selecci√≥n             | ‚ùå No                  |
| Activado/desactivado  | ‚ùå No                  |
| Datos del dispositivo | ‚ùå No                  |
| Hover                 | ‚úî S√≠                  |
| Animaci√≥n activa      | ‚úî S√≠                  |
| Opacidad temporal     | ‚úî S√≠                  |

---

# 8. Error m√°s sutil: almacenar datos derivados

Ejemplo incorrecto:

```qml
property real computedValue

Component.onCompleted: {
    computedValue = expensiveCalculation(model.value)
}
```

Si `model.value` cambia:

* `computedValue` queda desincronizado.

Correcto:

```qml
property real computedValue: expensiveCalculation(model.value)
```

Binding declarativo.
Sin almacenamiento interno.

---

# 9. Interacci√≥n con reciclado (muy importante)

`ListView` puede:

* reutilizar delegates
* reasignar nuevos `modelData`
* cambiar `index`

Si el delegate guarda estado interno, ese estado:

* no corresponde al nuevo elemento
* produce comportamiento err√°tico

---

# 10. Patr√≥n correcto: Unidirectional Data Flow

Modelo ‚Üí Delegate ‚Üí Usuario ‚Üí Modelo

Nunca:

Delegate ‚Üí mantiene estado interno ‚Üí Modelo opcional

Siempre:

Delegate comunica intenci√≥n ‚Üí Modelo cambia ‚Üí Delegate reacciona

---

# 11. Ejemplo completo bien dise√±ado

```qml
ListView {
    model: deviceModel

    delegate: Rectangle {
        required property string deviceId
        required property bool active

        color: active ? "green" : "gray"

        MouseArea {
            anchors.fill: parent
            onClicked: {
                deviceModel.toggleActive(index)
            }
        }
    }
}
```

El delegate:

* no almacena nada
* solo refleja `active`
* notifica intenci√≥n

---

# 12. Caso complejo: selecci√≥n √∫nica

Nunca hagas esto:

```qml
property bool selected
```

Haz esto en el modelo:

```qml
ListModel {
    property int selectedIndex: -1
}
```

Y el delegate:

```qml
color: index === myModel.selectedIndex ? "blue" : "white"
```

Esto elimina estados duplicados.

---

# 13. Relaci√≥n con principios anteriores

Este principio est√° alineado con:

* Declarative bindings
* Single source of truth
* Avoid duck typing
* Required properties
* No reliance on evaluation order

Todos apuntan a lo mismo:

> El estado debe ser √∫nico y centralizado.

---

# 14. Excepci√≥n leg√≠tima

En `Repeater` (no reciclado), el riesgo es menor.

Pero incluso ah√≠:

* Si el estado es l√≥gico, debe estar fuera.
* Solo estado puramente visual puede estar dentro.

---

# 15. Resumen t√©cnico

No almacenar en delegate:

* selecci√≥n
* flags persistentes
* datos del backend
* resultados de c√°lculo

S√≠ puede almacenar:

* hover
* animaciones
* estados transitorios puramente visuales

---

# Conclusi√≥n

Un delegate es una vista ef√≠mera del modelo.

Si almacena estado persistente, est√°s violando el dise√±o de QML.

En aplicaciones complejas (dashboards industriales, c√°maras, paneles con cientos de items), ignorar este principio produce bugs muy dif√≠ciles de rastrear.

---

# Use Group Property Syntax (QML)

**Group Property Syntax** consiste en usar la forma agrupada de propiedades cuando un tipo expone una propiedad compuesta (sub-propiedades), en lugar de asignarlas una por una con prefijo repetido.

No es solo est√©tica: mejora legibilidad, reduce errores y hace m√°s expl√≠cito el contrato del tipo.

---

## 1. Qu√© es una propiedad ‚Äúgroup‚Äù

Muchos tipos QML exponen propiedades que son objetos compuestos con sub-propiedades:

* `anchors`
* `font`
* `border`
* `gradient`
* `Layout`
* `layer`
* `ScrollBar.vertical`
* `ScrollBar.horizontal`

En vez de escribir:

```qml
Rectangle {
    anchors.left: parent.left
    anchors.right: parent.right
    anchors.top: parent.top
    anchors.bottom: parent.bottom
}
```

Usa sintaxis agrupada:

```qml
Rectangle {
    anchors {
        left: parent.left
        right: parent.right
        top: parent.top
        bottom: parent.bottom
    }
}
```

---

## 2. Beneficios reales

### 2.1 Cohesi√≥n visual

Agrupa sem√°nticamente lo relacionado.

Comparaci√≥n:

```qml
font.pixelSize: 14
font.bold: true
font.family: "Inter"
```

vs

```qml
font {
    pixelSize: 14
    bold: true
    family: "Inter"
}
```

La segunda comunica claramente: *estoy configurando la fuente*.

---

### 2.2 Menos duplicaci√≥n

Evita repetir el prefijo:

```qml
border.width: 1
border.color: "red"
```

vs

```qml
border {
    width: 1
    color: "red"
}
```

Menos ruido, menos posibilidad de error tipogr√°fico.

---

### 2.3 Mejor mantenibilidad

Si ma√±ana agregas m√°s propiedades del mismo grupo:

```qml
border {
    width: 1
    color: "red"
    pixelAligned: true
}
```

Todo queda en el mismo bloque.

---

## 3. Ejemplos comunes

### 3.1 anchors

Correcto:

```qml
Item {
    anchors {
        fill: parent
        margins: 10
    }
}
```

---

### 3.2 font

```qml
Text {
    font {
        family: "Roboto"
        pixelSize: 16
        bold: true
    }
}
```

---

### 3.3 border

```qml
Rectangle {
    border {
        width: 2
        color: "orange"
    }
}
```

---

### 3.4 Layout (QtQuick.Layouts)

```qml
import QtQuick.Layouts

Item {
    Layout {
        fillWidth: true
        preferredHeight: 40
    }
}
```

Mucho m√°s limpio que repetir `Layout.`.

---

### 3.5 layer

```qml
Rectangle {
    layer {
        enabled: true
        smooth: true
        mipmap: true
    }
}
```

---

## 4. Cu√°ndo es obligatorio usar group syntax

Algunas propiedades son **read-only object properties** (por ejemplo `anchors`).
No puedes hacer:

```qml
anchors = something   // inv√°lido
```

Solo puedes modificar sub-propiedades.

En estos casos, la sintaxis agrupada es natural.

---

## 5. Error frecuente

### ‚ùå Mezclar estilos

```qml
border.width: 1
border {
    color: "red"
}
```

Inconsistente.

Elige uno y s√© coherente.

---

## 6. Cu√°ndo NO usar group syntax

Si solo est√°s asignando una propiedad del grupo y no hay previsi√≥n de m√°s, ambas formas son v√°lidas:

```qml
font.pixelSize: 14
```

Pero en componentes reutilizables o UI complejas, la agrupaci√≥n mejora claridad.

---

## 7. Relaci√≥n con dise√±o declarativo

Group property syntax:

* Refuerza cohesi√≥n sem√°ntica
* Reduce ruido
* Hace que el archivo QML sea m√°s declarativo
* Facilita escaneo visual (muy importante en UIs grandes)

En proyectos industriales con cientos de l√≠neas por componente, esto impacta directamente en mantenibilidad.

---

## 8. Ejemplo completo bien estructurado

```qml
Rectangle {
    width: 200
    height: 80
    color: "#1A1D23"

    anchors {
        horizontalCenter: parent.horizontalCenter
        top: parent.top
        topMargin: 20
    }

    border {
        width: 1
        color: "#2E3440"
    }

    Text {
        anchors.centerIn: parent

        font {
            family: "Inter"
            pixelSize: 16
            bold: true
        }

        color: "white"
        text: "Dashboard"
    }
}
```

Todo agrupado por intenci√≥n.

---

## 9. Impacto arquitect√≥nico

Este principio, junto con:

* Strong typing
* Required properties
* Declarative bindings

apunta a lo mismo:

> C√≥digo QML expresivo, coherente y f√°cil de razonar.

No cambia el runtime, pero cambia dr√°sticamente la calidad del c√≥digo.

---

## 10. Regla pr√°ctica

* Si modificas m√°s de una sub-propiedad ‚Üí usa group syntax.
* No mezcles estilos.
* Mant√©n coherencia en todo el proyecto.
* √ösalo especialmente en componentes reutilizables.

---

# Deprecated Injected Signal Parameters (QML)

En QML ‚Äú**injected signal parameters**‚Äù se refiere a un comportamiento hist√≥rico: **en un handler de se√±al pod√≠as usar los par√°metros de la se√±al como ‚Äúvariables m√°gicas‚Äù dentro del bloque**, sin declararlos expl√≠citamente.

Eso se est√° **deprecando** en Qt 6 (y el tooling lo penaliza) porque genera c√≥digo:

* ambiguo (colisiones con propiedades/ids/variables del scope),
* dif√≠cil de analizar est√°ticamente (qmllint / QML LS / qmltc),
* fr√°gil al refactorizar (cambiar nombre de par√°metro rompe handlers sin que se vea).

La recomendaci√≥n actual es: **declara los par√°metros expl√≠citamente** (funci√≥n o arrow function).

---

## 1) Qu√© es ‚Äúinyecci√≥n‚Äù (lo deprecado)

Si tienes una se√±al:

```qml
QtObject {
    signal valueChanged(newValue: int)
}
```

Antes era com√∫n escribir:

```qml
onValueChanged: {
    console.log(newValue)   // <-- "newValue" est√° inyectado
}
```

Aqu√≠ **no hay funci√≥n con argumentos**, y aun as√≠ `newValue` aparece como variable disponible. Eso es la ‚Äúinyecci√≥n‚Äù.

### Problema pr√°ctico

Si en ese mismo scope existe tambi√©n una propiedad `newValue`, un `id` o una variable local con ese nombre, el significado puede ser confuso o directamente incorrecto.

---

## 2) Migraci√≥n correcta (lo recomendado)

### Opci√≥n A: handler como funci√≥n expl√≠cita (clara y compatible)

```qml
onValueChanged: function(newValue) {
    console.log(newValue)
}
```

### Opci√≥n B: arrow function (m√°s compacta)

```qml
onValueChanged: (newValue) => {
    console.log(newValue)
}
```

Ambas eliminan la ambig√ºedad: el par√°metro **es local** al handler.

---

## 3) Caso t√≠pico: MouseArea / Pointer Handlers

Ejemplo cl√°sico con `MouseArea.clicked(mouse)`:

### ‚ùå (inyecci√≥n) deprecado

```qml
MouseArea {
    onClicked: {
        console.log(mouse.x, mouse.y) // "mouse" inyectado
    }
}
```

### ‚úÖ recomendado

```qml
MouseArea {
    onClicked: (mouse) => {
        console.log(mouse.x, mouse.y)
    }
}
```

---

## 4) `Connections`: el patr√≥n m√°s robusto

Cuando conectas se√±ales de un objeto externo, evita el estilo antiguo y usa **m√©todos con firma**.

### ‚úÖ recomendado (Qt 6)

```qml
Connections {
    target: backend
    function onStateChanged(state) {
        console.log(state)
    }
}
```

Esto es particularmente importante en proyectos grandes porque:

* es analizables por tooling,
* es m√°s ‚Äúbuscable‚Äù (refactor),
* evita colisiones de nombres con propiedades del componente.

---

## 5) Por qu√© NO debes ignorar esto (impacto real)

### 5.1 Colisiones silenciosas

Si tienes:

```qml
Item {
    property int state: 0
    Connections {
        target: backend
        onStateChanged: {
            console.log(state) // ¬øpropiedad `state` o par√°metro `state`?
        }
    }
}
```

Ese ‚Äústate‚Äù es una bomba: depende de reglas de scope y nombres.

Con firma expl√≠cita se elimina el riesgo:

```qml
Connections {
    target: backend
    onStateChanged: (newState) => console.log(newState)
}
```

### 5.2 Tooling / qmltc

La inyecci√≥n dificulta el an√°lisis est√°tico y la compilaci√≥n AOT. En c√≥digo serio, eso se traduce en menos warnings √∫tiles y m√°s bugs tard√≠os.

---

## 6) Regla operativa

**Siempre** que uses una se√±al con par√°metros:

* **No** uses el bloque `{ ... }` esperando variables inyectadas.
* **S√≠** usa `function(...) { ... }` o `(‚Ä¶) => { ‚Ä¶ }`.

Ejemplos r√°pidos:

```qml
onTextChanged: (text) => console.log(text)
onError: function(code, message) { log(code, message) }
```

---

## 7) Checklist para auditar tu c√≥digo

Busca y refactoriza:

* `onClicked: { ... mouse ... }`
* `onTriggered: { ... checked ... }`
* `Connections { onXxx: { ... paramName ... } }`

y convi√©rtelo a:

* `onXxx: (paramName) => { ... }`
* o `function onXxx(paramName) { ... }` en `Connections`

---

# Prefer UI Interaction Signals Over Changed Signals (QML)

Este principio es sutil pero fundamental en aplicaciones bien dise√±adas:

> Cuando reacciones a una acci√≥n del usuario, usa la se√±al de interacci√≥n espec√≠fica (`clicked`, `toggled`, `editingFinished`, `activated`, etc.) en lugar de la se√±al gen√©rica `onXChanged`.

El motivo es separar claramente:

* **interacci√≥n del usuario**
* **cambios de estado**
* **actualizaciones program√°ticas**

Si mezclas ambos, introduces efectos colaterales dif√≠ciles de controlar.

---

# 1. El problema con `onXChanged`

Muchos controles exponen:

```qml
property bool checked
signal toggled(bool checked)
```

Y es com√∫n ver esto:

```qml
CheckBox {
    onCheckedChanged: {
        backend.setFeatureEnabled(checked)
    }
}
```

Esto parece correcto, pero no lo es.

## Problema:

`checked` puede cambiar:

* Por clic del usuario.
* Por actualizaci√≥n desde el backend.
* Por binding reactivo.
* Por inicializaci√≥n.

No sabes el origen del cambio.

Eso rompe el flujo unidireccional.

---

# 2. La forma correcta

Usa la se√±al espec√≠fica de interacci√≥n:

```qml
CheckBox {
    onToggled: (checked) => {
        backend.setFeatureEnabled(checked)
    }
}
```

Ahora:

* Solo reaccionas cuando el usuario interact√∫a.
* No cuando el estado cambia program√°ticamente.
* No generas loops involuntarios.

---

# 3. Ejemplo real de bug t√≠pico

Sup√≥n arquitectura bidireccional mal dise√±ada:

```qml
CheckBox {
    checked: backend.featureEnabled

    onCheckedChanged: {
        backend.setFeatureEnabled(checked)
    }
}
```

Secuencia posible:

1. Usuario hace clic.
2. `checked` cambia.
3. `setFeatureEnabled` se llama.
4. Backend emite se√±al.
5. `checked` vuelve a cambiar.
6. `onCheckedChanged` se vuelve a disparar.

Puedes crear:

* loops
* doble escritura
* tr√°fico innecesario
* glitches visuales

---

# 4. Versi√≥n robusta

```qml
CheckBox {
    checked: backend.featureEnabled

    onToggled: (checked) => {
        backend.setFeatureEnabled(checked)
    }
}
```

El binding mantiene sincronizaci√≥n.
La se√±al de interacci√≥n comunica intenci√≥n.

Separaci√≥n clara.

---

# 5. Ejemplos por tipo de control

## 5.1 Button

‚ùå Incorrecto:

```qml
onPressedChanged: { doSomething() }
```

‚úÖ Correcto:

```qml
onClicked: { doSomething() }
```

---

## 5.2 TextField

‚ùå Incorrecto:

```qml
onTextChanged: {
    backend.setName(text)
}
```

Esto se dispara en cada car√°cter.

‚úÖ Mejor:

```qml
onEditingFinished: {
    backend.setName(text)
}
```

O si quieres respuesta inmediata:

```qml
onAccepted: { ... }
```

Depende del caso.

---

## 5.3 ComboBox

‚ùå Incorrecto:

```qml
onCurrentIndexChanged: {
    backend.setMode(currentIndex)
}
```

Puede cambiar por binding.

‚úÖ Correcto:

```qml
onActivated: (index) => {
    backend.setMode(index)
}
```

---

## 6. Diferencia conceptual clave

| Se√±al                                     | Significado                           |
| ----------------------------------------- | ------------------------------------- |
| `onXChanged`                              | El estado cambi√≥ (origen desconocido) |
| `onClicked` / `onToggled` / `onActivated` | El usuario interactu√≥                 |

No son equivalentes.

---

# 7. Regla arquitect√≥nica fuerte

UI debe comunicar **intenci√≥n del usuario**, no reaccionar a cambios de estado.

Flujo correcto:

Usuario ‚Üí se√±al de interacci√≥n ‚Üí backend
Backend ‚Üí actualiza estado ‚Üí binding actualiza UI

Nunca:

UI ‚Üí reacciona a cambio ‚Üí backend ‚Üí backend ‚Üí UI ‚Üí loop

---

# 8. Caso industrial (tu contexto real)

Sup√≥n:

* Slider controla ganancia de c√°mara.
* Backend puede cambiar ganancia autom√°ticamente (auto-exposure).

‚ùå Incorrecto:

```qml
Slider {
    value: backend.gain

    onValueChanged: {
        backend.setGain(value)
    }
}
```

Si backend cambia gain, disparas setGain otra vez.

---

‚úÖ Correcto:

```qml
Slider {
    value: backend.gain

    onMoved: (value) => {
        backend.setGain(value)
    }
}
```

Ahora:

* Solo cuando el usuario mueve.
* No cuando backend ajusta autom√°ticamente.

Sistema estable.

---

# 9. Cu√°ndo s√≠ usar `onXChanged`

Solo para:

* animaciones
* logging
* efectos secundarios puramente visuales
* c√°lculos derivados internos

Nunca para comunicar intenci√≥n al backend.

---

# 10. Relaci√≥n con principios anteriores

Este principio encaja con:

* Declarative bindings
* Delegates should not store state
* Avoid duck typing
* No reliance on signal order
* Single source of truth

Todos refuerzan el mismo modelo:

> Estado centralizado + UI declarativa + interacci√≥n expl√≠cita.

---

# 11. Checklist pr√°ctico

En tu proyecto, revisa:

* `onCheckedChanged`
* `onCurrentIndexChanged`
* `onValueChanged`
* `onTextChanged`

Y eval√∫a:

¬øEstoy reaccionando a interacci√≥n o a cambio de estado?

Si es interacci√≥n ‚Üí usa se√±al espec√≠fica.

---

# 12. Resumen t√©cnico

Preferir se√±ales de interacci√≥n:

* evita loops
* evita ambig√ºedad de origen
* refuerza arquitectura unidireccional
* mejora claridad sem√°ntica
* reduce bugs intermitentes

---

# Use Compile-Time Style Selection (Qt Quick Controls)

En **Qt Quick Controls 2**, el *style* (Material, Fusion, Imagine, iOS, etc.) puede elegirse:

* en **runtime** (variable de entorno, `QQuickStyle::setStyle()`)
* en **compile time** (configuraci√≥n del build / qtquickcontrols2.conf / flags)

La recomendaci√≥n para aplicaciones serias es:

> Seleccionar el style en compile-time siempre que sea posible.

---

# 1. Qu√© significa realmente ‚Äúcompile-time style selection‚Äù

Significa que el style queda **fijado en el binario** y no depende de:

* variable de entorno (`QT_QUICK_CONTROLS_STYLE`)
* c√≥digo din√°mico
* sistema operativo
* configuraci√≥n externa

Ejemplo t√≠pico (C++):

```cpp
#include <QQuickStyle>

int main(int argc, char *argv[])
{
    QQuickStyle::setStyle("Material");  // se fija antes de crear la app
    QGuiApplication app(argc, argv);
    ...
}
```

O mediante `qtquickcontrols2.conf`.

En cambio, si permites que el style se elija din√°micamente por entorno, ya no es compile-time puro.

---

# 2. Por qu√© es importante

## 2.1 Determinismo visual

Si no lo fijas:

* En Linux puede salir Fusion.
* En Windows puede salir Windows style.
* En macOS puede salir macOS style.

Tu UI cambia sin que t√∫ lo controles.

En sistemas industriales o herramientas t√©cnicas esto es inaceptable.

---

## 2.2 Rendimiento y tama√±o

Cuando el style es fijo:

* Solo se incluye el style seleccionado.
* No se cargan assets innecesarios.
* El arranque es m√°s predecible.

En entornos embebidos esto importa.

---

## 2.3 Compatibilidad con qmltc / AOT

La compilaci√≥n est√°tica de QML funciona mejor si el style es fijo.

La selecci√≥n din√°mica:

* dificulta an√°lisis est√°tico
* complica empaquetado
* introduce dependencias ocultas

---

# 3. Problema con selecci√≥n en runtime

Ejemplo incorrecto:

```bash
QT_QUICK_CONTROLS_STYLE=Material ./app
```

O:

```cpp
if (someConfig)
    QQuickStyle::setStyle("Material");
else
    QQuickStyle::setStyle("Fusion");
```

Esto:

* multiplica combinaciones a testear
* complica QA
* rompe consistencia visual

---

# 4. C√≥mo hacerlo correctamente

## Opci√≥n 1: `qtquickcontrols2.conf` (recomendado)

Archivo:

```
qtquickcontrols2.conf
```

Contenido:

```
[Controls]
Style=Material
```

Col√≥calo en recursos (`qrc`) o junto al ejecutable.

Esto fija el style de forma determinista.

---

## Opci√≥n 2: Forzar en `main.cpp`

```cpp
QQuickStyle::setStyle("Material");
```

Debe hacerse **antes** de crear `QGuiApplication`.

---

## Opci√≥n 3: CMake (control de dependencias)

En proyectos grandes puedes controlar qu√© styles se construyen:

```cmake
qt_add_qml_module(...)
```

Y limitar dependencias innecesarias.

---

# 5. Qu√© styles existen

En Qt 6 (Qt Quick Controls 2):

* Material
* Fusion
* Imagine
* iOS
* macOS
* Universal

Cada uno tiene:

* m√©tricas distintas
* espaciados distintos
* animaciones distintas
* assets distintos

No son equivalentes visualmente.

---

# 6. Caso real (dashboard industrial)

Si tu aplicaci√≥n controla:

* c√°maras
* hardware
* sistemas de producci√≥n

No quieres que:

* el padding cambie
* el tama√±o de botones cambie
* el comportamiento del focus cambie

Un cambio de style puede romper layout cuidadosamente ajustado.

---

# 7. Errores frecuentes

## ‚ùå Mezclar estilos din√°micamente

```cpp
QQuickStyle::setStyle(userPreference);
```

Esto convierte tu UI en no determinista.

---

## ‚ùå Confiar en style por defecto del SO

Si no defines nada, Qt puede elegir autom√°ticamente.

Eso es mala pr√°ctica en software profesional.

---

## ‚ùå Ajustar layout ‚Äúa ojo‚Äù sin fijar style

Si no fijas style y luego mueves app a otra plataforma:

* spacing cambia
* tipograf√≠a cambia
* layout se rompe

---

# 8. Cu√°ndo s√≠ usar selecci√≥n din√°mica

Solo si:

* Est√°s desarrollando una app ‚Äúconsumer‚Äù multiplataforma.
* Quieres que la app imite el sistema operativo.
* El equipo acepta la variabilidad visual.

En sistemas t√©cnicos, no suele ser el caso.

---

# 9. Relaci√≥n con otros principios

Compile-time style selection refuerza:

* Determinismo
* Reproducibilidad
* Single source of truth
* Eliminaci√≥n de dependencias impl√≠citas
* Robustez en despliegue

Es coherente con:

* Explicit URL resolution
* Strong typing
* No reliance on evaluation order

---

# 10. Recomendaci√≥n arquitect√≥nica fuerte

En proyectos profesionales:

1. Elegir un style.
2. Fijarlo en build.
3. Dise√±ar UI sobre ese style.
4. No permitir override externo.

Eso simplifica:

* Testing
* CI
* Mantenimiento
* Soporte multiplataforma

---

# 11. Resumen t√©cnico

No dependas de:

* variable de entorno
* SO
* configuraci√≥n externa

Fija el style en:

* `qtquickcontrols2.conf`
* o `main.cpp`

Haz la UI determinista.

---

# Avoid Shadowing Properties (QML)

**Shadowing** ocurre cuando introduces un identificador (variable, par√°metro, `id`, `property`, `function` local) con el **mismo nombre** que una propiedad accesible en el scope. El resultado es que **dejas de referirte a la propiedad** sin darte cuenta.

En QML esto es especialmente peligroso porque:

* los scopes (QML + JS) se mezclan,
* el motor permite nombres ‚Äúv√°lidos‚Äù aunque sem√°nticamente sean una trampa,
* el tooling pierde capacidad de an√°lisis,
* aparecen bugs silenciosos (bindings que ‚Äúparecen‚Äù bien, pero leen otra cosa).

---

## 1) Ejemplo m√≠nimo: par√°metro que sombrea una propiedad

```qml
Item {
    id: root
    property int value: 10

    function setValue(value) {   // <-- 'value' par√°metro SOMBRA root.value
        value = value + 1        // modifica el par√°metro, NO root.value
    }
}
```

**Qu√© pasa realmente:** dentro de `setValue`, `value` es el par√°metro. La propiedad `root.value` queda inaccesible por nombre simple.

### Correcci√≥n

* Cambia el nombre del par√°metro.
* O referencia expl√≠citamente con `root.value`.

```qml
Item {
    id: root
    property int value: 10

    function setValue(newValue: int): void {
        root.value = newValue
    }
}
```

---

## 2) Shadowing en handlers de se√±ales (muy t√≠pico)

```qml
Item {
    id: root
    property int index: 5

    MouseArea {
        anchors.fill: parent
        onClicked: (index) => {     // <-- par√°metro 'index' sombrea root.index
            console.log(index)      // imprime par√°metro, NO root.index
        }
    }
}
```

### Correcci√≥n

```qml
onClicked: (mouse) => {
    console.log(root.index)
}
```

Y evita nombres como `index`, `checked`, `value`, `text`, `state` como par√°metros si ya existen en el componente.

---

## 3) Shadowing con variables locales en bindings/JS

```qml
Item {
    id: root
    property int count: 3

    Component.onCompleted: {
        let count = 10        // <-- sombrea root.count en este bloque
        console.log(count)    // 10, no 3
    }
}
```

Esto puede ser aceptable si es intencional, pero en QML suele ser un accidente.

### Correcci√≥n

* Usa nombres locales con prefijo (`localCount`, `tmpCount`).
* O usa `root.count` siempre que sea propiedad.

---

## 4) Shadowing en delegates (frecuente y confuso)

En un `ListView`, el delegate recibe `index` autom√°ticamente. Si adem√°s t√∫ defines algo con el mismo nombre, creas ambig√ºedad.

```qml
ListView {
    model: 10
    delegate: Item {
        property int index: 123   // <-- MAL: sombrea el index del delegate
        Text { text: index }      // ¬ø123 o el √≠ndice del modelo? -> tu propiedad
    }
}
```

### Correcci√≥n

* No definas propiedades con nombres reservados/impl√≠citos del delegate (`index`, `model`, `modelData`).
* Usa `rowIndex`, `itemIndex` si necesitas almacenar algo.

```qml
delegate: Item {
    property int rowIndex: index
    Text { text: rowIndex }
}
```

---

## 5) Shadowing con `id` (s√≠, tambi√©n)

Si pones un `id` con el mismo nombre que una propiedad ‚Äúconocida‚Äù del tipo o una propiedad que usas mucho, te creas un infierno sem√°ntico.

Ejemplo t√≠pico: usar `id: parent` o `id: text` (mala idea).

Regla pr√°ctica: `id`s con sem√°ntica clara y √∫nica (`root`, `view`, `delegateRoot`, `content`, `backend`).

---

## 6) Por qu√© es un problema serio en QML

### Bugs silenciosos

No crashea: simplemente lee/escribe en el sitio equivocado.

### Rompe mantenibilidad

Un refactor puede introducir un nombre que antes no exist√≠a y cambiar significado.

### Tooling m√°s d√©bil

`qmllint`/QML LS no siempre pueden inferir intenci√≥n si hay nombres colisionando.

---

## 7) Reglas operativas para evitarlo

1. **Siempre usa un `id` ra√≠z** (`id: root`) y referencia propiedades con `root.` en c√≥digo JS sensible.
2. **Par√°metros con prefijo**: `newValue`, `isChecked`, `mouseEvent`, `activatedIndex`.
3. En delegates, evita definir propiedades llamadas:

   * `index`, `model`, `modelData`
   * y tambi√©n `width`, `height`, `x`, `y`, `visible`, `enabled` (porque son propiedades del Item y confunden al leer).
4. Si un handler recibe un par√°metro, **n√≥mbralo expl√≠citamente** (y no uses nombres de propiedades existentes). Esto adem√°s evita el tema de *deprecated injected signal parameters*.

---

## 8) Ejemplo ‚Äúantes/despu√©s‚Äù realista (producci√≥n)

### ‚ùå Antes (shadowing + bug)

```qml
Item {
    id: root
    property bool enabled: true

    function setEnabled(enabled) {
        enabled = enabled  // no hace nada √∫til; sombrea root.enabled
    }
}
```

### ‚úÖ Despu√©s

```qml
Item {
    id: root
    property bool enabled: true

    function setEnabled(isEnabled: bool): void {
        root.enabled = isEnabled
    }
}
```

---

## 9) Checklist r√°pido para revisar tu QML

Busca en tu c√≥digo:

* `function foo(value) { ... value ... }` cuando existe `property ... value`
* `onXxx: (index) => ...` cuando existe `property index` o est√°s en un delegate
* `let text = ...` dentro de un componente que tiene `Text { id: text ... }` (o propiedad `text`)
* delegates con `property int index: ...`

Si aparece, refactor inmediato.

---


# Avoid Implicit Lookup in the Root Scope (QML)

En QML, ‚Äúimplicit lookup in the root scope‚Äù es cuando escribes un identificador **sin calificar** (sin `root.` / `someId.` / `Qt.` / `MySingleton.`) y conf√≠as en que el motor lo encuentre ‚Äúpor arte de magia‚Äù en el *scope chain*.

Ejemplos t√≠picos de lookup impl√≠cito:

* `width`, `height`, `x`, `y`, `parent`, `index` usados ‚Äúa pelo‚Äù
* `someFunction()` sin `root.someFunction()`
* `backend` sin `root.backend` (o sin `MyStore.backend`)
* `state` sin calificar (cuando hay varios `state` posibles)
* `foo` que el motor resuelve en root/ids/context properties/imports‚Ä¶ seg√∫n reglas de scope

La recomendaci√≥n es:

> En c√≥digo que no sea trivial, **no dependas de la resoluci√≥n impl√≠cita** del root scope. Usa referencias expl√≠citas.

---

## 1) Por qu√© es un problema (de verdad)

### 1.1 Ambig√ºedad y bugs silenciosos

QML resuelve nombres buscando en varios sitios (local scope JS ‚Üí ids ‚Üí propiedades del objeto actual ‚Üí scopes padres ‚Üí context properties ‚Üí singletons/imports‚Ä¶).
Peque√±os cambios (a√±adir una propiedad, renombrar un id, introducir un par√°metro) pueden cambiar **qu√© s√≠mbolo se est√° resolviendo**.

Resultado: compila/carga, pero hace otra cosa.

### 1.2 Shadowing accidental

Este principio est√° directamente conectado con *Avoid Shadowing Properties*:
un `let value` o un par√°metro `value` puede sombrear una propiedad `value` ‚Äúvisible‚Äù por lookup impl√≠cito. Si no calificas, te puedes estar refiriendo al s√≠mbolo equivocado.

### 1.3 Tooling y qmltc

`qmllint`, QML Language Server y compilaci√≥n AOT (qmltc) trabajan mucho mejor cuando las referencias son expl√≠citas:

* menos falsos positivos/negativos
* refactors m√°s seguros
* detecci√≥n temprana de errores

### 1.4 Rendimiento (secundario pero real)

La resoluci√≥n impl√≠cita puede implicar m√°s trabajo (b√∫squeda en cadena de scopes). No suele ser el cuello de botella, pero en UI grande y muy din√°mica suma.

---

## 2) Ejemplos concretos de lookup impl√≠cito peligroso

### Ejemplo A: funci√≥n sin calificar

```qml
Item {
    id: root
    property int value: 10

    function bump(): void { value += 1 }

    Component.onCompleted: {
        bump()          // lookup impl√≠cito: ¬øroot.bump() u otra cosa?
        console.log(value) // lookup impl√≠cito: ¬øroot.value o variable sombreada?
    }
}
```

**Correcto (expl√≠cito):**

```qml
Component.onCompleted: {
    root.bump()
    console.log(root.value)
}
```

---

### Ejemplo B: `Connections` / se√±ales externas

```qml
Item {
    id: root
    property int state: 0

    Connections {
        target: backend
        function onStateChanged(state) {
            // "state" aqu√≠ es el par√°metro, no root.state
            if (state === 2) console.log("error")
        }
    }
}
```

Aqu√≠ el bug es por shadowing, pero se vuelve m√°s dif√≠cil de ver si encima usas `state` sin `root.` en m√°s sitios.

**Correcto:**

```qml
function onStateChanged(newState) {
    root.state = newState
}
```

---

### Ejemplo C: delegates y `index`

En delegates existen s√≠mbolos impl√≠citos (`index`, `model`, `modelData`). Si adem√°s hay un `index` en otro scope y no calificas, el c√≥digo se vuelve fr√°gil.

**Recomendaci√≥n en delegates:**

* Usa `index` solo cuando est√©s **seguro** de que es el `index` del delegate.
* Si lo vas a pasar a funciones del root, p√°salo expl√≠citamente: `root.handleClicked(index)` y dentro usa `index` como par√°metro pero **con nombre no ambiguo** (`rowIndex`).

---

## 3) Patr√≥n recomendado: `id: root` + acceso expl√≠cito

Regla operativa simple:

1. En cada componente, define `id: root`.
2. En JS (handlers, funciones, bindings complejos), referencia **siempre** con `root.` lo que sea propiedad/funci√≥n del componente.
3. Para objetos externos, referencia por `id` o singleton (`backend`, `Store`, etc.) **siempre expl√≠cito**.

Ejemplo:

```qml
Item {
    id: root
    property int counter: 0

    function increment(step: int): void {
        root.counter += step
    }

    Timer {
        interval: 1000
        running: true
        repeat: true
        onTriggered: () => root.increment(1)
    }

    Text {
        text: `Counter: ${root.counter}`
    }
}
```

---

## 4) Import alias / singletons: explicitidad a nivel m√≥dulo

Otro caso cl√°sico de lookup impl√≠cito es cuando dependes de nombres ‚Äúglobales‚Äù por imports.

**Mejor: usar alias de import cuando hay riesgo de colisi√≥n o quieres claridad:**

```qml
import QtQuick as QQ

QQ.Item {
    // ...
}
```

Y para singletons, preferir acceso expl√≠cito:

```qml
import MyApp.Stores 1.0

Text { text: MyStore.userName }  // no "userName" suelto
```

---

## 5) Qu√© s√≠ puede ser impl√≠cito (pragm√°tico)

No hace falta escribir `root.width` siempre. En QML idiom√°tico es normal:

* dentro de un `Item`, usar `width`, `height`, `parent`, `anchors` sin calificar
* bindings muy simples

Pero en cuanto entras en:

* JS (handlers, funciones, `Connections`, `Component.onCompleted`)
* delegates
* componentes reutilizables con APIs grandes
* c√≥digo con riesgo de shadowing

**califica**.

Regla pragm√°tica:

* **Bindings simples:** OK impl√≠cito.
* **C√≥digo JS / l√≥gica:** expl√≠cito casi siempre.

---

## 6) Checklist de refactor inmediato

Busca y cambia:

* `someFunc()` ‚Üí `root.someFunc()` (si es tu funci√≥n)
* `value` ‚Üí `root.value` (si es tu propiedad) **en JS**
* `state`, `index`, `checked`, `text`, `enabled` usados sin calificar en handlers
* `Connections { onXxx: { ... } }` con variables ‚Äúm√°gicas‚Äù no expl√≠citas

---

## 7) Anti-patr√≥n t√≠pico y correcci√≥n

### ‚ùå Anti-patr√≥n

‚ÄúDependo de que el root tenga un `backend` en el contexto y lo llamo como si fuera global.‚Äù

```qml
onClicked: backend.start()
```

Si ma√±ana `backend` deja de existir como context property o se renombra, falla.

### ‚úÖ Correcto

Inyecta dependencia expl√≠cita al componente (y si aplica, `required`):

```qml
Item {
    id: root
    required property Backend backend

    Button {
        onClicked: () => root.backend.start()
    }
}
```

Esto refuerza contrato + elimina lookup impl√≠cito.

---

## Conclusi√≥n

‚ÄúAvoid Implicit Lookup in the Root Scope‚Äù es b√°sicamente: **no escribas QML como si tuviera variables globales m√°gicas**. En cuanto hay l√≥gica, usa referencias expl√≠citas (`root.` / `id.` / `Singleton.`). Ganas:

* determinismo
* refactor seguro
* menos bugs intermitentes
* mejor tooling

# Avoid Referencing Objects Outside the Component (QML)

Este principio significa: **un componente QML no debe ‚Äúalcanzar‚Äù (reach out) y usar IDs/objetos que est√°n fuera de su propio archivo/componente**, porque eso rompe el encapsulamiento y convierte tu UI en una red de dependencias impl√≠citas.

En otras palabras:

* ‚úÖ Un componente debe depender de **su API p√∫blica** (props/signals/methods).
* ‚ùå No debe depender de `someExternalId.someProperty` si `someExternalId` vive fuera.

---

## 1) Qu√© se considera ‚Äúreferenciar fuera del componente‚Äù

Ejemplo t√≠pico (mal):

```qml
// MyWidget.qml
Item {
    Text { text: header.title }     // header es un id del padre (fuera)
    Button { onClicked: stack.pop() } // stack es un id del padre (fuera)
}
```

Este `MyWidget` **no es reutilizable**: solo funciona si el padre tiene `id: header` y `id: stack` con esas APIs.

---

## 2) Por qu√© es un problema (impacto real)

### 2.1 Acoplamiento duro y fr√°gil

Cambias el nombre del `id` o reestructuras el padre y el componente explota.

### 2.2 Reutilizaci√≥n cero

No puedes mover ese componente a otra pantalla o proyecto sin arrastrar toda la estructura externa.

### 2.3 Tooling y refactor pobres

El QML LS / qmllint no puede inferir bien contratos si ‚Äúdependes de cosas m√°gicas‚Äù.

### 2.4 Bugs sutiles por scopes / shadowing

Si el componente se carga con `Loader`, en otro contexto o desde C++, ese lookup puede fallar o resolver otra cosa.

---

## 3) Forma correcta: inyecci√≥n expl√≠cita de dependencias

### Patr√≥n A: `required property` (recomendado)

```qml
// MyWidget.qml
import QtQuick
import QtQuick.Controls

Item {
    id: root
    required property string title
    required property var navigator   // mejor tipar si es tipo registrado

    Column {
        Text { text: root.title }
        Button {
            text: "Back"
            onClicked: () => root.navigator.pop()
        }
    }
}
```

Uso:

```qml
MyWidget {
    title: header.title
    navigator: stack
}
```

**Ventaja:** el componente declara lo que necesita. No ‚Äúadivina‚Äù d√≥nde est√°.

> Ideal: no uses `var` si puedes registrar un tipo `Navigator` o pasar un `StackView` tipado (seg√∫n tu arquitectura).

---

### Patr√≥n B: exponer se√±ales en vez de llamar ‚Äúhacia fuera‚Äù

En UI robusta, el componente no deber√≠a ejecutar navegaci√≥n directamente. Debe **emitir intenci√≥n**.

```qml
// MyWidget.qml
Item {
    id: root
    required property string title
    signal backRequested()

    Column {
        Text { text: root.title }
        Button {
            text: "Back"
            onClicked: () => root.backRequested()
        }
    }
}
```

Uso:

```qml
MyWidget {
    title: header.title
    onBackRequested: stack.pop()
}
```

**Ventaja:** desacoplas UI de navegaci√≥n/backends. Es el patr√≥n m√°s limpio.

---

### Patr√≥n C: pasar callbacks expl√≠citos (menos recomendable, pero v√°lido)

```qml
Item {
    id: root
    required property var onBack

    Button {
        text: "Back"
        onClicked: () => root.onBack()
    }
}
```

**Contras:** `var` + funciones reduce tipado/analizabilidad. √ösalo solo si no puedes modelar la dependencia.

---

## 4) Caso t√≠pico: componente que necesita backend

### ‚ùå Anti-patr√≥n: usar `backend` global/context property sin declararlo

```qml
Text { text: backend.temperature }      // ¬øde d√≥nde sale backend?
Button { onClicked: backend.start() }
```

### ‚úÖ Correcto: dependencia expl√≠cita

```qml
Item {
    id: root
    required property Backend backend

    Text { text: `${root.backend.temperature.toFixed(1)} ¬∞C` }
    Button { text: "Start"; onClicked: () => root.backend.start() }
}
```

O mejor a√∫n: **se√±ales** y el padre decide:

```qml
signal startRequested()
Button { onClicked: () => root.startRequested() }
```

---

## 5) Delegates: el sitio donde m√°s se rompe este principio

Un delegate NO deber√≠a hacer:

```qml
delegate: Item {
    MouseArea { onClicked: detailsPanel.show(model.id) } // detailsPanel fuera
}
```

Correcto:

```qml
delegate: Item {
    required property string deviceId
    signal clicked(deviceId: string)

    MouseArea { onClicked: () => clicked(deviceId) }
}
```

Y en el `ListView`:

```qml
ListView {
    delegate: MyDelegate {
        deviceId: model.deviceId
        onClicked: (id) => detailsPanel.show(id)
    }
}
```

---

## 6) Excepciones razonables (cu√°ndo s√≠ referenciar ‚Äúfuera‚Äù)

### 6.1 Singletons intencionales (App-wide)

Si defines un **Singleton** (QML singleton o C++ singleton) como dependencia global deliberada:

* `Theme`
* `Localization/I18n`
* `AppSettings`
* `Telemetry` (con cuidado)

Ejemplo:

```qml
Text { color: Theme.textPrimary }
```

Esto no es ‚Äúoutside object‚Äù accidental; es una dependencia global expl√≠cita por dise√±o.

**Regla:** si es global, debe ser global *de verdad* (Singleton importado), no un `id` del padre.

---

### 6.2 `parent` / `anchors` / `StackView.view` (APIs del framework)

Referenciar `parent` es normal y parte del modelo visual.

Pero no conviertas `parent` en ‚Äúservicio‚Äù:

* ‚ùå `parent.backend.doStuff()`
* ‚úÖ `anchors.fill: parent`

---

## 7) Regla operativa (r√°pida y aplicable)

Dentro de un componente reutilizable (`Foo.qml`):

* ‚úÖ Referencia: `root.<prop>` / `id` internos / singletons importados / `Qt.*`
* ‚ùå Referencia: IDs que no est√°n declarados en el archivo (`header`, `stack`, `appWindow`, `mainView`, etc.)

Si necesitas algo externo:

1. `required property T dep` **o**
2. `signal intent()` y el padre act√∫a.

---

## 8) Ejemplo ‚Äúantes / despu√©s‚Äù (refactor t√≠pico)

### Antes (acoplado)

```qml
// ControlPanel.qml
Item {
    Button { text: "Connect"; onClicked: backend.connect() } // backend fuera
    Text { text: statusLabel.text }                          // statusLabel fuera
}
```

### Despu√©s (encapsulado)

```qml
// ControlPanel.qml
Item {
    id: root
    required property Backend backend
    required property string statusText
    signal connectRequested()

    Button { text: "Connect"; onClicked: () => root.connectRequested() }
    Text { text: root.statusText }
}
```

Uso:

```qml
ControlPanel {
    backend: backend
    statusText: backend.statusText
    onConnectRequested: backend.connect()
}
```

Esto escala y es testeable.

---

## 9) Relaci√≥n con los principios anteriores

Este principio es el complemento de:

* **Avoid implicit lookup in root scope** (nada ‚Äúm√°gico‚Äù)
* **Avoid duck typing** (contratos)
* **Use required properties** (inyecci√≥n)
* **Prefer interaction signals** (intenci√≥n vs estado)
* **Delegates should not store state** (estado fuera)

Todo converge a: **componente aislado + dependencias expl√≠citas + flujo unidireccional**.

---

# Avoid Using `parent` for Property Qualification (QML)

Este principio significa:

> No uses `parent` como mecanismo para acceder a propiedades o l√≥gica del contenedor.
> √ösalo solo para relaciones puramente visuales (layout/anchoring).

En QML, `parent` describe la **jerarqu√≠a visual**, no la **jerarqu√≠a l√≥gica**.
Si dependes de `parent.someProperty`, est√°s acoplando tu componente a su posici√≥n en el √°rbol.

---

## 1. El problema real

Ejemplo t√≠pico (mal dise√±o):

```qml
Rectangle {
    property string title: "Main"

    MyWidget {
        Text {
            text: parent.title   // depende del parent
        }
    }
}
```

`MyWidget` solo funciona si:

* su `parent` tiene una propiedad `title`
* y adem√°s con ese nombre exacto

Si lo reutilizas en otro sitio:

* rompe
* o lee otra cosa
* o produce `undefined`

Esto es acoplamiento estructural impl√≠cito.

---

## 2. Por qu√© es peligroso

### 2.1 Fragilidad ante refactor

Si insertas un `Item` intermedio:

```qml
Rectangle {
    property string title: "Main"

    Item {
        MyWidget { }
    }
}
```

Ahora `parent` ya no es el que cre√≠as.

El comportamiento cambia sin warning claro.

---

### 2.2 Rompe reutilizaci√≥n

El componente no puede moverse libremente.

---

### 2.3 Oculta dependencias

El componente parece aut√≥nomo, pero depende de algo externo no declarado.

---

## 3. Cu√°ndo S√ç usar `parent`

Solo para:

* `anchors`
* posicionamiento visual
* layout visual
* tama√±o visual

Ejemplo correcto:

```qml
Rectangle {
    anchors.fill: parent
}
```

Esto es visual. Es leg√≠timo.

---

## 4. Cu√°ndo NO usar `parent`

‚ùå Para acceder a estado l√≥gico:

```qml
text: parent.temperature
onClicked: parent.start()
color: parent.active ? "green" : "gray"
```

Eso es dependencia l√≥gica disfrazada de visual.

---

## 5. Soluci√≥n correcta: inyecci√≥n expl√≠cita

### Patr√≥n recomendado

```qml
// MyWidget.qml
Item {
    id: root
    required property string title

    Text {
        text: root.title
    }
}
```

Uso:

```qml
Rectangle {
    property string title: "Main"

    MyWidget {
        title: title
    }
}
```

Ahora el contrato es expl√≠cito.

---

## 6. Caso com√∫n en dashboards

Mal dise√±o t√≠pico:

```qml
Gauge {
    value: parent.currentTemperature
}
```

Si cambias estructura:

* Se rompe.
* O toma otro parent.

Correcto:

```qml
Gauge {
    value: root.currentTemperature
}
```

O mejor:

```qml
Gauge {
    required property real value
}
```

Y el contenedor pasa `value`.

---

## 7. Anti-patr√≥n avanzado: `parent.parent`

Si ves esto:

```qml
parent.parent.backend.doSomething()
```

Es se√±al clara de arquitectura defectuosa.

Significa:

* El componente depende de la estructura exacta del √°rbol.
* Cualquier cambio rompe comportamiento.
* Es imposible de reutilizar.

Debe refactorizarse inmediatamente.

---

## 8. Diferencia importante: `parent` vs `id`

Esto:

```qml
anchors.fill: parent
```

Est√° bien.

Pero esto:

```qml
text: parent.title
```

Deber√≠a ser:

```qml
text: root.title
```

Porque `root` es estable; `parent` no lo es.

---

## 9. Patr√≥n robusto: `id: root`

Siempre define:

```qml
Item {
    id: root
}
```

Y usa:

```qml
text: root.someProperty
```

Nunca dependas de `parent` para l√≥gica.

---

## 10. Caso especial: Delegates

En delegates es a√∫n m√°s peligroso.

```qml
delegate: Item {
    Text { text: parent.someProperty }
}
```

Aqu√≠ `parent` puede ser:

* el `ListView`
* el `contentItem`
* un wrapper interno

No es contractual.

Si necesitas algo del exterior:

* p√°salo como propiedad
* o usa se√±al para comunicar intenci√≥n

---

## 11. Excepci√≥n leg√≠tima

Layouts autom√°ticos pueden usar `parent` en relaciones visuales:

```qml
width: parent.width * 0.5
```

Eso es razonable si es estrictamente layout.

Pero incluso ah√≠, en componentes reutilizables, suele ser mejor:

```qml
required property real availableWidth
width: availableWidth * 0.5
```

M√°s expl√≠cito y testeable.

---

## 12. Comparaci√≥n clara

| Uso                          | Correcto   |
| ---------------------------- | ---------- |
| `anchors.fill: parent`       | ‚úî          |
| `text: parent.title`         | ‚ùå          |
| `parent.backend.start()`     | ‚ùå          |
| `width: parent.width`        | ‚úî (visual) |
| `color: parent.active ? ...` | ‚ùå          |

---

## 13. Relaci√≥n con otros principios

Este principio refuerza:

* Avoid Referencing Objects Outside the Component
* Avoid Implicit Lookup
* Required Properties
* Single source of truth
* Declarative bindings

Todos apuntan a lo mismo:

> El √°rbol visual no es tu arquitectura l√≥gica.

---

## 14. Regla operativa fuerte

Si una referencia afecta:

* comportamiento
* estado
* l√≥gica
* backend
* navegaci√≥n

No debe usar `parent`.

Solo layout puede usar `parent`.

---
# `??` y `?.` en QML (Nullish Coalescing + Optional Chaining)

Qt ha ido incorporando features modernas de JavaScript al runtime de QML:

* **Nullish coalescing `??`**: soportado **desde Qt 5.15**. ([Documentaci√≥n de Qt][1])
* **Optional chaining `?.`**: soportado **desde Qt 6.2**. ([Documentaci√≥n de Qt][1])

La idea es escribir bindings y handlers **m√°s seguros** sin cascadas de `if (x && x.y && x.y.z)` ni defaults incorrectos con `||`.

---

## 1) `??` (Nullish coalescing): default solo para `null/undefined`

**Sem√°ntica:**
`a ?? b` devuelve `b` **solo si** `a` es `null` o `undefined`. Si `a` es `0`, `false` o `""`, **se queda con `a`**. ([MDN Web Docs][2])

### Por qu√© importa en QML

Much√≠simas propiedades v√°lidas son falsy:

* `opacity: 0`
* `index: 0`
* `text: ""`
* `checked: false`

Con `||` las pisas por error.

#### ‚ùå Mal (con `||`)

```qml
Text {
    // si title == "" (v√°lido), se sustituye por "Untitled" (no deseado)
    text: title || "Untitled"
}
```

#### ‚úÖ Bien (con `??`)

```qml
Text {
    // solo aplica default si title es null/undefined
    text: title ?? "Untitled"
}
```

### Caso t√≠pico con n√∫meros

```qml
Text {
    // si gain = 0, no queremos fallback
    text: `Gain: ${(gain ?? 0).toFixed(1)}`
}
```

---

## 2) `?.` (Optional chaining): acceso seguro a propiedades/llamadas

**Sem√°ntica b√°sica:**

* `obj?.prop` ‚Üí si `obj` es `null/undefined`, devuelve `undefined` sin lanzar error.
* `obj?.method?.()` ‚Üí igual para m√©todos.
* `arr?.[i]` ‚Üí igual para indexaci√≥n.

### En QML, para qu√© sirve

* Objetos que llegan tarde (Loader, async, context properties).
* Estructuras opcionales (por ejemplo, backend a√∫n no inicializado).
* JSON din√°mico (aunque idealmente lo tipas, esto reduce crashes).

#### ‚ùå Mal (crashea si `backend` es null)

```qml
Text { text: backend.temperature.toFixed(1) }
```

#### ‚úÖ Bien

```qml
Text { text: `${backend?.temperature?.toFixed(1) ?? "-"} ¬∞C` }
```

---

## 3) `?.` + `??`: patr√≥n est√°ndar (safe read + default)

Este es el uso can√≥nico:

```qml
Text {
    text: user?.profile?.address?.city ?? "Unknown"
}
```

* `?.` evita el TypeError.
* `??` da un valor por defecto cuando el resultado es `undefined`/`null`. ([MDN Web Docs][2])

---

## 4) Errores frecuentes y correcciones

### Error A: usar `||` como default ‚Äúr√°pido‚Äù

Si el valor puede ser `0/false/""`, **no uses `||`**.

**Usa `??`**, salvo que *quieras* que `0` se trate como ‚Äúvac√≠o‚Äù (raro en UI t√©cnica).

---

### Error B: optional chaining como ‚Äúparche‚Äù de dise√±o

`?.` no debe ocultar APIs mal definidas. Si esperas que algo exista, **iny√©ctalo** con `required property` y tipado fuerte.

Ejemplo de *mejor arquitectura*:

```qml
Item {
    id: root
    required property Backend backend  // contrato expl√≠cito

    Text { text: `${root.backend.temperature.toFixed(1)} ¬∞C` }
}
```

En este caso, `backend?.temperature` ser√≠a un olor: est√°s aceptando que falte algo que en realidad es obligatorio.

---

### Error C: optional chaining redundante (warning de qmllint)

Qt tiene warning espec√≠fico para `?.` redundante cuando el base **no puede** ser null/undefined (p.ej. enums, objetos garantizados). ([Documentaci√≥n de Qt][3])

Ejemplo conceptual:

```qml
// si 'Qt' o un enum est√° garantizado, Qt?.Something es redundante
```

**Regla:** no uses `?.` ‚Äúpor defecto‚Äù. √ösalo cuando la nulidad sea real.

---

### Error D: ‚Äúmejor uso `?.` en vez de arreglar el origen‚Äù

Si `device` puede ser null en un delegate, muchas veces el problema es el flujo de datos:

* o el modelo no est√° tipado,
* o falta `required property`,
* o est√°s referenciando fuera del componente.

Soluci√≥n: arreglar contrato primero; `?.` como √∫ltimo recurso en zonas realmente opcionales.

---

## 5) Recomendaciones operativas

### Cu√°ndo usar `??`

* Defaults en UI donde `0/false/""` son valores v√°lidos.
* Strings formateadas donde `undefined` debe mostrarse como `"-"` o `"N/A"`.

### Cu√°ndo usar `?.`

* Objetos opcionales por ciclo de vida (Loader, inicializaci√≥n, null temporal).
* JSON y estructuras din√°micas (idealmente minimizadas).
* Accesos encadenados donde ser√≠a ilegible validar manualmente.

### Cu√°ndo NO usar `?.`

* Cuando la dependencia deber√≠a ser **obligatoria** ‚Üí usa `required` + tipo.
* Cuando te est√° escondiendo un bug (typo de propiedad, error de wiring, mala arquitectura).

---

## 6) Mini-gu√≠a ‚Äúlista para copiar‚Äù

* Default seguro:

  ```qml
  text: value ?? "‚Äî"
  ```
* Acceso seguro + default:

  ```qml
  text: obj?.sub?.value ?? "‚Äî"
  ```
* Llamada segura:

  ```qml
  backend?.start?.()
  ```
* Indexaci√≥n segura:

  ```qml
  text: items?.[index] ?? "‚Äî"
  ```

---

Si me dices tu versi√≥n de Qt (por ejemplo 6.2/6.5/6.6), te marco exactamente d√≥nde puedes/conviene usar `?.` y `??` en tu c√≥digo actual sin degradar el dise√±o (y d√≥nde es mejor reforzar contratos con `required` y tipos).

[1]: https://doc.qt.io/qt-6/qtqml-javascript-hostenvironment.html?utm_source=chatgpt.com "JavaScript Host Environment | Qt Qml | Qt 6.10.2"
[2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Nullish_coalescing?utm_source=chatgpt.com "Nullish coalescing operator (??) - JavaScript - MDN Web Docs"
[3]: https://doc.qt.io/qt-6/qmllint-warnings-and-errors-redundant-optional-chaining.html?utm_source=chatgpt.com "Redundant Optional Chaining | Qt Qml | Qt 6.10.2"


<---FILES--->

<---Ejemplo Basico--->

<---Ejemplo Avanzado--->

