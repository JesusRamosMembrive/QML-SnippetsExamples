<---EXPLANATION--->
### Patron Bridge (Puente)

El patron **Bridge** separa una abstraccion de su implementacion para que ambas puedan evolucionar de forma independiente. A diferencia de la herencia tradicional donde la abstraccion y la implementacion estan acopladas, Bridge introduce una **composicion** que actua como puente entre ambas jerarquias. Esto evita la explosion combinatoria de subclases que ocurre cuando tienes multiples dimensiones de variacion.

#### Problema

Supongamos que tienes una clase `Forma` con subclases `Circulo` y `Rectangulo`. Ahora necesitas agregar colores: `Rojo` y `Azul`. Con herencia directa, necesitarias `CirculoRojo`, `CirculoAzul`, `RectanguloRojo`, `RectanguloAzul` â€” 4 clases. Si agregas una tercera forma y un tercer color, necesitas 9 clases. El numero crece **multiplicativamente** con cada nueva dimension.

Este problema se conoce como **explosion de clases** y aparece siempre que tienes dos o mas dimensiones independientes de variacion (forma/color, plataforma/funcionalidad, dispositivo/protocolo).

#### Solucion

Bridge resuelve esto extrayendo una de las dimensiones en una jerarquia separada. La clase original (abstraccion) mantiene una referencia a un objeto de la nueva jerarquia (implementacion) en lugar de contener toda la funcionalidad directamente.

```cpp
// Implementacion: jerarquia independiente
class IColor {
public:
    virtual std::string aplicar() const = 0;
};

// Abstraccion: contiene una referencia al implementador
class Forma {
protected:
    IColor* color_; // Puente hacia la implementacion
public:
    Forma(IColor* c) : color_(c) {}
    virtual void dibujar() = 0;
};
```

Ahora `Circulo` y `Rectangulo` extienden `Forma`, mientras `Rojo` y `Azul` extienden `IColor`. Las combinaciones se hacen en **tiempo de ejecucion** mediante composicion, no mediante herencia.

#### Estructura

- **Abstraction (Abstraccion):** Define la interfaz de alto nivel y mantiene una referencia al `Implementor`. Delega el trabajo real a la implementacion.
- **RefinedAbstraction (Abstraccion Refinada):** Extiende la Abstraccion con funcionalidad adicional.
- **Implementor (Implementador):** Define la interfaz para las implementaciones concretas. No necesita coincidir con la interfaz de la Abstraccion.
- **ConcreteImplementor (Implementador Concreto):** Proporciona una implementacion especifica del Implementor.

##### Relacion clave

La Abstraccion **contiene** (composicion) al Implementor. Ambas jerarquias pueden crecer de forma independiente sin afectarse mutuamente.

#### Implementacion en C++

En C++ moderno se implementa con punteros inteligentes para gestionar la vida del implementador:

```cpp
class Abstraccion {
protected:
    std::unique_ptr<Implementador> impl_;
public:
    explicit Abstraccion(std::unique_ptr<Implementador> impl)
        : impl_(std::move(impl)) {}

    virtual void operacion() {
        impl_->operacionImplementacion();
    }
};
```

Un patron comun es usar el **Pimpl idiom** (Pointer to Implementation), que es una aplicacion directa del Bridge para ocultar detalles de implementacion y reducir tiempos de compilacion.

#### Ventajas y Desventajas

##### Ventajas
- **Independencia dimensional:** Las abstracciones e implementaciones evolucionan por separado.
- **Principio abierto/cerrado:** Puedes agregar nuevas abstracciones o implementaciones sin tocar el codigo existente.
- **Ocultar detalles:** El cliente solo ve la abstraccion, no la implementacion.
- **Cambio en tiempo de ejecucion:** Puedes cambiar la implementacion dinamicamente.

##### Desventajas
- **Mayor complejidad inicial:** Requiere definir interfaces adicionales y mas clases.
- **Indirecta:** El codigo puede ser mas dificil de seguir al tener que navegar entre la abstraccion y su implementacion.

#### Aplicacion en Qt

Qt aplica Bridge en varios subsistemas fundamentales:

- **`QPaintDevice` / `QPaintEngine`:** Esta es la aplicacion mas clara. `QPaintDevice` es la abstraccion (puede ser `QWidget`, `QPixmap`, `QImage`, `QPrinter`) y `QPaintEngine` es la implementacion (OpenGL, Raster, PDF, etc.). Puedes pintar en cualquier dispositivo con `QPainter` sin importar que motor de renderizado se usa internamente.

- **`QAbstractSocket`:** Separa la interfaz de socket (`QTcpSocket`, `QUdpSocket`) de la implementacion de red del sistema operativo subyacente.

- **Pimpl en Qt (d-pointer):** Qt usa extensivamente el patron Pimpl (una forma de Bridge) con los punteros `d_ptr` y `q_ptr`. Casi todas las clases publicas de Qt tienen una clase privada `*Private` que contiene la implementacion real, permitiendo mantener compatibilidad binaria entre versiones.

> **Nota:** El Pimpl idiom en Qt es tan importante que tiene macros dedicadas: `Q_DECLARE_PRIVATE`, `Q_D`, etc.

#### Cuando usar y cuando evitar

##### Cuando usar
- Cuando tienes 2 o mas dimensiones de variacion independientes.
- Cuando quieres evitar explosion de subclases por combinaciones.
- Cuando necesitas cambiar implementacion en tiempo de ejecucion.

##### Cuando evitar
- Si solo hay una dimension de cambio clara.
- Si la jerarquia es pequena y estable.
- Si la separacion abstraccion/implementacion agrega mas complejidad que valor.

<---FILES--->
Ejemplo Basico
Ejemplo Basico Result
Ejemplo Avanzado
Ejemplo Avanzado Result
Ejemplo con Qt
Ejemplo con Qt Result
Ejemplo Extra
Ejemplo Extra Result

<---Ejemplo Basico--->
```cpp
#include <iostream>
#include <memory>
#include <string>

// === Implementador: Define la interfaz de renderizado ===
class IRenderizador {
public:
    virtual ~IRenderizador() = default;
    virtual void renderizarCirculo(double x, double y, double radio) const = 0;
    virtual void renderizarRectangulo(double x, double y, double ancho, double alto) const = 0;
    virtual std::string nombre() const = 0;
};

// === Implementadores Concretos ===
class RenderizadorOpenGL : public IRenderizador {
public:
    void renderizarCirculo(double x, double y, double radio) const override {
        std::cout << "  [OpenGL] Circulo en (" << x << "," << y
                  << ") radio=" << radio << std::endl;
    }
    void renderizarRectangulo(double x, double y, double ancho, double alto) const override {
        std::cout << "  [OpenGL] Rectangulo en (" << x << "," << y
                  << ") " << ancho << "x" << alto << std::endl;
    }
    std::string nombre() const override { return "OpenGL"; }
};

class RenderizadorSVG : public IRenderizador {
public:
    void renderizarCirculo(double x, double y, double radio) const override {
        std::cout << "  [SVG] <circle cx=\"" << x << "\" cy=\"" << y
                  << "\" r=\"" << radio << "\"/>" << std::endl;
    }
    void renderizarRectangulo(double x, double y, double ancho, double alto) const override {
        std::cout << "  [SVG] <rect x=\"" << x << "\" y=\"" << y
                  << "\" width=\"" << ancho << "\" height=\"" << alto << "\"/>" << std::endl;
    }
    std::string nombre() const override { return "SVG"; }
};

// === Abstraccion: Forma con referencia al renderizador ===
class Forma {
protected:
    IRenderizador* renderizador_; // Puente
public:
    explicit Forma(IRenderizador* r) : renderizador_(r) {}
    virtual ~Forma() = default;
    virtual void dibujar() const = 0;
    virtual void mover(double dx, double dy) = 0;
};

// === Abstracciones Refinadas ===
class Circulo : public Forma {
    double x_, y_, radio_;
public:
    Circulo(IRenderizador* r, double x, double y, double radio)
        : Forma(r), x_(x), y_(y), radio_(radio) {}

    void dibujar() const override {
        renderizador_->renderizarCirculo(x_, y_, radio_);
    }
    void mover(double dx, double dy) override { x_ += dx; y_ += dy; }
};

class Rectangulo : public Forma {
    double x_, y_, ancho_, alto_;
public:
    Rectangulo(IRenderizador* r, double x, double y, double w, double h)
        : Forma(r), x_(x), y_(y), ancho_(w), alto_(h) {}

    void dibujar() const override {
        renderizador_->renderizarRectangulo(x_, y_, ancho_, alto_);
    }
    void mover(double dx, double dy) override { x_ += dx; y_ += dy; }
};

int main() {
    // Creamos renderizadores
    RenderizadorOpenGL opengl;
    RenderizadorSVG svg;

    // Mismas formas, diferentes renderizadores
    std::cout << "=== Dibujando con OpenGL ===" << std::endl;
    Circulo c1(&opengl, 10, 20, 5);
    Rectangulo r1(&opengl, 0, 0, 100, 50);
    c1.dibujar();
    r1.dibujar();

    std::cout << "\n=== Dibujando con SVG ===" << std::endl;
    Circulo c2(&svg, 10, 20, 5);
    Rectangulo r2(&svg, 0, 0, 100, 50);
    c2.dibujar();
    r2.dibujar();

    return 0;
}
```
<---Ejemplo Basico Result--->
=== Dibujando con OpenGL ===
  [OpenGL] Circulo en (10,20) radio=5
  [OpenGL] Rectangulo en (0,0) 100x50

=== Dibujando con SVG ===
  [SVG] <circle cx="10" cy="20" r="5"/>
  [SVG] <rect x="0" y="0" width="100" height="50"/>

<---Ejemplo Avanzado--->
```cpp
#include <iostream>
#include <memory>
#include <string>
#include <vector>

// === Implementador: Estrategia de notificacion ===
class ICanalNotificacion {
public:
    virtual ~ICanalNotificacion() = default;
    virtual void enviar(const std::string& destinatario,
                        const std::string& titulo,
                        const std::string& cuerpo) const = 0;
    virtual std::string tipo() const = 0;
};

class CanalEmail : public ICanalNotificacion {
public:
    void enviar(const std::string& destinatario,
                const std::string& titulo,
                const std::string& cuerpo) const override {
        std::cout << "  [EMAIL] Para: " << destinatario << std::endl;
        std::cout << "  Asunto: " << titulo << std::endl;
        std::cout << "  Cuerpo: " << cuerpo << std::endl;
    }
    std::string tipo() const override { return "Email"; }
};

class CanalSMS : public ICanalNotificacion {
public:
    void enviar(const std::string& destinatario,
                const std::string& titulo,
                const std::string& cuerpo) const override {
        // SMS tiene limite de caracteres, se concatena titulo + cuerpo
        std::string mensaje = titulo + ": " + cuerpo;
        if (mensaje.size() > 60) {
            mensaje = mensaje.substr(0, 57) + "...";
        }
        std::cout << "  [SMS] Para: " << destinatario << std::endl;
        std::cout << "  Mensaje: " << mensaje << std::endl;
    }
    std::string tipo() const override { return "SMS"; }
};

class CanalPush : public ICanalNotificacion {
public:
    void enviar(const std::string& destinatario,
                const std::string& titulo,
                const std::string& cuerpo) const override {
        std::cout << "  [PUSH] Dispositivo: " << destinatario << std::endl;
        std::cout << "  Notificacion: " << titulo << std::endl;
        std::cout << "  Detalle: " << cuerpo << std::endl;
    }
    std::string tipo() const override { return "Push"; }
};

// === Abstraccion: Tipo de mensaje ===
class Mensaje {
protected:
    std::unique_ptr<ICanalNotificacion> canal_;
    std::string destinatario_;
public:
    Mensaje(std::unique_ptr<ICanalNotificacion> canal, const std::string& dest)
        : canal_(std::move(canal)), destinatario_(dest) {}
    virtual ~Mensaje() = default;
    virtual void notificar() const = 0;
};

// === Abstracciones Refinadas: Diferentes tipos de mensajes ===
class MensajeUrgente : public Mensaje {
    std::string contenido_;
public:
    MensajeUrgente(std::unique_ptr<ICanalNotificacion> canal,
                   const std::string& dest, const std::string& contenido)
        : Mensaje(std::move(canal), dest), contenido_(contenido) {}

    void notificar() const override {
        std::string titulo = "[URGENTE] Accion requerida";
        std::string cuerpo = "PRIORIDAD ALTA - " + contenido_;
        canal_->enviar(destinatario_, titulo, cuerpo);
    }
};

class MensajeInformativo : public Mensaje {
    std::string contenido_;
public:
    MensajeInformativo(std::unique_ptr<ICanalNotificacion> canal,
                       const std::string& dest, const std::string& contenido)
        : Mensaje(std::move(canal), dest), contenido_(contenido) {}

    void notificar() const override {
        canal_->enviar(destinatario_, "Informacion", contenido_);
    }
};

class MensajePromocion : public Mensaje {
    std::string producto_;
    double descuento_;
public:
    MensajePromocion(std::unique_ptr<ICanalNotificacion> canal,
                     const std::string& dest, const std::string& producto,
                     double descuento)
        : Mensaje(std::move(canal), dest), producto_(producto),
          descuento_(descuento) {}

    void notificar() const override {
        std::string titulo = "Oferta especial: " + producto_;
        std::string cuerpo = "Descuento del " + std::to_string(static_cast<int>(descuento_))
                           + "% en " + producto_ + ". Aprovecha ahora!";
        canal_->enviar(destinatario_, titulo, cuerpo);
    }
};

int main() {
    std::cout << "=== Sistema de Notificaciones (Bridge) ===" << std::endl;

    // Mensaje urgente por email
    std::cout << "\n--- Urgente por Email ---" << std::endl;
    MensajeUrgente m1(std::make_unique<CanalEmail>(),
                      "admin@empresa.com", "Servidor caido");
    m1.notificar();

    // Mensaje urgente por SMS (misma abstraccion, diferente implementacion)
    std::cout << "\n--- Urgente por SMS ---" << std::endl;
    MensajeUrgente m2(std::make_unique<CanalSMS>(),
                      "+52-555-1234567", "Servidor caido");
    m2.notificar();

    // Promocion por push
    std::cout << "\n--- Promocion por Push ---" << std::endl;
    MensajePromocion m3(std::make_unique<CanalPush>(),
                        "device-token-abc", "Laptop Pro", 25.0);
    m3.notificar();

    // Informativo por email
    std::cout << "\n--- Informativo por Email ---" << std::endl;
    MensajeInformativo m4(std::make_unique<CanalEmail>(),
                          "usuario@correo.com", "Su pedido ha sido enviado");
    m4.notificar();

    return 0;
}
```
<---Ejemplo Avanzado Result--->
=== Sistema de Notificaciones (Bridge) ===

--- Urgente por Email ---
  [EMAIL] Para: admin@empresa.com
  Asunto: [URGENTE] Accion requerida
  Cuerpo: PRIORIDAD ALTA - Servidor caido

--- Urgente por SMS ---
  [SMS] Para: +52-555-1234567
  Mensaje: [URGENTE] Accion requerida: PRIORIDAD ALTA - Servidor c...

--- Promocion por Push ---
  [PUSH] Dispositivo: device-token-abc
  Notificacion: Oferta especial: Laptop Pro
  Detalle: Descuento del 25% en Laptop Pro. Aprovecha ahora!

--- Informativo por Email ---
  [EMAIL] Para: usuario@correo.com
  Asunto: Informacion
  Cuerpo: Su pedido ha sido enviado

<---Ejemplo con Qt--->
```cpp
#include <QCoreApplication>
#include <QPainter>
#include <QImage>
#include <QSvgGenerator>
#include <QDebug>
#include <memory>

// =====================================================
// Demostracion del Bridge en Qt: QPainter + QPaintDevice
//
// QPaintDevice es la abstraccion (superficie de dibujo)
// QPaintEngine es la implementacion concreta (interna de Qt)
// QPainter actua como cliente que usa ese puente.
//
// El mismo codigo de dibujo funciona en QImage, QPixmap,
// QSvgGenerator, QPrinter, QWidget, etc.
// =====================================================

// Funcion de dibujo generica - usa QPainter sin importar el dispositivo
void dibujarEscena(QPainter& painter, int ancho, int alto) {
    // Fondo
    painter.fillRect(0, 0, ancho, alto, Qt::white);

    // Rectangulo azul
    painter.setPen(QPen(Qt::blue, 2));
    painter.setBrush(QBrush(Qt::cyan));
    painter.drawRect(10, 10, ancho - 20, alto - 20);

    // Circulo rojo
    painter.setPen(QPen(Qt::red, 3));
    painter.setBrush(QBrush(QColor(255, 100, 100, 128)));
    painter.drawEllipse(ancho / 4, alto / 4, ancho / 2, alto / 2);

    // Texto
    painter.setPen(Qt::black);
    QFont fuente("Arial", 14);
    painter.setFont(fuente);
    painter.drawText(ancho / 2 - 40, alto / 2, "Bridge Qt");
}

int main(int argc, char* argv[]) {
    QCoreApplication app(argc, argv);

    const int ANCHO = 400;
    const int ALTO = 300;

    // === Implementacion 1: Renderizar a QImage (raster) ===
    qDebug() << "=== Bridge: QPainter + QPaintDevice ===\n";

    QImage imagen(ANCHO, ALTO, QImage::Format_ARGB32);
    {
        QPainter painter(&imagen);  // Puente: QPainter -> QImage
        painter.setRenderHint(QPainter::Antialiasing);
        dibujarEscena(painter, ANCHO, ALTO);
    }
    // Guardar resultado
    imagen.save("escena_raster.png");
    qDebug() << "Imagen raster guardada: escena_raster.png"
             << "(" << imagen.width() << "x" << imagen.height() << ")";

    // === Implementacion 2: Renderizar a SVG ===
    QSvgGenerator svg;
    svg.setFileName("escena_vector.svg");
    svg.setSize(QSize(ANCHO, ALTO));
    svg.setViewBox(QRect(0, 0, ANCHO, ALTO));
    {
        QPainter painter(&svg);  // Puente: QPainter -> QSvgGenerator
        painter.setRenderHint(QPainter::Antialiasing);
        dibujarEscena(painter, ANCHO, ALTO);
    }
    qDebug() << "Imagen SVG guardada: escena_vector.svg";

    // === Ejemplo Pimpl (d-pointer) estilo Qt ===
    qDebug() << "\n=== Patron Pimpl (d-pointer) estilo Qt ===";
    qDebug() << "Qt usa el Bridge internamente con d-pointers:";
    qDebug() << "  - Clase publica: QWidget";
    qDebug() << "  - Clase privada: QWidgetPrivate (implementacion)";
    qDebug() << "  - Permite cambiar la implementacion sin romper ABI";
    qDebug() << "  - Macros: Q_DECLARE_PRIVATE, Q_D(Clase)";

    return 0;
}
```
<---Ejemplo con Qt Result--->
=== Bridge: QPainter + QPaintDevice ===

Imagen raster guardada: escena_raster.png ( 400 x 300 )
Imagen SVG guardada: escena_vector.svg

=== Patron Pimpl (d-pointer) estilo Qt ===
Qt usa el Bridge internamente con d-pointers:
  - Clase publica: QWidget
  - Clase privada: QWidgetPrivate (implementacion)
  - Permite cambiar la implementacion sin romper ABI
  - Macros: Q_DECLARE_PRIVATE, Q_D(Clase)

<---Ejemplo Extra--->
```cpp
#include <iostream>
#include <memory>
#include <string>

// Implementador: canal de envio
class ICanal {
public:
    virtual ~ICanal() = default;
    virtual void enviar(const std::string& destino,
                        const std::string& payload) const = 0;
};

class CanalEmail : public ICanal {
public:
    void enviar(const std::string& destino,
                const std::string& payload) const override {
        std::cout << "  [Email] " << destino << " <- " << payload << std::endl;
    }
};

class CanalSMS : public ICanal {
public:
    void enviar(const std::string& destino,
                const std::string& payload) const override {
        std::cout << "  [SMS] " << destino << " <- " << payload << std::endl;
    }
};

// Abstraccion: tipo de mensaje
class Mensaje {
public:
    explicit Mensaje(std::shared_ptr<ICanal> canal) : canal_(std::move(canal)) {}
    virtual ~Mensaje() = default;
    virtual void notificar(const std::string& destino) const = 0;

protected:
    std::shared_ptr<ICanal> canal_;
};

class MensajeAlerta : public Mensaje {
public:
    using Mensaje::Mensaje;
    void notificar(const std::string& destino) const override {
        canal_->enviar(destino, "ALERTA: CPU > 90%");
    }
};

class MensajeInfo : public Mensaje {
public:
    using Mensaje::Mensaje;
    void notificar(const std::string& destino) const override {
        canal_->enviar(destino, "INFO: Backup completado");
    }
};

int main() {
    std::cout << "=== Bridge Extra ===" << std::endl;

    auto email = std::make_shared<CanalEmail>();
    auto sms = std::make_shared<CanalSMS>();

    MensajeAlerta alertaPorEmail(email);
    MensajeAlerta alertaPorSMS(sms);
    MensajeInfo infoPorEmail(email);

    alertaPorEmail.notificar("ops@empresa.com");
    alertaPorSMS.notificar("+34123456789");
    infoPorEmail.notificar("admin@empresa.com");

    return 0;
}
```
<---Ejemplo Extra Result--->
=== Bridge Extra ===
  [Email] ops@empresa.com <- ALERTA: CPU > 90%
  [SMS] +34123456789 <- ALERTA: CPU > 90%
  [Email] admin@empresa.com <- INFO: Backup completado
