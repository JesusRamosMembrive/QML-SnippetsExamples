<---EXPLANATION--->
### Definición de Clase, Clase Base y Clase Derivada en C++

En la programación orientada a objetos (POO) en C++, las clases son los bloques de construcción fundamentales que encapsulan datos y comportamientos relacionados. La herencia permite crear jerarquías de clases donde una clase puede heredar atributos y métodos de otra. Entender la diferencia entre clases base y clases derivadas es crucial para aprovechar al máximo las ventajas de la POO.

#### Definición de Clase

Una clase en C++ es una plantilla para crear objetos. Una clase define un conjunto de atributos (datos) y métodos (funciones) que operan sobre esos datos. Los atributos representan el estado del objeto, mientras que los métodos representan el comportamiento del objeto.

##### Sintaxis Básica de una Clase

```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
```

##### Ejemplo de una Clase Básica

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
```

En este ejemplo, `Persona` es una clase con dos atributos (`nombre` y `edad`) y un método (`mostrarInformacion`).

#### Definición de Clase Base

Una clase base (también conocida como superclase o clase padre) es una clase que se utiliza como punto de partida para crear otras clases mediante herencia. La clase base proporciona atributos y métodos que son comunes a todas las clases derivadas.

##### Ejemplo de una Clase Base

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
```

En este ejemplo, `Animal` es una clase base que define dos métodos (`comer` y `dormir`) que son comunes a todos los animales.

#### Definición de Clase Derivada

Una clase derivada (también conocida como subclase o clase hija) es una clase que hereda atributos y métodos de otra clase (la clase base). La clase derivada puede extender o modificar el comportamiento de la clase base.

##### Sintaxis Básica de una Clase Derivada

```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
```

- **`public`** indica que la herencia es pública, es decir, los miembros públicos y protegidos de la clase base permanecen públicos y protegidos en la clase derivada.

##### Ejemplo de una Clase Derivada

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
```

En este ejemplo:
- `Animal` es la clase base que define métodos comunes (`comer` y `dormir`).
- `Perro` es la clase derivada que hereda de `Animal` y añade un método adicional (`ladrar`).

#### Clases Derivadas con Constructores Heredados (C++11)

A partir de C++11, las clases derivadas pueden heredar los constructores de su clase base mediante la declaración `using Base::Base;`. Esto simplifica significativamente el código cuando la clase derivada no necesita lógica adicional en sus constructores. Además, C++11 introdujo las palabras clave `= default` y `= delete` para controlar explícitamente las funciones miembro especiales (constructor por defecto, constructor de copia, operador de asignación y destructor).

- **`using Base::Base;`** — Hereda todos los constructores de la clase base.
- **`= default`** — Le indica al compilador que genere la implementación por defecto de una función miembro especial.
- **`= delete`** — Elimina una función miembro especial, impidiendo su uso.

##### Ejemplo de Constructores Heredados y Funciones Especiales

```cpp
#include <iostream>
#include <string>
using namespace std;

class Figura {
protected:
    string nombre;
    string color;

public:
    // Constructor parametrizado
    Figura(const string& n, const string& c) : nombre(n), color(c) {
        cout << "Figura creada: " << nombre << " (" << color << ")" << endl;
    }

    // Constructor con solo nombre
    Figura(const string& n) : nombre(n), color("sin color") {
        cout << "Figura creada: " << nombre << endl;
    }

    // Destructor por defecto generado por el compilador
    virtual ~Figura() = default;

    // Prohibir la copia de figuras
    Figura(const Figura&) = delete;
    Figura& operator=(const Figura&) = delete;

    virtual void dibujar() const {
        cout << "Dibujando " << nombre << " de color " << color << endl;
    }
};

class Circulo : public Figura {
public:
    // Heredar todos los constructores de Figura
    using Figura::Figura;

    // Sobrescribir el método dibujar
    void dibujar() const override {
        cout << "Dibujando círculo: " << nombre << " de color " << color << endl;
    }
};

int main() {
    // Usa el constructor Figura(nombre, color) heredado
    Circulo c1("Sol", "amarillo");
    c1.dibujar();

    cout << endl;

    // Usa el constructor Figura(nombre) heredado
    Circulo c2("Luna");
    c2.dibujar();

    // Error de compilación: copia eliminada con = delete
    // Circulo c3 = c1;

    return 0;
}
```

En este ejemplo, `Circulo` hereda los constructores de `Figura` con `using Figura::Figura;`. El destructor se genera automáticamente con `= default`, y el constructor de copia y el operador de asignación se eliminan con `= delete` para evitar copias accidentales de objetos.

#### Jerarquía de Clases en Qt

Qt utiliza una jerarquía de clases muy organizada donde la mayoría de las clases derivan de `QObject`. Para los componentes de interfaz gráfica, la cadena de herencia es especialmente clara:

```
QObject → QWidget → QFrame → QLabel
QObject → QWidget → QAbstractButton → QPushButton
QObject → QWidget → QAbstractSlider → QSlider
```

En Qt, las clases derivadas reciben un puntero `parent` (padre) que establece una relación de propiedad. Cuando un objeto padre se destruye, automáticamente destruye a todos sus hijos, simplificando la gestión de memoria.

Cada nivel de la jerarquía añade funcionalidad:
- **`QObject`** — Sistema de meta-objetos, señales y slots, gestión padre-hijo.
- **`QWidget`** — Funcionalidad básica de ventana: posición, tamaño, eventos de pintado, foco.
- **`QFrame`** — Añade marcos y bordes configurables.
- **`QLabel`** — Muestra texto o imágenes con formato.

##### Ejemplo de Jerarquía de Clases en Qt

```cpp
#include <QApplication>
#include <QWidget>
#include <QLabel>
#include <QPushButton>
#include <QVBoxLayout>
#include <QDebug>

// Clase derivada de QWidget: ventana personalizada
class VentanaPrincipal : public QWidget {
    Q_OBJECT

public:
    explicit VentanaPrincipal(QWidget* parent = nullptr)
        : QWidget(parent)  // Llamada al constructor de la clase base
    {
        setWindowTitle("Jerarquía Qt");
        resize(300, 200);

        // Crear layout vertical (hijo de esta ventana)
        QVBoxLayout* layout = new QVBoxLayout(this);

        // QLabel hereda: QObject → QWidget → QFrame → QLabel
        QLabel* etiqueta = new QLabel("Ejemplo de jerarquía de clases", this);
        layout->addWidget(etiqueta);

        // QPushButton hereda: QObject → QWidget → QAbstractButton → QPushButton
        QPushButton* boton = new QPushButton("Hacer clic", this);
        layout->addWidget(boton);

        // Conectar señal del botón a un slot
        connect(boton, &QPushButton::clicked, this, &VentanaPrincipal::alHacerClic);

        // Mostrar la jerarquía de padres de la etiqueta
        qDebug() << "Jerarquía de la etiqueta:";
        QObject* obj = etiqueta;
        while (obj) {
            qDebug() << " ->" << obj->metaObject()->className();
            obj = obj->parent();
        }
    }

private slots:
    void alHacerClic() {
        qDebug() << "Botón presionado";
        // Mostrar cantidad de hijos de esta ventana
        qDebug() << "Hijos de VentanaPrincipal:" << children().count();
    }
};

int main(int argc, char* argv[]) {
    QApplication app(argc, argv);

    VentanaPrincipal ventana;
    ventana.show();

    return app.exec();
    // Al cerrar, 'ventana' se destruye y con ella todos sus hijos
    // (etiqueta, boton, layout) automáticamente
}
```

En este ejemplo, `VentanaPrincipal` hereda de `QWidget`, que a su vez hereda de `QObject`. Los widgets hijos (`QLabel`, `QPushButton`) se crean pasando `this` como padre, lo que establece la relación de propiedad. Al destruirse la ventana principal, todos los hijos se destruyen automáticamente.

### Conclusión

Las clases son los bloques de construcción fundamentales en la programación orientada a objetos en C++. Una clase encapsula datos y comportamientos, proporcionando una plantilla para crear objetos. Las clases base y derivadas permiten la reutilización y extensión del código a través de la herencia, donde las clases derivadas heredan y pueden extender los atributos y métodos de las clases base. Esta estructura facilita la organización, mantenimiento y expansión del código en proyectos de software complejos.
<---FILES--->
Sintaxis Básica de una Clase
Sintaxis Básica de una Clase Result
Ejemplo de una Clase Básica
Ejemplo de una Clase Básica Result
Ejemplo de una Clase Base
Ejemplo de una Clase Base Result
Sintaxis Básica de una Clase Derivada
Sintaxis Básica de una Clase Derivada Result
Ejemplo de una Clase Derivada
Ejemplo de una Clase Derivada Result
Ejemplo de Constructores Heredados y Funciones Especiales
Ejemplo de Constructores Heredados y Funciones Especiales Result
Ejemplo de Jerarquía de Clases en Qt
Ejemplo de Jerarquía de Clases en Qt Result
<---Sintaxis Básica de una Clase--->
```cpp
class NombreClase {
public:
    // Atributos
    tipo_atributo nombre_atributo;

    // Métodos
    tipo_retorno nombre_metodo(parametros);

    // Otros componentes, como constructores, destructores, etc.
};
<---Sintaxis Básica de una Clase Result--->
<---Ejemplo de una Clase Básica--->
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;
    int edad;

    // Constructor
    Persona(string n, int e) : nombre(n), edad(e) {}

    // Método para mostrar información
    void mostrarInformacion() const {
        cout << "Nombre: " << nombre << ", Edad: " << edad << endl;
    }
};

int main() {
    Persona juan("Juan", 30);
    juan.mostrarInformacion();

    return 0;
}
<---Ejemplo de una Clase Básica Result--->
<---Ejemplo de una Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};
<---Ejemplo de una Clase Base Result--->
<---Sintaxis Básica de una Clase Derivada--->
```cpp
class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales
};
<---Sintaxis Básica de una Clase Derivada Result--->
<---Ejemplo de una Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() const {
        cout << "El animal está comiendo." << endl;
    }

    void dormir() const {
        cout << "El animal está durmiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() const {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.dormir(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo de una Clase Derivada Result--->
<---Ejemplo de Constructores Heredados y Funciones Especiales--->
```cpp
#include <iostream>
#include <string>
using namespace std;

class Figura {
protected:
    string nombre;
    string color;

public:
    // Constructor parametrizado
    Figura(const string& n, const string& c) : nombre(n), color(c) {
        cout << "Figura creada: " << nombre << " (" << color << ")" << endl;
    }

    // Constructor con solo nombre
    Figura(const string& n) : nombre(n), color("sin color") {
        cout << "Figura creada: " << nombre << endl;
    }

    // Destructor por defecto generado por el compilador
    virtual ~Figura() = default;

    // Prohibir la copia de figuras
    Figura(const Figura&) = delete;
    Figura& operator=(const Figura&) = delete;

    virtual void dibujar() const {
        cout << "Dibujando " << nombre << " de color " << color << endl;
    }
};

class Circulo : public Figura {
public:
    // Heredar todos los constructores de Figura
    using Figura::Figura;

    // Sobrescribir el método dibujar
    void dibujar() const override {
        cout << "Dibujando círculo: " << nombre << " de color " << color << endl;
    }
};

int main() {
    // Usa el constructor Figura(nombre, color) heredado
    Circulo c1("Sol", "amarillo");
    c1.dibujar();

    cout << endl;

    // Usa el constructor Figura(nombre) heredado
    Circulo c2("Luna");
    c2.dibujar();

    // Error de compilación: copia eliminada con = delete
    // Circulo c3 = c1;

    return 0;
}
<---Ejemplo de Constructores Heredados y Funciones Especiales Result--->
<---Ejemplo de Jerarquía de Clases en Qt--->
```cpp
#include <QApplication>
#include <QWidget>
#include <QLabel>
#include <QPushButton>
#include <QVBoxLayout>
#include <QDebug>

// Clase derivada de QWidget: ventana personalizada
class VentanaPrincipal : public QWidget {
    Q_OBJECT

public:
    explicit VentanaPrincipal(QWidget* parent = nullptr)
        : QWidget(parent)  // Llamada al constructor de la clase base
    {
        setWindowTitle("Jerarquía Qt");
        resize(300, 200);

        // Crear layout vertical (hijo de esta ventana)
        QVBoxLayout* layout = new QVBoxLayout(this);

        // QLabel hereda: QObject → QWidget → QFrame → QLabel
        QLabel* etiqueta = new QLabel("Ejemplo de jerarquía de clases", this);
        layout->addWidget(etiqueta);

        // QPushButton hereda: QObject → QWidget → QAbstractButton → QPushButton
        QPushButton* boton = new QPushButton("Hacer clic", this);
        layout->addWidget(boton);

        // Conectar señal del botón a un slot
        connect(boton, &QPushButton::clicked, this, &VentanaPrincipal::alHacerClic);

        // Mostrar la jerarquía de padres de la etiqueta
        qDebug() << "Jerarquía de la etiqueta:";
        QObject* obj = etiqueta;
        while (obj) {
            qDebug() << " ->" << obj->metaObject()->className();
            obj = obj->parent();
        }
    }

private slots:
    void alHacerClic() {
        qDebug() << "Botón presionado";
        // Mostrar cantidad de hijos de esta ventana
        qDebug() << "Hijos de VentanaPrincipal:" << children().count();
    }
};

int main(int argc, char* argv[]) {
    QApplication app(argc, argv);

    VentanaPrincipal ventana;
    ventana.show();

    return app.exec();
    // Al cerrar, 'ventana' se destruye y con ella todos sus hijos
    // (etiqueta, boton, layout) automáticamente
}
<---Ejemplo de Jerarquía de Clases en Qt Result--->
