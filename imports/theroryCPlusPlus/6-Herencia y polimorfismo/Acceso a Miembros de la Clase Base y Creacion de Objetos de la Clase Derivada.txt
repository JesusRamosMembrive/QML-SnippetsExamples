<---EXPLANATION--->
### Acceso a Miembros de la Clase Base y Creación de Objetos de la Clase Derivada en C++

En la programación orientada a objetos en C++, la herencia permite que las clases derivadas accedan a los miembros de la clase base y extiendan su funcionalidad. Entender cómo se accede a estos miembros y cómo se crean objetos de clases derivadas es crucial para aprovechar al máximo la herencia.

#### Acceso a Miembros de la Clase Base

En C++, los miembros de una clase base pueden tener diferentes niveles de acceso: `public`, `protected`, y `private`. La accesibilidad de estos miembros en una clase derivada depende del especificador de acceso utilizado en la herencia y del nivel de acceso original de los miembros en la clase base.

##### Especificadores de Acceso

- **`public`:** Los miembros públicos de la clase base se mantienen públicos en la clase derivada. Los miembros protegidos de la clase base se mantienen protegidos en la clase derivada.
- **`protected`:** Los miembros públicos y protegidos de la clase base se convierten en protegidos en la clase derivada.
- **`private`:** Los miembros públicos y protegidos de la clase base se convierten en privados en la clase derivada.

##### Ejemplo de Acceso a Miembros de la Clase Base

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class DerivadaPublic : public Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPublic:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaProtected : protected Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaProtected:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaPrivate : private Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPrivate:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10;
    objPublic.mostrar();

    DerivadaProtected objProtected;
    // objProtected.publicVar = 20; // No accesible desde fuera de la clase derivada
    objProtected.mostrar();

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 30; // No accesible desde fuera de la clase derivada
    objPrivate.mostrar();

    return 0;
}
```

En este ejemplo, mostramos cómo los miembros de la clase base son accesibles en clases derivadas dependiendo del especificador de acceso utilizado en la herencia.

#### Creación de Objetos de la Clase Derivada

La creación de objetos de la clase derivada sigue las mismas reglas básicas que la creación de objetos de cualquier clase en C++. Sin embargo, es importante entender cómo se inicializan los miembros de la clase base durante la construcción de un objeto derivado.

##### Constructores de Clases Derivadas

Cuando se crea un objeto de una clase derivada, el constructor de la clase base se llama automáticamente antes de que se ejecute el constructor de la clase derivada. La lista de inicialización del constructor de la clase derivada se puede utilizar para inicializar los miembros de la clase base.

##### Ejemplo de Creación de Objetos de la Clase Derivada

```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int baseVar;

public:
    // Constructor de la clase base
    Base(int v) : baseVar(v) {
        cout << "Constructor de la clase Base llamado con valor " << baseVar << endl;
    }

    void mostrarBase() const {
        cout << "Valor de baseVar: " << baseVar << endl;
    }
};

class Derivada : public Base {
private:
    int derivadaVar;

public:
    // Constructor de la clase derivada
    Derivada(int baseVal, int derivadaVal) : Base(baseVal), derivadaVar(derivadaVal) {
        cout << "Constructor de la clase Derivada llamado con valor " << derivadaVar << endl;
    }

    void mostrarDerivada() const {
        mostrarBase();
        cout << "Valor de derivadaVar: " << derivadaVar << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    obj.mostrarDerivada();

    return 0;
}
```

En este ejemplo:
- La clase `Base` tiene un constructor que inicializa `baseVar`.
- La clase `Derivada` hereda de `Base` y su constructor inicializa tanto `baseVar` (a través de la lista de inicialización) como `derivadaVar`.

#### Invocación de Constructores de la Clase Base

El constructor de la clase base se llama automáticamente antes de que se ejecute el constructor de la clase derivada. Esto asegura que todos los miembros de la clase base se inicialicen correctamente antes de inicializar los miembros de la clase derivada.

##### Ejemplo de Invocación de Constructores

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base llamado" << endl;
    }

    Base(int x) {
        cout << "Constructor de Base llamado con valor " << x << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada llamado" << endl;
    }

    Derivada(int y) : Base(y) {
        cout << "Constructor de Derivada llamado con valor " << y << endl;
    }
};

int main() {
    cout << "Creando obj1:" << endl;
    Derivada obj1;

    cout << "\nCreando obj2:" << endl;
    Derivada obj2(100);

    return 0;
}
```

En este ejemplo, vemos cómo el constructor de la clase base se llama automáticamente antes del constructor de la clase derivada. Cuando se crea `obj2` con un valor, el constructor parametrizado de `Base` se invoca con el valor proporcionado.

#### Herencia de Constructores con `using Base::Base` (C++11)

A partir de C++11, es posible heredar todos los constructores de la clase base en la clase derivada mediante una única declaración `using`. Esto evita tener que reescribir manualmente cada constructor cuando la clase derivada no necesita lógica adicional de construcción. Sin embargo, si la clase derivada tiene miembros propios, estos se inicializarán con sus valores por defecto a menos que se proporcione un inicializador en la declaración del miembro.

##### Ejemplo de Herencia de Constructores con `using`

```cpp
#include <iostream>
#include <string>
using namespace std;

class Vehiculo {
protected:
    string marca;
    int anio;

public:
    Vehiculo() : marca("Desconocido"), anio(0) {
        cout << "Constructor por defecto de Vehiculo" << endl;
    }

    Vehiculo(const string& m) : marca(m), anio(0) {
        cout << "Constructor de Vehiculo con marca: " << marca << endl;
    }

    Vehiculo(const string& m, int a) : marca(m), anio(a) {
        cout << "Constructor de Vehiculo con marca y anio: "
             << marca << ", " << anio << endl;
    }

    void mostrar() const {
        cout << "Marca: " << marca << ", Anio: " << anio;
    }
};

class Auto : public Vehiculo {
private:
    int numPuertas = 4; // Valor por defecto para el miembro propio

public:
    // Hereda TODOS los constructores de Vehiculo
    using Vehiculo::Vehiculo;

    // Constructor adicional propio de Auto
    Auto(const string& m, int a, int puertas)
        : Vehiculo(m, a), numPuertas(puertas) {
        cout << "Constructor de Auto con puertas: " << numPuertas << endl;
    }

    void mostrarCompleto() const {
        mostrar();
        cout << ", Puertas: " << numPuertas << endl;
    }
};

int main() {
    cout << "--- auto1 (constructor por defecto heredado) ---" << endl;
    Auto auto1;
    auto1.mostrarCompleto();

    cout << "\n--- auto2 (constructor con marca heredado) ---" << endl;
    Auto auto2("Toyota");
    auto2.mostrarCompleto();

    cout << "\n--- auto3 (constructor con marca y anio heredado) ---" << endl;
    Auto auto3("Honda", 2023);
    auto3.mostrarCompleto();

    cout << "\n--- auto4 (constructor propio de Auto) ---" << endl;
    Auto auto4("BMW", 2024, 2);
    auto4.mostrarCompleto();

    return 0;
}
```

En este ejemplo, la clase `Auto` hereda todos los constructores de `Vehiculo` con `using Vehiculo::Vehiculo`. Cuando se usan los constructores heredados, el miembro `numPuertas` toma su valor por defecto (`4`). Además, `Auto` define su propio constructor adicional que permite especificar el número de puertas.

#### Inicialización Agregada de Clases Derivadas (C++17)

C++17 introdujo la posibilidad de usar inicialización agregada para clases derivadas cuando tanto la clase base como la derivada son agregados (es decir, no tienen constructores definidos por el usuario, no tienen miembros privados ni protegidos, y no tienen funciones virtuales). Esto permite inicializar los miembros de la base y de la derivada directamente con llaves `{}`.

##### Ejemplo de Inicialización Agregada de Clases Derivadas

```cpp
#include <iostream>
#include <string>
using namespace std;

// Clase base agregada (sin constructores definidos por el usuario)
struct Punto {
    double x;
    double y;
};

// Clase derivada agregada
struct Punto3D : Punto {
    double z;
};

// Otro ejemplo con structs más complejos
struct DatosPersona {
    string nombre;
    int edad;
};

struct Empleado : DatosPersona {
    string departamento;
    double salario;
};

int main() {
    // Inicialización agregada C++17: {base, miembros_derivados}
    Punto3D p1{{1.0, 2.0}, 3.0};
    cout << "Punto3D: (" << p1.x << ", " << p1.y << ", " << p1.z << ")" << endl;

    // También se puede usar con más miembros
    Empleado emp{{"Carlos", 30}, "Ingenieria", 55000.0};
    cout << "Empleado: " << emp.nombre << ", edad " << emp.edad
         << ", depto: " << emp.departamento
         << ", salario: " << emp.salario << endl;

    // Inicialización parcial (los campos no especificados se inicializan a cero/vacío)
    Punto3D p2{{5.0}, 10.0};
    cout << "Punto3D parcial: (" << p2.x << ", " << p2.y << ", " << p2.z << ")" << endl;

    return 0;
}
```

En este ejemplo, `Punto3D` hereda de `Punto` y ambos son agregados. Gracias a C++17, podemos inicializarlos con la sintaxis `{{miembros_base}, miembros_derivados}`. Lo mismo se aplica a `Empleado` que hereda de `DatosPersona`. Esta sintaxis es especialmente útil para tipos de datos simples que no requieren lógica de construcción compleja.

### Conclusión

La herencia en C++ permite que las clases derivadas accedan a los miembros de la clase base y extiendan su funcionalidad. Los especificadores de acceso (`public`, `protected`, `private`) juegan un papel crucial en determinar cómo los miembros de la clase base son accesibles en la clase derivada. La creación de objetos de la clase derivada implica la llamada automática al constructor de la clase base, asegurando que todos los miembros se inicialicen correctamente. Entender estos conceptos es esencial para diseñar jerarquías de clases efectivas y aprovechar al máximo la programación orientada a objetos en C++.
<---FILES--->
Especificadores de Acceso
Especificadores de Acceso Result
Ejemplo de Acceso a Miembros de la Clase Base
Ejemplo de Acceso a Miembros de la Clase Base Result
Constructores de Clases Derivadas
Constructores de Clases Derivadas Result
Ejemplo de Creación de Objetos de la Clase Derivada
Ejemplo de Creación de Objetos de la Clase Derivada Result
Ejemplo de Invocación de Constructores
Ejemplo de Invocación de Constructores Result
Ejemplo de Herencia de Constructores con `using`
Ejemplo de Herencia de Constructores con `using` Result
Ejemplo de Inicialización Agregada de Clases Derivadas
Ejemplo de Inicialización Agregada de Clases Derivadas Result
<---Especificadores de Acceso--->
<---Especificadores de Acceso Result--->
<---Ejemplo de Acceso a Miembros de la Clase Base--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;

protected:
    int protectedVar;

private:
    int privateVar;
};

class DerivadaPublic : public Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPublic:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaProtected : protected Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaProtected:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

class DerivadaPrivate : private Base {
public:
    void mostrar() {
        cout << "Acceso en DerivadaPrivate:" << endl;
        cout << "publicVar: " << publicVar << endl; // Accesible
        cout << "protectedVar: " << protectedVar << endl; // Accesible
        // cout << "privateVar: " << privateVar << endl; // No accesible
    }
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10;
    objPublic.mostrar();

    DerivadaProtected objProtected;
    // objProtected.publicVar = 20; // No accesible desde fuera de la clase derivada
    objProtected.mostrar();

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 30; // No accesible desde fuera de la clase derivada
    objPrivate.mostrar();

    return 0;
}
<---Ejemplo de Acceso a Miembros de la Clase Base Result--->
<---Constructores de Clases Derivadas--->
<---Constructores de Clases Derivadas Result--->
<---Ejemplo de Creación de Objetos de la Clase Derivada--->
```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int baseVar;

public:
    // Constructor de la clase base
    Base(int v) : baseVar(v) {
        cout << "Constructor de la clase Base llamado con valor " << baseVar << endl;
    }

    void mostrarBase() const {
        cout << "Valor de baseVar: " << baseVar << endl;
    }
};

class Derivada : public Base {
private:
    int derivadaVar;

public:
    // Constructor de la clase derivada
    Derivada(int baseVal, int derivadaVal) : Base(baseVal), derivadaVar(derivadaVal) {
        cout << "Constructor de la clase Derivada llamado con valor " << derivadaVar << endl;
    }

    void mostrarDerivada() const {
        mostrarBase();
        cout << "Valor de derivadaVar: " << derivadaVar << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    obj.mostrarDerivada();

    return 0;
}
<---Ejemplo de Creación de Objetos de la Clase Derivada Result--->
<---Ejemplo de Invocación de Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base llamado" << endl;
    }

    Base(int x) {
        cout << "Constructor de Base llamado con valor " << x << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada llamado" << endl;
    }

    Derivada(int y) : Base(y) {
        cout << "Constructor de Derivada llamado con valor " << y << endl;
    }
};

int main() {
    cout << "Creando obj1:" << endl;
    Derivada obj1;

    cout << "\nCreando obj2:" << endl;
    Derivada obj2(100);

    return 0;
}
<---Ejemplo de Invocación de Constructores Result--->
<---Ejemplo de Herencia de Constructores con `using`--->
```cpp
#include <iostream>
#include <string>
using namespace std;

class Vehiculo {
protected:
    string marca;
    int anio;

public:
    Vehiculo() : marca("Desconocido"), anio(0) {
        cout << "Constructor por defecto de Vehiculo" << endl;
    }

    Vehiculo(const string& m) : marca(m), anio(0) {
        cout << "Constructor de Vehiculo con marca: " << marca << endl;
    }

    Vehiculo(const string& m, int a) : marca(m), anio(a) {
        cout << "Constructor de Vehiculo con marca y anio: "
             << marca << ", " << anio << endl;
    }

    void mostrar() const {
        cout << "Marca: " << marca << ", Anio: " << anio;
    }
};

class Auto : public Vehiculo {
private:
    int numPuertas = 4; // Valor por defecto para el miembro propio

public:
    // Hereda TODOS los constructores de Vehiculo
    using Vehiculo::Vehiculo;

    // Constructor adicional propio de Auto
    Auto(const string& m, int a, int puertas)
        : Vehiculo(m, a), numPuertas(puertas) {
        cout << "Constructor de Auto con puertas: " << numPuertas << endl;
    }

    void mostrarCompleto() const {
        mostrar();
        cout << ", Puertas: " << numPuertas << endl;
    }
};

int main() {
    cout << "--- auto1 (constructor por defecto heredado) ---" << endl;
    Auto auto1;
    auto1.mostrarCompleto();

    cout << "\n--- auto2 (constructor con marca heredado) ---" << endl;
    Auto auto2("Toyota");
    auto2.mostrarCompleto();

    cout << "\n--- auto3 (constructor con marca y anio heredado) ---" << endl;
    Auto auto3("Honda", 2023);
    auto3.mostrarCompleto();

    cout << "\n--- auto4 (constructor propio de Auto) ---" << endl;
    Auto auto4("BMW", 2024, 2);
    auto4.mostrarCompleto();

    return 0;
}
<---Ejemplo de Herencia de Constructores con `using` Result--->
<---Ejemplo de Inicialización Agregada de Clases Derivadas--->
```cpp
#include <iostream>
#include <string>
using namespace std;

// Clase base agregada (sin constructores definidos por el usuario)
struct Punto {
    double x;
    double y;
};

// Clase derivada agregada
struct Punto3D : Punto {
    double z;
};

// Otro ejemplo con structs más complejos
struct DatosPersona {
    string nombre;
    int edad;
};

struct Empleado : DatosPersona {
    string departamento;
    double salario;
};

int main() {
    // Inicialización agregada C++17: {base, miembros_derivados}
    Punto3D p1{{1.0, 2.0}, 3.0};
    cout << "Punto3D: (" << p1.x << ", " << p1.y << ", " << p1.z << ")" << endl;

    // También se puede usar con más miembros
    Empleado emp{{"Carlos", 30}, "Ingenieria", 55000.0};
    cout << "Empleado: " << emp.nombre << ", edad " << emp.edad
         << ", depto: " << emp.departamento
         << ", salario: " << emp.salario << endl;

    // Inicialización parcial (los campos no especificados se inicializan a cero/vacío)
    Punto3D p2{{5.0}, 10.0};
    cout << "Punto3D parcial: (" << p2.x << ", " << p2.y << ", " << p2.z << ")" << endl;

    return 0;
}
<---Ejemplo de Inicialización Agregada de Clases Derivadas Result--->
