<---EXPLANATION--->
### Clases Abstractas en C++

Las clases abstractas son un concepto fundamental en la programación orientada a objetos en C++. Proporcionan una manera de definir interfaces comunes para sus clases derivadas y permiten diseñar sistemas más flexibles y extensibles. Una clase abstracta es una clase que no puede ser instanciada directamente y se utiliza principalmente como una base para otras clases.

#### Definición de Clase Abstracta

Una clase abstracta en C++ es una clase que contiene al menos una función miembro pura virtual. Una función miembro pura virtual se declara añadiendo `= 0` al final de su declaración. Las clases derivadas deben proporcionar implementaciones para todas las funciones miembro puras virtuales de la clase abstracta para ser instanciadas.

##### Sintaxis

```cpp
class NombreClaseAbstracta {
public:
    virtual void funcionPuraVirtual() = 0; // Función pura virtual
};
```

#### Ejemplo de Clase Abstracta

Consideremos un ejemplo donde queremos definir una jerarquía de clases para diferentes tipos de animales. La clase base `Animal` será una clase abstracta porque tiene una función pura virtual `hacerSonido`.

##### Ejemplo de Implementación

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función pura virtual

    virtual ~Animal() {
        // Destructor virtual
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    // Animal a; // Error: no se puede instanciar una clase abstracta

    Animal* p = new Perro();
    Animal* g = new Gato();

    p->hacerSonido(); // Llama a Perro::hacerSonido()
    g->hacerSonido(); // Llama a Gato::hacerSonido()

    delete p;
    delete g;

    return 0;
}
```

En este ejemplo:
- `Animal` es una clase abstracta porque tiene una función pura virtual `hacerSonido`.
- `Perro` y `Gato` son clases derivadas que proporcionan implementaciones específicas de `hacerSonido`.

#### Uso de Clases Abstractas

Las clases abstractas son útiles cuando se desea definir una interfaz común para un conjunto de clases derivadas. Permiten que las clases derivadas compartan una estructura común y obligan a estas clases a proporcionar implementaciones específicas para las funciones puras virtuales.

##### Ventajas de Usar Clases Abstractas

1. **Interfaz Común:** Proveen una interfaz común para todas las clases derivadas, asegurando que todas implementen ciertas funciones.
2. **Extensibilidad:** Facilitan la extensibilidad del código. Nuevas clases derivadas pueden añadirse sin cambiar la interfaz de la clase base.
3. **Flexibilidad:** Permiten escribir código más flexible y reusable, ya que el código puede operar sobre punteros o referencias a la clase abstracta sin conocer los detalles de las clases derivadas específicas.

##### Ejemplo de Uso en una Colección

```cpp
#include <iostream>
#include <vector>
using namespace std;

class Figura {
public:
    virtual void dibujar() const = 0; // Función pura virtual
    virtual ~Figura() {}
};

class Circulo : public Figura {
public:
    void dibujar() const override {
        cout << "Dibujando un círculo" << endl;
    }
};

class Cuadrado : public Figura {
public:
    void dibujar() const override {
        cout << "Dibujando un cuadrado" << endl;
    }
};

int main() {
    vector<Figura*> figuras;
    figuras.push_back(new Circulo());
    figuras.push_back(new Cuadrado());

    for (const auto& figura : figuras) {
        figura->dibujar();
    }

    // Liberar memoria
    for (const auto& figura : figuras) {
        delete figura;
    }

    return 0;
}
```

En este ejemplo:
- `Figura` es una clase abstracta con una función pura virtual `dibujar`.
- `Circulo` y `Cuadrado` son clases derivadas que proporcionan implementaciones específicas de `dibujar`.
- Un vector de punteros a `Figura` permite almacenar y operar sobre diferentes tipos de figuras de manera polimórfica.

#### Consideraciones al Usar Clases Abstractas

1. **Destructores Virtuales:** Siempre declarar destructores virtuales en clases abstractas para asegurar una correcta liberación de recursos en las clases derivadas.
2. **Implementaciones Comunes:** Si una función pura virtual tiene una implementación común que puede ser compartida por algunas clases derivadas, puede ser implementada en la clase base como una función virtual no pura.
3. **Combinación con Otras Características:** Las clases abstractas pueden combinarse con otras características de la POO, como la herencia múltiple y los templates, para diseñar sistemas más complejos y flexibles.

#### Interfaces en C++ (Clases Puramente Abstractas)

A diferencia de lenguajes como Java o C#, C++ no tiene una palabra clave `interface`. Sin embargo, existe una convención ampliamente adoptada para simular interfaces: crear clases que contengan **únicamente funciones puras virtuales** y un **destructor virtual**, sin miembros de datos ni implementación alguna.

Las características de una interfaz en C++ son:
1. **Solo funciones puras virtuales:** Todas las funciones miembro son `virtual ... = 0`.
2. **Destructor virtual:** Necesario para la correcta destrucción polimórfica.
3. **Sin datos miembro:** No almacena estado propio.
4. **Sin implementación:** Las funciones no tienen cuerpo.
5. **Nombre con prefijo `I`:** Por convención, los nombres de interfaces empiezan con `I` (ej: `ISerializable`, `ICloneable`).

Una ventaja importante es que C++ permite **herencia múltiple**, lo que significa que una clase puede implementar múltiples interfaces simultáneamente, algo que no es posible con herencia de clases regulares en muchos otros lenguajes.

##### Ejemplo de Interfaces en C++

```cpp
#include <iostream>
#include <string>
#include <memory>
using namespace std;

// Interfaz ISerializable: capacidad de convertir a/desde texto
class ISerializable {
public:
    virtual ~ISerializable() = default;
    virtual string serializar() const = 0;
    virtual void deserializar(const string& datos) = 0;
};

// Interfaz ICloneable: capacidad de crear una copia
class ICloneable {
public:
    virtual ~ICloneable() = default;
    virtual unique_ptr<ICloneable> clonar() const = 0;
};

// Interfaz IImprimible: capacidad de imprimir en consola
class IImprimible {
public:
    virtual ~IImprimible() = default;
    virtual void imprimir() const = 0;
};

// Clase que implementa múltiples interfaces
class Contacto : public ISerializable, public ICloneable, public IImprimible {
    string nombre;
    string email;

public:
    Contacto() = default;
    Contacto(const string& nombre, const string& email)
        : nombre(nombre), email(email) {}

    // Implementación de ISerializable
    string serializar() const override {
        return nombre + "|" + email;
    }

    void deserializar(const string& datos) override {
        size_t pos = datos.find('|');
        if (pos != string::npos) {
            nombre = datos.substr(0, pos);
            email = datos.substr(pos + 1);
        }
    }

    // Implementación de ICloneable
    unique_ptr<ICloneable> clonar() const override {
        return make_unique<Contacto>(*this);
    }

    // Implementación de IImprimible
    void imprimir() const override {
        cout << "Contacto: " << nombre << " <" << email << ">" << endl;
    }
};

// Funciones que trabajan con interfaces específicas
void guardarDatos(const ISerializable& obj) {
    cout << "Datos serializados: " << obj.serializar() << endl;
}

void mostrarEnPantalla(const IImprimible& obj) {
    obj.imprimir();
}

int main() {
    Contacto original("Ana García", "ana@ejemplo.com");

    cout << "=== Objeto original ===" << endl;
    mostrarEnPantalla(original);
    guardarDatos(original);

    cout << "\n=== Clon del objeto ===" << endl;
    auto copia = original.clonar();
    // Necesitamos hacer cast porque clonar() devuelve ICloneable*
    if (auto* contactoCopia = dynamic_cast<Contacto*>(copia.get())) {
        mostrarEnPantalla(*contactoCopia);
    }

    cout << "\n=== Deserialización ===" << endl;
    Contacto nuevo;
    nuevo.deserializar("Carlos López|carlos@ejemplo.com");
    mostrarEnPantalla(nuevo);

    return 0;
}
```

En este ejemplo:
- `ISerializable`, `ICloneable` e `IImprimible` son interfaces puras: solo funciones virtuales puras y destructor virtual.
- `Contacto` implementa las tres interfaces usando herencia múltiple.
- Las funciones `guardarDatos` y `mostrarEnPantalla` aceptan cualquier objeto que implemente la interfaz correspondiente, sin importar su tipo concreto.

#### Clases Abstractas en Qt: QAbstractItemModel

Qt hace un uso extensivo de clases abstractas para definir marcos de trabajo (frameworks) que el usuario debe completar. Uno de los ejemplos más importantes es el sistema de modelos de datos basado en `QAbstractItemModel` y sus variantes simplificadas como `QAbstractListModel`.

Para crear un modelo personalizado con `QAbstractListModel`, se deben anular al menos:
- **`rowCount()`**: Devuelve la cantidad de filas en el modelo.
- **`data()`**: Devuelve los datos para un índice y rol específicos.
- **`roleNames()`** (opcional): Define nombres personalizados para los roles, necesario para acceder a los datos desde QML.

El sistema de roles permite que un mismo elemento tenga múltiples datos asociados (nombre, color, tamaño, etc.), cada uno identificado por un rol numérico.

##### Ejemplo de QAbstractListModel Personalizado

```cpp
#include <QAbstractListModel>
#include <QStringList>
#include <QColor>

// Modelo personalizado para una lista de tareas
class ModeloTareas : public QAbstractListModel {
    Q_OBJECT

public:
    // Definir roles personalizados
    enum RolesTarea {
        RolTitulo = Qt::UserRole + 1,
        RolCompletada,
        RolPrioridad
    };

    struct Tarea {
        QString titulo;
        bool completada;
        int prioridad; // 1 = baja, 2 = media, 3 = alta
    };

    explicit ModeloTareas(QObject* parent = nullptr)
        : QAbstractListModel(parent) {}

    // === Funciones que DEBEMOS anular (obligatorias) ===

    // Devuelve la cantidad de filas en el modelo
    int rowCount(const QModelIndex& parent = QModelIndex()) const override {
        if (parent.isValid())
            return 0; // En un modelo de lista, los hijos no tienen filas
        return static_cast<int>(m_tareas.size());
    }

    // Devuelve los datos para un índice y rol específicos
    QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override {
        if (!index.isValid() || index.row() < 0
            || index.row() >= static_cast<int>(m_tareas.size()))
            return {};

        const Tarea& tarea = m_tareas.at(index.row());

        switch (role) {
        case RolTitulo:
            return tarea.titulo;
        case RolCompletada:
            return tarea.completada;
        case RolPrioridad:
            return tarea.prioridad;
        case Qt::DisplayRole:
            return tarea.titulo;
        default:
            return {};
        }
    }

    // === Función opcional pero necesaria para QML ===

    // Define los nombres de roles para acceder desde QML
    QHash<int, QByteArray> roleNames() const override {
        QHash<int, QByteArray> roles;
        roles[RolTitulo] = "titulo";
        roles[RolCompletada] = "completada";
        roles[RolPrioridad] = "prioridad";
        return roles;
    }

    // === Funciones adicionales para manipular el modelo ===

    // Agregar una tarea
    Q_INVOKABLE void agregarTarea(const QString& titulo, int prioridad = 2) {
        beginInsertRows(QModelIndex(), rowCount(), rowCount());
        m_tareas.push_back({titulo, false, prioridad});
        endInsertRows();
    }

    // Marcar tarea como completada
    Q_INVOKABLE void completarTarea(int indice) {
        if (indice < 0 || indice >= static_cast<int>(m_tareas.size()))
            return;

        m_tareas[indice].completada = true;
        QModelIndex idx = index(indice);
        emit dataChanged(idx, idx, {RolCompletada});
    }

    // Eliminar una tarea
    Q_INVOKABLE void eliminarTarea(int indice) {
        if (indice < 0 || indice >= static_cast<int>(m_tareas.size()))
            return;

        beginRemoveRows(QModelIndex(), indice, indice);
        m_tareas.erase(m_tareas.begin() + indice);
        endRemoveRows();
    }

private:
    std::vector<Tarea> m_tareas;
};
```

En este ejemplo:
- `ModeloTareas` hereda de `QAbstractListModel` y anula las funciones puras virtuales obligatorias: `rowCount()` y `data()`.
- Se definen roles personalizados (`RolTitulo`, `RolCompletada`, `RolPrioridad`) para que cada tarea pueda exponer múltiples datos.
- `roleNames()` mapea los roles numéricos a nombres de cadena, permitiendo acceder a los datos desde QML con `model.titulo`, `model.completada`, etc.
- Las funciones `agregarTarea`, `completarTarea` y `eliminarTarea` usan `beginInsertRows`/`endInsertRows`, `dataChanged` y `beginRemoveRows`/`endRemoveRows` para notificar a las vistas de los cambios.
- Las funciones marcadas con `Q_INVOKABLE` pueden ser llamadas directamente desde QML.

### Conclusión

Las clases abstractas en C++ son una herramienta poderosa para definir interfaces comunes y asegurar que todas las clases derivadas implementen ciertas funciones. Facilitan la extensibilidad y la reutilización del código, permitiendo escribir aplicaciones más flexibles y mantenibles. Comprender cómo y cuándo usar clases abstractas es esencial para aprovechar al máximo las capacidades de la programación orientada a objetos en C++.
<---FILES--->
Sintaxis
Sintaxis Result
Ejemplo de Implementación
Ejemplo de Implementación Result
Ventajas de Usar Clases Abstractas
Ventajas de Usar Clases Abstractas Result
Ejemplo de Uso en una Colección
Ejemplo de Uso en una Colección Result
Ejemplo de Interfaces en C++
Ejemplo de Interfaces en C++ Result
Ejemplo de QAbstractListModel Personalizado
Ejemplo de QAbstractListModel Personalizado Result
<---Sintaxis--->
```cpp
class NombreClaseAbstracta {
public:
    virtual void funcionPuraVirtual() = 0; // Función pura virtual
};
<---Sintaxis Result--->
<---Ejemplo de Implementación--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    virtual void hacerSonido() const = 0; // Función pura virtual

    virtual ~Animal() {
        // Destructor virtual
    }
};

class Perro : public Animal {
public:
    void hacerSonido() const override {
        cout << "El perro ladra" << endl;
    }
};

class Gato : public Animal {
public:
    void hacerSonido() const override {
        cout << "El gato maúlla" << endl;
    }
};

int main() {
    // Animal a; // Error: no se puede instanciar una clase abstracta

    Animal* p = new Perro();
    Animal* g = new Gato();

    p->hacerSonido(); // Llama a Perro::hacerSonido()
    g->hacerSonido(); // Llama a Gato::hacerSonido()

    delete p;
    delete g;

    return 0;
}
<---Ejemplo de Implementación Result--->
<---Ventajas de Usar Clases Abstractas--->
<---Ventajas de Usar Clases Abstractas Result--->
<---Ejemplo de Uso en una Colección--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

class Figura {
public:
    virtual void dibujar() const = 0; // Función pura virtual
    virtual ~Figura() {}
};

class Circulo : public Figura {
public:
    void dibujar() const override {
        cout << "Dibujando un círculo" << endl;
    }
};

class Cuadrado : public Figura {
public:
    void dibujar() const override {
        cout << "Dibujando un cuadrado" << endl;
    }
};

int main() {
    vector<Figura*> figuras;
    figuras.push_back(new Circulo());
    figuras.push_back(new Cuadrado());

    for (const auto& figura : figuras) {
        figura->dibujar();
    }

    // Liberar memoria
    for (const auto& figura : figuras) {
        delete figura;
    }

    return 0;
}
<---Ejemplo de Uso en una Colección Result--->
<---Ejemplo de Interfaces en C++--->
```cpp
#include <iostream>
#include <string>
#include <memory>
using namespace std;

// Interfaz ISerializable: capacidad de convertir a/desde texto
class ISerializable {
public:
    virtual ~ISerializable() = default;
    virtual string serializar() const = 0;
    virtual void deserializar(const string& datos) = 0;
};

// Interfaz ICloneable: capacidad de crear una copia
class ICloneable {
public:
    virtual ~ICloneable() = default;
    virtual unique_ptr<ICloneable> clonar() const = 0;
};

// Interfaz IImprimible: capacidad de imprimir en consola
class IImprimible {
public:
    virtual ~IImprimible() = default;
    virtual void imprimir() const = 0;
};

// Clase que implementa múltiples interfaces
class Contacto : public ISerializable, public ICloneable, public IImprimible {
    string nombre;
    string email;

public:
    Contacto() = default;
    Contacto(const string& nombre, const string& email)
        : nombre(nombre), email(email) {}

    // Implementación de ISerializable
    string serializar() const override {
        return nombre + "|" + email;
    }

    void deserializar(const string& datos) override {
        size_t pos = datos.find('|');
        if (pos != string::npos) {
            nombre = datos.substr(0, pos);
            email = datos.substr(pos + 1);
        }
    }

    // Implementación de ICloneable
    unique_ptr<ICloneable> clonar() const override {
        return make_unique<Contacto>(*this);
    }

    // Implementación de IImprimible
    void imprimir() const override {
        cout << "Contacto: " << nombre << " <" << email << ">" << endl;
    }
};

// Funciones que trabajan con interfaces específicas
void guardarDatos(const ISerializable& obj) {
    cout << "Datos serializados: " << obj.serializar() << endl;
}

void mostrarEnPantalla(const IImprimible& obj) {
    obj.imprimir();
}

int main() {
    Contacto original("Ana García", "ana@ejemplo.com");

    cout << "=== Objeto original ===" << endl;
    mostrarEnPantalla(original);
    guardarDatos(original);

    cout << "\n=== Clon del objeto ===" << endl;
    auto copia = original.clonar();
    // Necesitamos hacer cast porque clonar() devuelve ICloneable*
    if (auto* contactoCopia = dynamic_cast<Contacto*>(copia.get())) {
        mostrarEnPantalla(*contactoCopia);
    }

    cout << "\n=== Deserialización ===" << endl;
    Contacto nuevo;
    nuevo.deserializar("Carlos López|carlos@ejemplo.com");
    mostrarEnPantalla(nuevo);

    return 0;
}
<---Ejemplo de Interfaces en C++ Result--->
<---Ejemplo de QAbstractListModel Personalizado--->
```cpp
#include <QAbstractListModel>
#include <QStringList>
#include <QColor>

// Modelo personalizado para una lista de tareas
class ModeloTareas : public QAbstractListModel {
    Q_OBJECT

public:
    // Definir roles personalizados
    enum RolesTarea {
        RolTitulo = Qt::UserRole + 1,
        RolCompletada,
        RolPrioridad
    };

    struct Tarea {
        QString titulo;
        bool completada;
        int prioridad; // 1 = baja, 2 = media, 3 = alta
    };

    explicit ModeloTareas(QObject* parent = nullptr)
        : QAbstractListModel(parent) {}

    // === Funciones que DEBEMOS anular (obligatorias) ===

    // Devuelve la cantidad de filas en el modelo
    int rowCount(const QModelIndex& parent = QModelIndex()) const override {
        if (parent.isValid())
            return 0; // En un modelo de lista, los hijos no tienen filas
        return static_cast<int>(m_tareas.size());
    }

    // Devuelve los datos para un índice y rol específicos
    QVariant data(const QModelIndex& index, int role = Qt::DisplayRole) const override {
        if (!index.isValid() || index.row() < 0
            || index.row() >= static_cast<int>(m_tareas.size()))
            return {};

        const Tarea& tarea = m_tareas.at(index.row());

        switch (role) {
        case RolTitulo:
            return tarea.titulo;
        case RolCompletada:
            return tarea.completada;
        case RolPrioridad:
            return tarea.prioridad;
        case Qt::DisplayRole:
            return tarea.titulo;
        default:
            return {};
        }
    }

    // === Función opcional pero necesaria para QML ===

    // Define los nombres de roles para acceder desde QML
    QHash<int, QByteArray> roleNames() const override {
        QHash<int, QByteArray> roles;
        roles[RolTitulo] = "titulo";
        roles[RolCompletada] = "completada";
        roles[RolPrioridad] = "prioridad";
        return roles;
    }

    // === Funciones adicionales para manipular el modelo ===

    // Agregar una tarea
    Q_INVOKABLE void agregarTarea(const QString& titulo, int prioridad = 2) {
        beginInsertRows(QModelIndex(), rowCount(), rowCount());
        m_tareas.push_back({titulo, false, prioridad});
        endInsertRows();
    }

    // Marcar tarea como completada
    Q_INVOKABLE void completarTarea(int indice) {
        if (indice < 0 || indice >= static_cast<int>(m_tareas.size()))
            return;

        m_tareas[indice].completada = true;
        QModelIndex idx = index(indice);
        emit dataChanged(idx, idx, {RolCompletada});
    }

    // Eliminar una tarea
    Q_INVOKABLE void eliminarTarea(int indice) {
        if (indice < 0 || indice >= static_cast<int>(m_tareas.size()))
            return;

        beginRemoveRows(QModelIndex(), indice, indice);
        m_tareas.erase(m_tareas.begin() + indice);
        endRemoveRows();
    }

private:
    std::vector<Tarea> m_tareas;
};
<---Ejemplo de QAbstractListModel Personalizado Result--->
