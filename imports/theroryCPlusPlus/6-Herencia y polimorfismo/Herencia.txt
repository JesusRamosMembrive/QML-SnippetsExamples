<---EXPLANATION--->
### Herencia en C++

La herencia es uno de los pilares fundamentales de la programación orientada a objetos (POO). En C++, la herencia permite crear nuevas clases a partir de clases existentes, lo que facilita la reutilización del código y la creación de jerarquías de clases.

#### Definición de Herencia

La herencia es un mecanismo mediante el cual una clase (llamada clase derivada o subclase) puede heredar atributos y métodos de otra clase (llamada clase base o superclase). La clase derivada puede extender o modificar el comportamiento de la clase base.

- **Clase Base (Superclase):** La clase original que proporciona atributos y métodos a otras clases.
- **Clase Derivada (Subclase):** La nueva clase que hereda atributos y métodos de la clase base.

#### Ventajas de la Herencia

1. **Reutilización de Código:** La herencia permite reutilizar el código existente, lo que reduce la duplicación de código y facilita el mantenimiento.
2. **Extensibilidad:** Las clases derivadas pueden añadir nuevas funcionalidades o modificar las existentes sin cambiar el código de la clase base.
3. **Jerarquía y Organización:** La herencia permite organizar el código en jerarquías lógicas, facilitando la comprensión y gestión del mismo.
4. **Polimorfismo:** La herencia facilita el uso del polimorfismo, permitiendo que una misma interfaz se utilice para diferentes tipos de objetos.

#### Sintaxis Básica de la Herencia

La sintaxis básica para definir una clase derivada en C++ es la siguiente:

```cpp
class ClaseBase {
public:
    // Atributos y métodos de la clase base
};

class ClaseDerivada : public ClaseBase {
public:
    // Atributos y métodos adicionales de la clase derivada
};
```

- **`public`** indica que todos los miembros públicos de la clase base son accesibles como públicos en la clase derivada. Existen otros modos de herencia (`protected` y `private`), pero `public` es el más común.

##### Ejemplo Básico de Herencia

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
```

En este ejemplo:
- `Animal` es la clase base que define un método `comer`.
- `Perro` es la clase derivada que hereda de `Animal` y añade un método `ladrar`.

#### Tipos de Herencia

1. **Herencia Pública (`public`):** Los miembros públicos y protegidos de la clase base se convierten en públicos y protegidos en la clase derivada, respectivamente.
2. **Herencia Protegida (`protected`):** Los miembros públicos y protegidos de la clase base se convierten en protegidos en la clase derivada.
3. **Herencia Privada (`private`):** Los miembros públicos y protegidos de la clase base se convierten en privados en la clase derivada.

##### Ejemplo de Diferentes Modos de Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
```

En este ejemplo, se muestra cómo los diferentes modos de herencia afectan la accesibilidad de los miembros de la clase base en la clase derivada.

#### Herencia de Constructores con `using` (C++11)

A partir de C++11, es posible heredar los constructores de la clase base en la clase derivada utilizando la declaración `using Base::Base;`. Esto evita tener que reescribir constructores en la clase derivada cuando simplemente se desea reutilizar los de la clase base.

Sin la declaración `using`, la clase derivada necesitaría definir explícitamente constructores que deleguen al constructor de la clase base. Con `using Base::Base;`, todos los constructores de la clase base quedan disponibles automáticamente en la clase derivada.

##### Ejemplo de Herencia de Constructores con using

```cpp
#include <iostream>
#include <string>
using namespace std;

// Clase base: Vehiculo
class Vehiculo {
protected:
    string marca;
    int anio;

public:
    // Constructor con marca y año
    Vehiculo(const string& m, int a) : marca(m), anio(a) {
        cout << "Constructor Vehiculo(marca, anio)" << endl;
    }

    // Constructor solo con marca (año por defecto)
    Vehiculo(const string& m) : marca(m), anio(2024) {
        cout << "Constructor Vehiculo(marca)" << endl;
    }

    void mostrarInfo() const {
        cout << "Marca: " << marca << ", Año: " << anio << endl;
    }
};

// Clase derivada: Coche hereda constructores con using
class Coche : public Vehiculo {
public:
    // Heredar TODOS los constructores de Vehiculo
    using Vehiculo::Vehiculo;

    void conducir() const {
        cout << marca << " está en marcha." << endl;
    }
};

int main() {
    // Usa el constructor Vehiculo(marca, anio) heredado
    Coche c1("Toyota", 2023);
    c1.mostrarInfo();
    c1.conducir();

    cout << endl;

    // Usa el constructor Vehiculo(marca) heredado
    Coche c2("Honda");
    c2.mostrarInfo();
    c2.conducir();

    return 0;
}
```

En este ejemplo, `Coche` no define ningún constructor propio, pero gracias a `using Vehiculo::Vehiculo;` puede utilizar ambos constructores definidos en `Vehiculo`.

#### `final` en Clases (C++11)

C++11 introdujo el especificador `final` que, cuando se aplica a una clase, impide que otras clases hereden de ella. Esto es útil cuando se desea garantizar que una clase no sea extendida, ya sea por razones de diseño, seguridad o rendimiento (el compilador puede optimizar llamadas virtuales en clases `final`).

La sintaxis consiste en colocar `final` después del nombre de la clase (y después de la lista de herencia, si la hay):

```cpp
class MiClase final { /* ... */ };
class MiDerivada final : public Base { /* ... */ };
```

##### Ejemplo de final en Clases

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void saludar() const {
        cout << "Hola desde Base" << endl;
    }
};

// Segura hereda de Base y se marca como final
class Segura final : public Base {
public:
    void saludar() const override {
        cout << "Hola desde Segura (clase final)" << endl;
    }
};

// ERROR de compilación: no se puede heredar de una clase final
// class Intento : public Segura {
//     // Error: cannot derive from 'final' base 'Segura'
// };

int main() {
    Segura obj;
    obj.saludar();

    // Polimorfismo sigue funcionando normalmente
    Base* ptr = &obj;
    ptr->saludar();

    return 0;
}
```

En este ejemplo, `Segura` hereda de `Base` y se marca como `final`. Si se intenta crear una clase que herede de `Segura`, el compilador generará un error. Nótese que el polimorfismo sigue funcionando normalmente con punteros a la clase base.

#### Herencia en Qt: Modelo de Herencia Simple de QObject

En el framework Qt, la clase `QObject` es la clase base fundamental de la que derivan la mayoría de las clases del framework. Qt impone una restricción importante: **las clases que heredan de `QObject` solo admiten herencia simple**. Esto se debe al sistema de meta-objetos de Qt, que utiliza la macro `Q_OBJECT` para habilitar características como señales (signals), ranuras (slots) y propiedades dinámicas.

Además, Qt implementa un sistema de **relación padre-hijo**: cuando se establece un padre para un `QObject`, el padre se encarga de destruir a sus hijos cuando él mismo es destruido. Esto simplifica la gestión de memoria en aplicaciones Qt.

Reglas clave:
- Solo herencia simple desde `QObject` (no herencia múltiple de varias clases `QObject`).
- La macro `Q_OBJECT` debe aparecer en la sección `private` de la clase.
- El constructor típicamente recibe un puntero `QObject* parent = nullptr`.

##### Ejemplo de Herencia Simple de QObject

```cpp
#include <QObject>
#include <QDebug>

// Clase Motor que hereda de QObject
class Motor : public QObject {
    Q_OBJECT  // Macro obligatoria para señales y slots

public:
    // Constructor con puntero al padre (patrón Qt)
    explicit Motor(QObject* parent = nullptr)
        : QObject(parent), m_encendido(false), m_rpm(0)
    {
        qDebug() << "Motor creado";
    }

    // Destructor
    ~Motor() override {
        qDebug() << "Motor destruido";
    }

    // Método público para encender el motor
    void encender() {
        if (!m_encendido) {
            m_encendido = true;
            m_rpm = 800; // RPM en ralentí
            emit encendidoCambiado(true);
            emit rpmCambiadas(m_rpm);
            qDebug() << "Motor encendido a" << m_rpm << "RPM";
        }
    }

    // Método público para apagar el motor
    void apagar() {
        if (m_encendido) {
            m_encendido = false;
            m_rpm = 0;
            emit encendidoCambiado(false);
            emit rpmCambiadas(m_rpm);
            qDebug() << "Motor apagado";
        }
    }

    bool estaEncendido() const { return m_encendido; }
    int rpm() const { return m_rpm; }

signals:
    // Señales que notifican cambios de estado
    void encendidoCambiado(bool encendido);
    void rpmCambiadas(int nuevasRpm);

private:
    bool m_encendido;
    int m_rpm;
};

int main() {
    // El objeto 'app' es el padre de 'motor'
    QObject app;
    Motor* motor = new Motor(&app);
    // No es necesario hacer delete de motor,
    // se destruirá automáticamente cuando 'app' sea destruido

    motor->encender();
    qDebug() << "¿Encendido?" << motor->estaEncendido();

    motor->apagar();
    qDebug() << "¿Encendido?" << motor->estaEncendido();

    return 0;
    // Al salir del scope, 'app' se destruye y con ella 'motor'
}
```

En este ejemplo, `Motor` hereda de `QObject` usando herencia simple. La macro `Q_OBJECT` habilita el sistema de señales y slots. El constructor recibe un `QObject* parent` que establece la relación padre-hijo para la gestión automática de memoria.

### Conclusión

La herencia es una característica poderosa de la programación orientada a objetos que permite crear nuevas clases basadas en clases existentes. Ofrece numerosas ventajas, como la reutilización de código, la extensibilidad y el uso de polimorfismo. La sintaxis de herencia en C++ es sencilla y permite definir jerarquías claras y organizadas, facilitando el desarrollo y mantenimiento del software. Entender los diferentes modos de herencia y cómo afectan la accesibilidad de los miembros es crucial para aprovechar al máximo esta característica.
<---FILES--->
Ejemplo Básico de Herencia
Ejemplo Básico de Herencia Result
Ejemplo de Diferentes Modos de Herencia
Ejemplo de Diferentes Modos de Herencia Result
Ejemplo de Herencia de Constructores con using
Ejemplo de Herencia de Constructores con using Result
Ejemplo de final en Clases
Ejemplo de final en Clases Result
Ejemplo de Herencia Simple de QObject
Ejemplo de Herencia Simple de QObject Result
<---Ejemplo Básico de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void comer() {
        cout << "El animal está comiendo." << endl;
    }
};

class Perro : public Animal {
public:
    void ladrar() {
        cout << "El perro está ladrando." << endl;
    }
};

int main() {
    Perro miPerro;
    miPerro.comer(); // Método heredado de la clase base
    miPerro.ladrar(); // Método de la clase derivada

    return 0;
}
<---Ejemplo Básico de Herencia Result--->
<---Ejemplo de Diferentes Modos de Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class DerivadaPublic : public Base {
    // publicVar es public
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaProtected : protected Base {
    // publicVar es protected
    // protectedVar es protected
    // privateVar no es accesible
};

class DerivadaPrivate : private Base {
    // publicVar es private
    // protectedVar es private
    // privateVar no es accesible
};

int main() {
    DerivadaPublic objPublic;
    objPublic.publicVar = 10; // Accesible
    // objPublic.protectedVar = 20; // No accesible
    // objPublic.privateVar = 30; // No accesible

    DerivadaProtected objProtected;
    // objProtected.publicVar = 10; // No accesible
    // objProtected.protectedVar = 20; // No accesible

    DerivadaPrivate objPrivate;
    // objPrivate.publicVar = 10; // No accesible
    // objPrivate.protectedVar = 20; // No accesible

    return 0;
}
<---Ejemplo de Diferentes Modos de Herencia Result--->
<---Ejemplo de Herencia de Constructores con using--->
```cpp
#include <iostream>
#include <string>
using namespace std;

// Clase base: Vehiculo
class Vehiculo {
protected:
    string marca;
    int anio;

public:
    // Constructor con marca y año
    Vehiculo(const string& m, int a) : marca(m), anio(a) {
        cout << "Constructor Vehiculo(marca, anio)" << endl;
    }

    // Constructor solo con marca (año por defecto)
    Vehiculo(const string& m) : marca(m), anio(2024) {
        cout << "Constructor Vehiculo(marca)" << endl;
    }

    void mostrarInfo() const {
        cout << "Marca: " << marca << ", Año: " << anio << endl;
    }
};

// Clase derivada: Coche hereda constructores con using
class Coche : public Vehiculo {
public:
    // Heredar TODOS los constructores de Vehiculo
    using Vehiculo::Vehiculo;

    void conducir() const {
        cout << marca << " está en marcha." << endl;
    }
};

int main() {
    // Usa el constructor Vehiculo(marca, anio) heredado
    Coche c1("Toyota", 2023);
    c1.mostrarInfo();
    c1.conducir();

    cout << endl;

    // Usa el constructor Vehiculo(marca) heredado
    Coche c2("Honda");
    c2.mostrarInfo();
    c2.conducir();

    return 0;
}
<---Ejemplo de Herencia de Constructores con using Result--->
<---Ejemplo de final en Clases--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void saludar() const {
        cout << "Hola desde Base" << endl;
    }
};

// Segura hereda de Base y se marca como final
class Segura final : public Base {
public:
    void saludar() const override {
        cout << "Hola desde Segura (clase final)" << endl;
    }
};

// ERROR de compilación: no se puede heredar de una clase final
// class Intento : public Segura {
//     // Error: cannot derive from 'final' base 'Segura'
// };

int main() {
    Segura obj;
    obj.saludar();

    // Polimorfismo sigue funcionando normalmente
    Base* ptr = &obj;
    ptr->saludar();

    return 0;
}
<---Ejemplo de final en Clases Result--->
<---Ejemplo de Herencia Simple de QObject--->
```cpp
#include <QObject>
#include <QDebug>

// Clase Motor que hereda de QObject
class Motor : public QObject {
    Q_OBJECT  // Macro obligatoria para señales y slots

public:
    // Constructor con puntero al padre (patrón Qt)
    explicit Motor(QObject* parent = nullptr)
        : QObject(parent), m_encendido(false), m_rpm(0)
    {
        qDebug() << "Motor creado";
    }

    // Destructor
    ~Motor() override {
        qDebug() << "Motor destruido";
    }

    // Método público para encender el motor
    void encender() {
        if (!m_encendido) {
            m_encendido = true;
            m_rpm = 800; // RPM en ralentí
            emit encendidoCambiado(true);
            emit rpmCambiadas(m_rpm);
            qDebug() << "Motor encendido a" << m_rpm << "RPM";
        }
    }

    // Método público para apagar el motor
    void apagar() {
        if (m_encendido) {
            m_encendido = false;
            m_rpm = 0;
            emit encendidoCambiado(false);
            emit rpmCambiadas(m_rpm);
            qDebug() << "Motor apagado";
        }
    }

    bool estaEncendido() const { return m_encendido; }
    int rpm() const { return m_rpm; }

signals:
    // Señales que notifican cambios de estado
    void encendidoCambiado(bool encendido);
    void rpmCambiadas(int nuevasRpm);

private:
    bool m_encendido;
    int m_rpm;
};

int main() {
    // El objeto 'app' es el padre de 'motor'
    QObject app;
    Motor* motor = new Motor(&app);
    // No es necesario hacer delete de motor,
    // se destruirá automáticamente cuando 'app' sea destruido

    motor->encender();
    qDebug() << "¿Encendido?" << motor->estaEncendido();

    motor->apagar();
    qDebug() << "¿Encendido?" << motor->estaEncendido();

    return 0;
    // Al salir del scope, 'app' se destruye y con ella 'motor'
}
<---Ejemplo de Herencia Simple de QObject Result--->
