<---EXPLANATION--->
### Declaración de Namespace y Uso en C++

Los namespaces (espacios de nombres) son una característica fundamental de C++ que ayuda a organizar el código y evitar conflictos de nombres. Los namespaces permiten agrupar identificadores como funciones, variables y clases bajo un nombre de espacio de nombres específico, lo que facilita la gestión y la reutilización del código en proyectos grandes.

#### Declaración de un Namespace

La declaración de un namespace se realiza usando la palabra clave `namespace` seguida del nombre del namespace y un bloque de código que contiene las definiciones que pertenecen a ese namespace.

##### Sintaxis Básica

```cpp
namespace nombre_del_namespace {
    // Definiciones de variables, funciones, clases, etc.
}
```

##### Ejemplo de Declaración de Namespace

```cpp
namespace Matematicas {
    const double PI = 3.141592653589793;

    double cuadrado(double x) {
        return x * x;
    }

    double areaCirculo(double radio) {
        return PI * cuadrado(radio);
    }
}
```

En este ejemplo:
- `Matematicas` es el nombre del namespace.
- Dentro de `Matematicas`, se definen una constante `PI` y dos funciones `cuadrado` y `areaCirculo`.

#### Uso de un Namespace

Para usar las definiciones de un namespace, se puede:
1. **Usar el Operador de Resolución de Ámbito `::`:** Este operador se usa para acceder a los miembros de un namespace especificando el nombre del namespace seguido de `::` y el nombre del miembro.

##### Ejemplo

```cpp
#include <iostream>

namespace Matematicas {
    const double PI = 3.141592653589793;

    double cuadrado(double x) {
        return x * x;
    }

    double areaCirculo(double radio) {
        return PI * cuadrado(radio);
    }
}

int main() {
    double radio = 5.0;
    std::cout << "El área del círculo con radio " << radio << " es " << Matematicas::areaCirculo(radio) << std::endl;
    return 0;
}
```

En este ejemplo, `Matematicas::areaCirculo` se utiliza para acceder a la función `areaCirculo` dentro del namespace `Matematicas`.

2. **Directiva `using`:** La directiva `using` puede traer todos los miembros de un namespace al ámbito actual, evitando la necesidad de usar el operador de resolución de ámbito repetidamente.

##### Ejemplo

```cpp
#include <iostream>

namespace Matematicas {
    const double PI = 3.141592653589793;

    double cuadrado(double x) {
        return x * x;
    }

    double areaCirculo(double radio) {
        return PI * cuadrado(radio);
    }
}

using namespace Matematicas;

int main() {
    double radio = 5.0;
    std::cout << "El área del círculo con radio " << radio << " es " << areaCirculo(radio) << std::endl; // Sin usar Matematicas::
    return 0;
}
```

En este ejemplo, `using namespace Matematicas` trae todos los miembros de `Matematicas` al ámbito actual, por lo que `areaCirculo` se puede usar directamente.

3. **Declaración de Uso de Identificadores Específicos:** Se puede usar la declaración `using` para traer solo identificadores específicos de un namespace al ámbito actual.

##### Ejemplo

```cpp
#include <iostream>

namespace Matematicas {
    const double PI = 3.141592653589793;

    double cuadrado(double x) {
        return x * x;
    }

    double areaCirculo(double radio) {
        return PI * cuadrado(radio);
    }
}

using Matematicas::areaCirculo;

int main() {
    double radio = 5.0;
    std::cout << "El área del círculo con radio " << radio << " es " << areaCirculo(radio) << std::endl; // Solo areaCirculo
    return 0;
}
```

En este ejemplo, solo `areaCirculo` se trae al ámbito actual, mientras que otros miembros de `Matematicas` no se traen automáticamente.

#### Namespaces Anidados

Los namespaces pueden anidarse para organizar el código de manera más jerárquica y modular.

##### Ejemplo de Namespaces Anidados

```cpp
#include <iostream>

namespace Empresa {
    namespace Departamento {
        namespace Proyecto {
            void mostrarMensaje() {
                std::cout << "Mensaje del proyecto" << std::endl;
            }
        }
    }
}

int main() {
    Empresa::Departamento::Proyecto::mostrarMensaje();
    return 0;
}
```

En este ejemplo:
- `Empresa`, `Departamento` y `Proyecto` son namespaces anidados.
- `mostrarMensaje` se accede usando el operador de resolución de ámbito con todos los niveles del namespace.

#### Alias de Namespace

Los alias de namespace pueden simplificar el acceso a namespaces largos o anidados.

##### Ejemplo de Alias de Namespace

```cpp
#include <iostream>

namespace Empresa {
    namespace Departamento {
        namespace Proyecto {
            void mostrarMensaje() {
                std::cout << "Mensaje del proyecto" << std::endl;
            }
        }
    }
}

// Crear un alias para un namespace largo
namespace Proyecto = Empresa::Departamento::Proyecto;

int main() {
    Proyecto::mostrarMensaje(); // Usando el alias para llamar a la función
    return 0;
}
```

En este ejemplo, `Proyecto` es un alias para `Empresa::Departamento::Proyecto`, lo que simplifica la llamada a `mostrarMensaje`.

#### Namespaces Anónimos

Los namespaces anónimos se utilizan para definir miembros que deben tener alcance en el archivo (file scope) y no deben ser accesibles desde otros archivos, útil para evitar colisiones de nombres en programas grandes.

##### Ejemplo de Namespace Anónimo

```cpp
#include <iostream>

namespace {
    void funcionPrivada() {
        std::cout << "Función en el namespace anónimo" << std::endl;
    }
}

int main() {
    funcionPrivada(); // Llamada válida dentro del mismo archivo
    return 0;
}
```

En este ejemplo, `funcionPrivada` solo es accesible dentro del archivo donde se define, ya que está en un namespace anónimo.

#### `inline namespace` para Versionado de APIs (C++11)

A partir de C++11, se puede declarar un namespace como `inline`. Los miembros de un `inline namespace` se comportan como si también fueran miembros del namespace que lo contiene, es decir, se pueden acceder sin cualificación adicional. Esto es especialmente útil para el **versionado de APIs**: la versión actual se marca como `inline` (convirtiéndola en la predeterminada), mientras que las versiones anteriores permanecen accesibles mediante cualificación explícita.

##### Ejemplo de `inline namespace` para Versionado

```cpp
#include <iostream>
#include <string>

namespace Protocolo {
    // Versión anterior (legacy), accesible solo con cualificación explícita
    namespace v2 {
        std::string formatearMensaje(const std::string& msg) {
            return "[v2] " + msg;
        }
    }

    // Versión actual (inline), accesible directamente desde Protocolo::
    inline namespace v3 {
        std::string formatearMensaje(const std::string& msg) {
            return "[v3] " + msg;
        }

        std::string formatearConPrioridad(const std::string& msg, int prioridad) {
            return "[v3|P" + std::to_string(prioridad) + "] " + msg;
        }
    }
}

int main() {
    // Usa v3 automáticamente (es inline)
    std::cout << Protocolo::formatearMensaje("Hola") << std::endl;

    // Acceso explícito a v2 cuando se necesita compatibilidad
    std::cout << Protocolo::v2::formatearMensaje("Hola legacy") << std::endl;

    // Función exclusiva de v3, accesible directamente
    std::cout << Protocolo::formatearConPrioridad("Alerta", 1) << std::endl;

    return 0;
}
```

En este ejemplo:
- `Protocolo::v3` es `inline`, por lo que `Protocolo::formatearMensaje` resuelve automáticamente a la versión v3.
- `Protocolo::v2::formatearMensaje` sigue accesible para código que necesite compatibilidad con la versión anterior.
- Cuando se lance una v4, bastará con mover `inline` a `namespace v4` y los usuarios obtendrán la nueva versión sin cambiar su código.

#### Reapertura de Namespaces

Los namespaces en C++ pueden **reabrirse** en múltiples lugares: diferentes partes del mismo archivo, en archivos distintos, o en diferentes unidades de traducción. Cada reapertura agrega nuevas declaraciones al mismo namespace existente. Así es como funciona la Biblioteca Estándar: `<vector>` agrega `std::vector`, `<string>` agrega `std::string`, `<algorithm>` agrega `std::sort`, etc., todos contribuyendo al mismo namespace `std`.

##### Ejemplo de Reapertura de Namespaces

```cpp
#include <iostream>
#include <cmath>

// Primera apertura: funciones de texto
namespace Utilidades {
    std::string repetir(const std::string& texto, int veces) {
        std::string resultado;
        for (int i = 0; i < veces; ++i) {
            resultado += texto;
        }
        return resultado;
    }

    std::string enMayusculas(const std::string& texto) {
        std::string resultado = texto;
        for (char& c : resultado) {
            c = std::toupper(c);
        }
        return resultado;
    }
}

// Segunda apertura: funciones matemáticas (mismo namespace)
namespace Utilidades {
    double hipotenusa(double a, double b) {
        return std::sqrt(a * a + b * b);
    }

    int factorial(int n) {
        return (n <= 1) ? 1 : n * factorial(n - 1);
    }
}

int main() {
    // Ambas aperturas contribuyen al mismo namespace
    std::cout << Utilidades::repetir("Hola ", 3) << std::endl;
    std::cout << Utilidades::enMayusculas("mundo") << std::endl;
    std::cout << "Hipotenusa(3,4): " << Utilidades::hipotenusa(3, 4) << std::endl;
    std::cout << "Factorial(5): " << Utilidades::factorial(5) << std::endl;

    return 0;
}
```

En este ejemplo:
- El namespace `Utilidades` se abre dos veces en el mismo archivo, cada vez agregando funciones distintas.
- En un proyecto real, estas aperturas podrían estar en archivos diferentes (`utilidades_texto.cpp` y `utilidades_math.cpp`), y todas las funciones seguirían perteneciendo al mismo namespace `Utilidades`.
- Esto permite organizar el código de forma modular sin que cada módulo necesite conocer las demás contribuciones al namespace.

### Conclusión

Los namespaces en C++ son esenciales para organizar el código y evitar conflictos de nombres en proyectos grandes. Permiten agrupar definiciones relacionadas, mejorar la modularidad y la claridad del código, y facilitar la integración de múltiples librerías. Comprender cómo declarar y utilizar namespaces de manera efectiva es crucial para escribir código C++ bien estructurado y mantenible.
<---FILES--->
Sintaxis Básica
Sintaxis Básica Result
Ejemplo de Declaración de Namespace
Ejemplo de Declaración de Namespace Result
Ejemplo
Ejemplo Result
Ejemplo de Namespaces Anidados
Ejemplo de Namespaces Anidados Result
Ejemplo de Alias de Namespace
Ejemplo de Alias de Namespace Result
Ejemplo de Namespace Anónimo
Ejemplo de Namespace Anónimo Result
Ejemplo de `inline namespace` para Versionado
Ejemplo de `inline namespace` para Versionado Result
Ejemplo de Reapertura de Namespaces
Ejemplo de Reapertura de Namespaces Result
<---Sintaxis Básica--->
```cpp
namespace nombre_del_namespace {
    // Definiciones de variables, funciones, clases, etc.
}
<---Sintaxis Básica Result--->
<---Ejemplo de Declaración de Namespace--->
```cpp
namespace Matematicas {
    const double PI = 3.141592653589793;

    double cuadrado(double x) {
        return x * x;
    }

    double areaCirculo(double radio) {
        return PI * cuadrado(radio);
    }
}
<---Ejemplo de Declaración de Namespace Result--->
<---Ejemplo--->
```cpp
#include <iostream>

namespace Matematicas {
    const double PI = 3.141592653589793;

    double cuadrado(double x) {
        return x * x;
    }

    double areaCirculo(double radio) {
        return PI * cuadrado(radio);
    }
}

using Matematicas::areaCirculo;

int main() {
    double radio = 5.0;
    std::cout << "El área del círculo con radio " << radio << " es " << areaCirculo(radio) << std::endl; // Solo areaCirculo
    return 0;
}
<---Ejemplo Result--->
<---Ejemplo de Namespaces Anidados--->
```cpp
#include <iostream>

namespace Empresa {
    namespace Departamento {
        namespace Proyecto {
            void mostrarMensaje() {
                std::cout << "Mensaje del proyecto" << std::endl;
            }
        }
    }
}

int main() {
    Empresa::Departamento::Proyecto::mostrarMensaje();
    return 0;
}
<---Ejemplo de Namespaces Anidados Result--->
<---Ejemplo de Alias de Namespace--->
```cpp
#include <iostream>

namespace Empresa {
    namespace Departamento {
        namespace Proyecto {
            void mostrarMensaje() {
                std::cout << "Mensaje del proyecto" << std::endl;
            }
        }
    }
}

// Crear un alias para un namespace largo
namespace Proyecto = Empresa::Departamento::Proyecto;

int main() {
    Proyecto::mostrarMensaje(); // Usando el alias para llamar a la función
    return 0;
}
<---Ejemplo de Alias de Namespace Result--->
<---Ejemplo de Namespace Anónimo--->
```cpp
#include <iostream>

namespace {
    void funcionPrivada() {
        std::cout << "Función en el namespace anónimo" << std::endl;
    }
}

int main() {
    funcionPrivada(); // Llamada válida dentro del mismo archivo
    return 0;
}
<---Ejemplo de Namespace Anónimo Result--->
<---Ejemplo de `inline namespace` para Versionado--->
```cpp
#include <iostream>
#include <string>

namespace Protocolo {
    // Versión anterior (legacy), accesible solo con cualificación explícita
    namespace v2 {
        std::string formatearMensaje(const std::string& msg) {
            return "[v2] " + msg;
        }
    }

    // Versión actual (inline), accesible directamente desde Protocolo::
    inline namespace v3 {
        std::string formatearMensaje(const std::string& msg) {
            return "[v3] " + msg;
        }

        std::string formatearConPrioridad(const std::string& msg, int prioridad) {
            return "[v3|P" + std::to_string(prioridad) + "] " + msg;
        }
    }
}

int main() {
    // Usa v3 automáticamente (es inline)
    std::cout << Protocolo::formatearMensaje("Hola") << std::endl;

    // Acceso explícito a v2 cuando se necesita compatibilidad
    std::cout << Protocolo::v2::formatearMensaje("Hola legacy") << std::endl;

    // Función exclusiva de v3, accesible directamente
    std::cout << Protocolo::formatearConPrioridad("Alerta", 1) << std::endl;

    return 0;
}
<---Ejemplo de `inline namespace` para Versionado Result--->
<---Ejemplo de Reapertura de Namespaces--->
```cpp
#include <iostream>
#include <cmath>

// Primera apertura: funciones de texto
namespace Utilidades {
    std::string repetir(const std::string& texto, int veces) {
        std::string resultado;
        for (int i = 0; i < veces; ++i) {
            resultado += texto;
        }
        return resultado;
    }

    std::string enMayusculas(const std::string& texto) {
        std::string resultado = texto;
        for (char& c : resultado) {
            c = std::toupper(c);
        }
        return resultado;
    }
}

// Segunda apertura: funciones matemáticas (mismo namespace)
namespace Utilidades {
    double hipotenusa(double a, double b) {
        return std::sqrt(a * a + b * b);
    }

    int factorial(int n) {
        return (n <= 1) ? 1 : n * factorial(n - 1);
    }
}

int main() {
    // Ambas aperturas contribuyen al mismo namespace
    std::cout << Utilidades::repetir("Hola ", 3) << std::endl;
    std::cout << Utilidades::enMayusculas("mundo") << std::endl;
    std::cout << "Hipotenusa(3,4): " << Utilidades::hipotenusa(3, 4) << std::endl;
    std::cout << "Factorial(5): " << Utilidades::factorial(5) << std::endl;

    return 0;
}
<---Ejemplo de Reapertura de Namespaces Result--->
