<---EXPLANATION--->
### Namespaces Anidados en C++

Los namespaces (espacios de nombres) anidados en C++ permiten organizar el código de manera jerárquica y modular. Utilizando namespaces anidados, se puede crear una estructura clara y coherente para los nombres de clases, funciones, y otras entidades, evitando conflictos de nombres y mejorando la legibilidad del código.

#### Definición de Namespaces Anidados

Un namespace anidado es simplemente un namespace que se declara dentro de otro namespace. Esto crea una jerarquía de namespaces que pueden contener definiciones más específicas dentro de un contexto más general.

##### Sintaxis de Namespaces Anidados

```cpp
namespace NamespacePadre {
    namespace NamespaceHijo {
        // Definiciones de variables, funciones, clases, etc.
    }
}
```

##### Ejemplo de Namespaces Anidados

```cpp
#include <iostream>

namespace Empresa {
    namespace Departamento {
        namespace Proyecto {
            void mostrarMensaje() {
                std::cout << "Mensaje del proyecto" << std::endl;
            }
        }
    }
}

int main() {
    Empresa::Departamento::Proyecto::mostrarMensaje();
    return 0;
}
```

En este ejemplo:
- `Empresa` es el namespace padre.
- `Departamento` es un namespace anidado dentro de `Empresa`.
- `Proyecto` es un namespace anidado dentro de `Departamento`.
- La función `mostrarMensaje` se define dentro de `Proyecto` y se accede usando el operador de resolución de ámbito `::` con todos los niveles del namespace.

#### Ventajas de Usar Namespaces Anidados

1. **Organización Jerárquica:** Facilitan la organización jerárquica del código, lo que es especialmente útil en proyectos grandes.
2. **Evitar Conflictos de Nombres:** Ayudan a evitar conflictos de nombres al agrupar definiciones relacionadas bajo nombres de espacios de nombres específicos.
3. **Modularidad:** Permiten definir módulos y submódulos de manera clara y estructurada.
4. **Claridad:** Mejoran la claridad del código al dejar claro a qué contexto pertenece cada definición.

#### Alias para Namespaces Anidados

Para simplificar el uso de namespaces anidados largos, se pueden crear alias.

##### Ejemplo de Alias para Namespaces Anidados

```cpp
#include <iostream>

namespace Empresa {
    namespace Departamento {
        namespace Proyecto {
            void mostrarMensaje() {
                std::cout << "Mensaje del proyecto" << std::endl;
            }
        }
    }
}

// Crear un alias para un namespace anidado largo
namespace ProyectoAlias = Empresa::Departamento::Proyecto;

int main() {
    ProyectoAlias::mostrarMensaje(); // Usando el alias para llamar a la función
    return 0;
}
```

En este ejemplo, `ProyectoAlias` es un alias para `Empresa::Departamento::Proyecto`, lo que simplifica la llamada a `mostrarMensaje`.

#### Usando `using` con Namespaces Anidados

La directiva `using` puede simplificar el acceso a los miembros de namespaces anidados.

##### Ejemplo con `using`

```cpp
#include <iostream>

namespace Empresa {
    namespace Departamento {
        namespace Proyecto {
            void mostrarMensaje() {
                std::cout << "Mensaje del proyecto" << std::endl;
            }
        }
    }
}

using namespace Empresa::Departamento::Proyecto;

int main() {
    mostrarMensaje(); // Llamada directa sin necesidad de prefijo
    return 0;
}
```

En este ejemplo, `using namespace Empresa::Departamento::Proyecto` trae todos los miembros de `Proyecto` al ámbito actual, permitiendo el uso directo de `mostrarMensaje`.

#### Namespaces Anónimos en Contexto Anidado

Los namespaces anónimos se utilizan para definir miembros que deben tener un alcance de archivo (file scope) y no deben ser accesibles desde otros archivos, evitando conflictos de nombres.

##### Ejemplo de Namespaces Anónimos Anidados

```cpp
#include <iostream>

namespace Empresa {
    namespace Departamento {
        namespace {
            void funcionPrivada() {
                std::cout << "Función en el namespace anónimo dentro de Proyecto" << std::endl;
            }
        }
    }
}

int main() {
    Empresa::Departamento::funcionPrivada(); // Llamada válida dentro del mismo archivo
    return 0;
}
```

En este ejemplo:
- `funcionPrivada` está en un namespace anónimo dentro de `Departamento`, y solo es accesible dentro del archivo en el que se define.

#### Sintaxis Compacta de C++17 para Namespaces Anidados

Antes de C++17, declarar namespaces anidados requería abrir y cerrar cada nivel con bloques separados, lo que producía código verboso y con mucha indentación. C++17 introdujo una **sintaxis compacta** que permite declarar namespaces anidados en una sola línea usando el operador `::`.

##### Comparación de Sintaxis

**Antes de C++17 (sintaxis clásica):**
```cpp
namespace Empresa {
    namespace Producto {
        namespace Utilidades {
            // definiciones...
        }
    }
}
```

**C++17 (sintaxis compacta):**
```cpp
namespace Empresa::Producto::Utilidades {
    // definiciones...
}
```

Ambas formas son equivalentes, pero la sintaxis compacta es más limpia y reduce la indentación innecesaria.

##### Ejemplo de Sintaxis Compacta C++17

```cpp
#include <iostream>
#include <string>

// Sintaxis compacta de C++17 para namespaces anidados
namespace Empresa::Producto::Utilidades {
    std::string formatearNombre(const std::string& nombre, const std::string& apellido) {
        return apellido + ", " + nombre;
    }

    void mostrarVersion() {
        std::cout << "Utilidades v3.2.1" << std::endl;
    }
}

// Se puede seguir añadiendo al mismo namespace en otro bloque
namespace Empresa::Producto {
    void iniciar() {
        std::cout << "Producto iniciado" << std::endl;
        std::cout << "Nombre formateado: "
                  << Utilidades::formatearNombre("Carlos", "García") << std::endl;
    }
}

int main() {
    Empresa::Producto::iniciar();
    Empresa::Producto::Utilidades::mostrarVersion();
    return 0;
}
```

En este ejemplo:
- `namespace Empresa::Producto::Utilidades` declara tres niveles de namespaces en una sola línea.
- Se puede seguir añadiendo contenido al mismo namespace o a niveles intermedios en bloques separados.
- El acceso a los miembros sigue usando el operador `::` como siempre.

#### `inline namespace` Anidado para Versionado (C++17/20)

C++20 extendió la sintaxis compacta de C++17 para permitir declarar **inline namespaces anidados** directamente en la declaración compacta. Esto se hace con `namespace A::B::inline C { }`. Esta característica es muy útil para implementar versionado de APIs en bibliotecas que usan namespaces anidados.

Con esta sintaxis, los miembros del namespace `inline` son accesibles como si pertenecieran al namespace padre, lo que permite establecer una versión predeterminada de la API mientras se mantienen versiones anteriores accesibles.

##### Ejemplo de inline namespace Anidado

```cpp
#include <iostream>

// C++20: inline en la declaración compacta
namespace MiLib::inline v2 {
    void procesar() {
        std::cout << "MiLib v2: Procesamiento optimizado con multihilo" << std::endl;
    }

    int calcular(int a, int b) {
        return a * b + a; // Algoritmo mejorado en v2
    }
}

// Versión anterior disponible explícitamente
namespace MiLib::v1 {
    void procesar() {
        std::cout << "MiLib v1: Procesamiento secuencial básico" << std::endl;
    }

    int calcular(int a, int b) {
        return a + b; // Algoritmo simple en v1
    }
}

int main() {
    // Usa v2 automáticamente (es el inline namespace)
    MiLib::procesar();
    std::cout << "Resultado v2: " << MiLib::calcular(5, 3) << std::endl;

    // Se puede acceder explícitamente a v1
    MiLib::v1::procesar();
    std::cout << "Resultado v1: " << MiLib::v1::calcular(5, 3) << std::endl;

    // Y también se puede acceder explícitamente a v2
    MiLib::v2::procesar();

    return 0;
}
```

En este ejemplo:
- `namespace MiLib::inline v2` declara `v2` como el namespace inline dentro de `MiLib`, por lo que `MiLib::procesar()` llama a la versión v2.
- `namespace MiLib::v1` define la versión anterior, accesible solo con calificación completa `MiLib::v1::procesar()`.
- Cuando se actualice la biblioteca a v3, solo se necesita cambiar `inline` de `v2` a `v3` y agregar el nuevo namespace.
- En C++17, la sintaxis `namespace A::inline B` no está soportada; se requiere la forma expandida con bloques anidados. Esta forma compacta es exclusiva de C++20.

### Conclusión

Los namespaces anidados en C++ son una herramienta poderosa para organizar y modularizar el código en proyectos grandes. Permiten crear una estructura jerárquica clara, evitando conflictos de nombres y mejorando la legibilidad del código. El uso de alias y la directiva `using` puede simplificar el acceso a miembros de namespaces anidados, haciendo el código más manejable y fácil de entender. Comprender y utilizar namespaces anidados de manera efectiva es crucial para escribir código C++ bien estructurado y mantenible.
<---FILES--->
Sintaxis de Namespaces Anidados
Sintaxis de Namespaces Anidados Result
Ejemplo de Namespaces Anidados
Ejemplo de Namespaces Anidados Result
Ejemplo de Alias para Namespaces Anidados
Ejemplo de Alias para Namespaces Anidados Result
Ejemplo con `using`
Ejemplo con `using` Result
Ejemplo de Namespaces Anónimos Anidados
Ejemplo de Namespaces Anónimos Anidados Result
Ejemplo de Sintaxis Compacta C++17
Ejemplo de Sintaxis Compacta C++17 Result
Ejemplo de inline namespace Anidado
Ejemplo de inline namespace Anidado Result
<---Sintaxis de Namespaces Anidados--->
```cpp
namespace NamespacePadre {
    namespace NamespaceHijo {
        // Definiciones de variables, funciones, clases, etc.
    }
}
<---Sintaxis de Namespaces Anidados Result--->
<---Ejemplo de Namespaces Anidados--->
```cpp
#include <iostream>

namespace Empresa {
    namespace Departamento {
        namespace Proyecto {
            void mostrarMensaje() {
                std::cout << "Mensaje del proyecto" << std::endl;
            }
        }
    }
}

int main() {
    Empresa::Departamento::Proyecto::mostrarMensaje();
    return 0;
}
<---Ejemplo de Namespaces Anidados Result--->
<---Ejemplo de Alias para Namespaces Anidados--->
```cpp
#include <iostream>

namespace Empresa {
    namespace Departamento {
        namespace Proyecto {
            void mostrarMensaje() {
                std::cout << "Mensaje del proyecto" << std::endl;
            }
        }
    }
}

// Crear un alias para un namespace anidado largo
namespace ProyectoAlias = Empresa::Departamento::Proyecto;

int main() {
    ProyectoAlias::mostrarMensaje(); // Usando el alias para llamar a la función
    return 0;
}
<---Ejemplo de Alias para Namespaces Anidados Result--->
<---Ejemplo con `using`--->
```cpp
#include <iostream>

namespace Empresa {
    namespace Departamento {
        namespace Proyecto {
            void mostrarMensaje() {
                std::cout << "Mensaje del proyecto" << std::endl;
            }
        }
    }
}

using namespace Empresa::Departamento::Proyecto;

int main() {
    mostrarMensaje(); // Llamada directa sin necesidad de prefijo
    return 0;
}
<---Ejemplo con `using` Result--->
<---Ejemplo de Namespaces Anónimos Anidados--->
```cpp
#include <iostream>

namespace Empresa {
    namespace Departamento {
        namespace {
            void funcionPrivada() {
                std::cout << "Función en el namespace anónimo dentro de Proyecto" << std::endl;
            }
        }
    }
}

int main() {
    Empresa::Departamento::funcionPrivada(); // Llamada válida dentro del mismo archivo
    return 0;
}
<---Ejemplo de Namespaces Anónimos Anidados Result--->
<---Ejemplo de Sintaxis Compacta C++17--->
```cpp
#include <iostream>
#include <string>

// Sintaxis compacta de C++17 para namespaces anidados
namespace Empresa::Producto::Utilidades {
    std::string formatearNombre(const std::string& nombre, const std::string& apellido) {
        return apellido + ", " + nombre;
    }

    void mostrarVersion() {
        std::cout << "Utilidades v3.2.1" << std::endl;
    }
}

// Se puede seguir añadiendo al mismo namespace en otro bloque
namespace Empresa::Producto {
    void iniciar() {
        std::cout << "Producto iniciado" << std::endl;
        std::cout << "Nombre formateado: "
                  << Utilidades::formatearNombre("Carlos", "García") << std::endl;
    }
}

int main() {
    Empresa::Producto::iniciar();
    Empresa::Producto::Utilidades::mostrarVersion();
    return 0;
}
<---Ejemplo de Sintaxis Compacta C++17 Result--->
<---Ejemplo de inline namespace Anidado--->
```cpp
#include <iostream>

// C++20: inline en la declaración compacta
namespace MiLib::inline v2 {
    void procesar() {
        std::cout << "MiLib v2: Procesamiento optimizado con multihilo" << std::endl;
    }

    int calcular(int a, int b) {
        return a * b + a; // Algoritmo mejorado en v2
    }
}

// Versión anterior disponible explícitamente
namespace MiLib::v1 {
    void procesar() {
        std::cout << "MiLib v1: Procesamiento secuencial básico" << std::endl;
    }

    int calcular(int a, int b) {
        return a + b; // Algoritmo simple en v1
    }
}

int main() {
    // Usa v2 automáticamente (es el inline namespace)
    MiLib::procesar();
    std::cout << "Resultado v2: " << MiLib::calcular(5, 3) << std::endl;

    // Se puede acceder explícitamente a v1
    MiLib::v1::procesar();
    std::cout << "Resultado v1: " << MiLib::v1::calcular(5, 3) << std::endl;

    // Y también se puede acceder explícitamente a v2
    MiLib::v2::procesar();

    return 0;
}
<---Ejemplo de inline namespace Anidado Result--->
