<---EXPLANATION--->
### Punteros Inteligentes en C++

Los punteros inteligentes en C++ son una característica introducida en C++11 que ayuda a gestionar la memoria automáticamente y prevenir fugas de memoria y errores comunes como los punteros colgantes. Los punteros inteligentes son clases de la biblioteca estándar que administran la vida útil de los objetos a los que apuntan. Los tres tipos principales de punteros inteligentes son `std::unique_ptr`, `std::shared_ptr` y `std::weak_ptr`.

#### `std::unique_ptr`

Un `std::unique_ptr` es un puntero inteligente que posee de manera exclusiva la memoria a la que apunta. No puede haber dos `std::unique_ptr` que posean el mismo recurso simultáneamente.

##### Características:
- Exclusividad: No puede haber copias de un `std::unique_ptr`.
- Liberación automática: La memoria se libera automáticamente cuando el `std::unique_ptr` sale de su ámbito.

##### Ejemplo de Uso de `std::unique_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Asignación de memoria
    std::cout << *ptr << std::endl; // Salida: 10

    // ptr2 = ptr; // Error: no se permite la copia de std::unique_ptr

    std::unique_ptr<int> ptr2 = std::move(ptr); // Transferencia de propiedad
    std::cout << *ptr2 << std::endl; // Salida: 10

    // La memoria se libera automáticamente al salir de ámbito
    return 0;
}
```

#### `std::shared_ptr`

Un `std::shared_ptr` permite compartir la propiedad de la memoria con múltiples punteros. La memoria se libera cuando el último `std::shared_ptr` que posee la memoria se destruye.

##### Características:
- Compartición: Múltiples `std::shared_ptr` pueden apuntar al mismo recurso.
- Contador de referencias: Lleva un conteo de cuántos `std::shared_ptr` están apuntando al recurso.

##### Ejemplo de Uso de `std::shared_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // Asignación de memoria
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // La memoria se libera automáticamente cuando el último shared_ptr se destruye
    return 0;
}
```

#### `std::weak_ptr`

Un `std::weak_ptr` es un puntero inteligente no propietario que se utiliza junto con `std::shared_ptr` para evitar ciclos de referencia. No afecta el conteo de referencias del `std::shared_ptr`.

##### Características:
- No propietario: No incrementa el contador de referencias.
- Utilizado para evitar ciclos de referencia: Permite la comprobación segura de si el recurso aún existe.

##### Ejemplo de Uso de `std::weak_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr; // No incrementa el contador de referencias

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) { // Comprobar si el recurso aún existe
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```

### Buenas Prácticas con Punteros Inteligentes

#### 1. Preferir `std::unique_ptr` por Defecto

Utilice `std::unique_ptr` cuando no necesite compartir la propiedad del recurso. Esto asegura que la propiedad sea clara y evita problemas de gestión de memoria.

```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```

#### 2. Usar `std::shared_ptr` para Propiedad Compartida

Utilice `std::shared_ptr` cuando necesite compartir la propiedad del recurso entre múltiples partes del código.

```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
std::shared_ptr<int> ptr2 = ptr1;
```

#### 3. Evitar Ciclos de Referencia con `std::weak_ptr`

Utilice `std::weak_ptr` junto con `std::shared_ptr` para evitar ciclos de referencia que pueden causar fugas de memoria.

```cpp
class Nodo {
public:
    std::shared_ptr<Nodo> siguiente;
    std::weak_ptr<Nodo> anterior; // Evitar ciclo de referencia
};
```

#### 4. Evitar el Uso de Punteros Crudos

Prefiera los punteros inteligentes sobre los punteros crudos para gestionar automáticamente la vida útil de los recursos y evitar errores comunes.

### Características Modernas de Punteros Inteligentes

#### Custom Deleters

Los punteros inteligentes permiten deleters personalizados para gestionar recursos no-memoria (archivos, sockets, handles del SO).

```cpp
#include <iostream>
#include <memory>
#include <cstdio>

int main() {
    // Custom deleter con lambda para FILE*
    auto fileDeleter = [](FILE* f) {
        if (f) {
            std::cout << "Cerrando archivo" << std::endl;
            std::fclose(f);
        }
    };

    {
        std::unique_ptr<FILE, decltype(fileDeleter)> archivo(
            std::fopen("test.txt", "w"), fileDeleter
        );
        if (archivo) {
            std::fputs("Hola desde unique_ptr con deleter", archivo.get());
        }
    } // Archivo se cierra automáticamente

    // Custom deleter con shared_ptr (más simple — no necesita tipo)
    {
        std::shared_ptr<FILE> archivo(
            std::fopen("test2.txt", "w"),
            [](FILE* f) { if (f) std::fclose(f); }
        );
    }

    std::cout << "Todos los archivos cerrados" << std::endl;
    return 0;
}
```

#### `std::make_unique` y `std::make_shared` — Preferir Siempre

```cpp
#include <iostream>
#include <memory>

class Punto {
public:
    Punto(double x, double y) : x_(x), y_(y) {}
    void mostrar() const {
        std::cout << "(" << x_ << ", " << y_ << ")" << std::endl;
    }
private:
    double x_, y_;
};

int main() {
    // PREFERIR: make_unique/make_shared (una sola asignación, exception-safe)
    auto p1 = std::make_unique<Punto>(3.0, 4.0);
    auto p2 = std::make_shared<Punto>(1.0, 2.0);

    // EVITAR: new directo (dos asignaciones para shared_ptr, no exception-safe)
    // std::shared_ptr<Punto> p3(new Punto(5.0, 6.0));

    p1->mostrar(); // Salida: (3, 4)
    p2->mostrar(); // Salida: (1, 2)

    // make_unique con arreglos
    auto arr = std::make_unique<int[]>(10);
    for (int i = 0; i < 10; ++i) arr[i] = i;

    return 0;
}
```

#### Equivalentes en Qt: Punteros Inteligentes Qt

```cpp
#include <QScopedPointer>
#include <QSharedPointer>
#include <QWeakPointer>
#include <QPointer>
#include <QObject>
#include <QDebug>

class Motor : public QObject {
    Q_OBJECT
public:
    explicit Motor(QObject* parent = nullptr) : QObject(parent) {}
    void arrancar() { qDebug() << "Motor arrancado"; }
};

void punterosQt() {
    // QScopedPointer ≈ std::unique_ptr (propiedad exclusiva)
    {
        QScopedPointer<int> ptr(new int(42));
        qDebug() << "QScopedPointer:" << *ptr;
    } // Se libera aquí

    // QSharedPointer ≈ std::shared_ptr (propiedad compartida)
    {
        QSharedPointer<int> p1 = QSharedPointer<int>::create(100);
        QSharedPointer<int> p2 = p1;
        qDebug() << "QSharedPointer:" << *p1 << "refs:" << p1.toStrongRef().data();
    }

    // QWeakPointer ≈ std::weak_ptr (observador de QSharedPointer)
    {
        QSharedPointer<int> fuerte = QSharedPointer<int>::create(99);
        QWeakPointer<int> debil = fuerte;
        if (auto ptr = debil.toStrongRef()) {
            qDebug() << "Recurso vivo:" << *ptr;
        }
    }

    // QPointer — exclusivo de Qt, para QObject*
    {
        auto* motor = new Motor();
        QPointer<Motor> ptrSeguro = motor;
        motor->arrancar();
        delete motor;
        qDebug() << "¿Motor existe?" << !ptrSeguro.isNull(); // false
    }
}
```

### Conclusión

Los punteros inteligentes en C++ proporcionan una forma segura y eficiente de gestionar la memoria dinámica. Al utilizar `std::unique_ptr`, `std::shared_ptr` y `std::weak_ptr`, los desarrolladores pueden prevenir fugas de memoria y errores de acceso a memoria, mejorando la robustez y mantenibilidad del código. Siguiendo buenas prácticas y eligiendo el tipo de puntero inteligente adecuado para cada situación, se puede aprovechar al máximo esta poderosa característica del lenguaje.
<---FILES--->
Características:
Características: Result
Ejemplo de Uso de `std::unique_ptr`
Ejemplo de Uso de `std::unique_ptr` Result
Ejemplo de Uso de `std::shared_ptr`
Ejemplo de Uso de `std::shared_ptr` Result
Ejemplo de Uso de `std::weak_ptr`
Ejemplo de Uso de `std::weak_ptr` Result
<---Características:--->
<---Características: Result--->
<---Ejemplo de Uso de `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Asignación de memoria
    std::cout << *ptr << std::endl; // Salida: 10

    // ptr2 = ptr; // Error: no se permite la copia de std::unique_ptr

    std::unique_ptr<int> ptr2 = std::move(ptr); // Transferencia de propiedad
    std::cout << *ptr2 << std::endl; // Salida: 10

    // La memoria se libera automáticamente al salir de ámbito
    return 0;
}
<---Ejemplo de Uso de `std::unique_ptr` Result--->
<---Ejemplo de Uso de `std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(20); // Asignación de memoria
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad

    std::cout << *ptr1 << std::endl; // Salida: 20
    std::cout << *ptr2 << std::endl; // Salida: 20
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // La memoria se libera automáticamente cuando el último shared_ptr se destruye
    return 0;
}
<---Ejemplo de Uso de `std::shared_ptr` Result--->
<---Ejemplo de Uso de `std::weak_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> sptr = std::make_shared<int>(30);
    std::weak_ptr<int> wptr = sptr; // No incrementa el contador de referencias

    std::cout << "Use count: " << sptr.use_count() << std::endl; // Salida: 1

    if (auto spt = wptr.lock()) { // Comprobar si el recurso aún existe
        std::cout << *spt << std::endl; // Salida: 30
    } else {
        std::cout << "wptr is expired" << std::endl;
    }

    return 0;
}
```cpp
std::unique_ptr<int> ptr = std::make_unique<int>(10);
```cpp
std::shared_ptr<int> ptr1 = std::make_shared<int>(20);
std::shared_ptr<int> ptr2 = ptr1;
```cpp
class Nodo {
public:
    std::shared_ptr<Nodo> siguiente;
    std::weak_ptr<Nodo> anterior; // Evitar ciclo de referencia
};
<---Ejemplo de Uso de `std::weak_ptr` Result--->
Custom Deleters
Custom Deleters Result
make_unique y make_shared
make_unique y make_shared Result
Punteros Inteligentes en Qt
Punteros Inteligentes en Qt Result
<---Custom Deleters--->
```cpp
#include <iostream>
#include <memory>
#include <cstdio>

int main() {
    auto fileDeleter = [](FILE* f) {
        if (f) {
            std::cout << "Cerrando archivo" << std::endl;
            std::fclose(f);
        }
    };

    {
        std::unique_ptr<FILE, decltype(fileDeleter)> archivo(
            std::fopen("test.txt", "w"), fileDeleter
        );
        if (archivo) {
            std::fputs("Hola desde unique_ptr con deleter", archivo.get());
        }
    } // Archivo cerrado automáticamente

    {
        std::shared_ptr<FILE> archivo(
            std::fopen("test2.txt", "w"),
            [](FILE* f) { if (f) std::fclose(f); }
        );
    }

    std::cout << "Todos los archivos cerrados" << std::endl;
    return 0;
}
<---Custom Deleters Result--->
<---make_unique y make_shared--->
```cpp
#include <iostream>
#include <memory>

class Punto {
public:
    Punto(double x, double y) : x_(x), y_(y) {}
    void mostrar() const {
        std::cout << "(" << x_ << ", " << y_ << ")" << std::endl;
    }
private:
    double x_, y_;
};

int main() {
    auto p1 = std::make_unique<Punto>(3.0, 4.0);
    auto p2 = std::make_shared<Punto>(1.0, 2.0);

    p1->mostrar(); // Salida: (3, 4)
    p2->mostrar(); // Salida: (1, 2)

    auto arr = std::make_unique<int[]>(10);
    for (int i = 0; i < 10; ++i) arr[i] = i;
    return 0;
}
<---make_unique y make_shared Result--->
<---Punteros Inteligentes en Qt--->
```cpp
#include <QScopedPointer>
#include <QSharedPointer>
#include <QWeakPointer>
#include <QPointer>
#include <QObject>
#include <QDebug>

class Motor : public QObject {
    Q_OBJECT
public:
    explicit Motor(QObject* parent = nullptr) : QObject(parent) {}
    void arrancar() { qDebug() << "Motor arrancado"; }
};

void punterosQt() {
    // QScopedPointer ≈ std::unique_ptr
    {
        QScopedPointer<int> ptr(new int(42));
        qDebug() << "QScopedPointer:" << *ptr;
    }
    // QSharedPointer ≈ std::shared_ptr
    {
        QSharedPointer<int> p1 = QSharedPointer<int>::create(100);
        QSharedPointer<int> p2 = p1;
        qDebug() << "QSharedPointer:" << *p1;
    }
    // QPointer — exclusivo de Qt, para QObject*
    {
        auto* motor = new Motor();
        QPointer<Motor> ptrSeguro = motor;
        delete motor;
        qDebug() << "¿Motor existe?" << !ptrSeguro.isNull(); // false
    }
}
<---Punteros Inteligentes en Qt Result--->
