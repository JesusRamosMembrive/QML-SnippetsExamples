<---EXPLANATION--->
### `std::shared_ptr` en Profundidad

`std::shared_ptr` es un puntero inteligente que permite compartir la propiedad de un recurso entre múltiples punteros. Este puntero inteligente utiliza un mecanismo de conteo de referencias para asegurarse de que el recurso se libera automáticamente cuando el último `std::shared_ptr` que lo posee es destruido. Aquí exploraremos su uso en profundidad, mejores prácticas y ejemplos de cómo integrarlo en proyectos más grandes.

#### Declaraciones y Uso Básico

##### Declaración y Asignación

Para declarar un `std::shared_ptr`, se incluye la cabecera `<memory>` y se puede utilizar `std::make_shared` para asignar memoria.

```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
    std::shared_ptr<int> ptr2 = ptr1; // ptr1 y ptr2 comparten la propiedad del mismo recurso

    std::cout << *ptr1 << std::endl; // Salida: 10
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // Memoria liberada automáticamente cuando el último shared_ptr sale del alcance
    return 0;
}
```

#### En Clases y Archivos de Cabecera

El uso de `std::shared_ptr` en clases permite una gestión de recursos compartida y segura. Aquí se muestra cómo declarar y definir una clase que utiliza `std::shared_ptr`.

##### Declaración en el Archivo de Cabecera (.h)

```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <memory>
#include <string>

class MiClase {
public:
    MiClase(const std::string& nombre);
    void mostrar() const;

private:
    std::shared_ptr<std::string> nombre_;
};

#endif // MICLASE_H
```

##### Definición en el Archivo de Implementación (.cpp)

```cpp
// MiClase.cpp
#include "MiClase.h"
#include <iostream>

// Constructor
MiClase::MiClase(const std::string& nombre)
    : nombre_(std::make_shared<std::string>(nombre)) {}

// Método mostrar
void MiClase::mostrar() const {
    std::cout << "Nombre: " << *nombre_ << std::endl;
}
```

#### Mejor Uso de `std::shared_ptr`

##### 1. Compartición de Recursos

`std::shared_ptr` es ideal para situaciones donde múltiples partes del código necesitan compartir la propiedad de un recurso. Por ejemplo, en estructuras de datos complejas como gráficos o árboles donde los nodos pueden ser compartidos por múltiples padres.

```cpp
#include <memory>
#include <vector>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
};

int main() {
    auto raiz = std::make_shared<Nodo>(1);
    auto hijo1 = std::make_shared<Nodo>(2);
    auto hijo2 = std::make_shared<Nodo>(3);

    raiz->agregarHijo(hijo1);
    raiz->agregarHijo(hijo2);

    raiz->mostrar(); // Muestra toda la jerarquía de nodos

    return 0;
}
```

##### 2. Evitar Ciclos de Referencia

Para evitar ciclos de referencia que pueden causar fugas de memoria, `std::shared_ptr` se utiliza junto con `std::weak_ptr`. Un `std::weak_ptr` es un puntero no propietario que permite referenciar un `std::shared_ptr` sin incrementar su contador de referencias.

##### Ejemplo de Ciclo de Referencia

```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::shared_ptr<Nodo> padre_; // Ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Ciclo de referencia evita que los nodos sean destruidos

    return 0;
}
```

##### Solución usando `std::weak_ptr`

```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::weak_ptr<Nodo> padre_; // Evitar ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Nodos correctamente destruidos

    return 0;
}
```

#### Ejemplo Completo

A continuación, se muestra un ejemplo más completo que incluye la declaración y el uso de `std::shared_ptr` en una clase, mostrando la gestión de recursos compartidos y evitando ciclos de referencia con `std::weak_ptr`.

##### Archivo de Cabecera (.h)

```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

private:
    std::shared_ptr<std::string> recurso_;
};

class Contenedor {
public:
    void establecerRecurso(std::shared_ptr<GestorRecurso> recurso);
    void mostrar() const;

private:
    std::shared_ptr<GestorRecurso> recurso_;
};

#endif // GESTORRECURSO_H
```

##### Archivo de Implementación (.cpp)

```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_shared<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

void Contenedor::establecerRecurso(std::shared_ptr<GestorRecurso> recurso) {
    recurso_ = recurso;
}

void Contenedor::mostrar() const {
    if (recurso_) {
        recurso_->mostrarRecurso();
    } else {
        std::cout << "Sin recurso" << std::endl;
    }
}
```

##### Función Principal

```cpp
#include <iostream>
#include "GestorRecurso.h"

int main() {
    auto recurso = std::make_shared<GestorRecurso>("MiRecurso");
    Contenedor contenedor;
    contenedor.establecerRecurso(recurso);

    recurso->mostrarRecurso();
    contenedor.mostrar();

    return 0;
}
```

### Características Avanzadas de `std::shared_ptr`

#### `std::enable_shared_from_this`

Permite que un objeto gestionado por `shared_ptr` obtenga un `shared_ptr` a sí mismo de forma segura.

```cpp
#include <iostream>
#include <memory>
#include <vector>

class Tarea : public std::enable_shared_from_this<Tarea> {
public:
    Tarea(const std::string& nombre) : nombre_(nombre) {}

    // Obtener shared_ptr a sí mismo — solo funciona si ya existe un shared_ptr
    std::shared_ptr<Tarea> obtenerPtr() {
        return shared_from_this();
    }

    // Registrarse en una cola usando shared_from_this
    void registrar(std::vector<std::shared_ptr<Tarea>>& cola) {
        cola.push_back(shared_from_this());
        std::cout << "Tarea '" << nombre_ << "' registrada (refs: "
                  << shared_from_this().use_count() << ")" << std::endl;
    }

    const std::string& nombre() const { return nombre_; }

private:
    std::string nombre_;
};

int main() {
    auto tarea = std::make_shared<Tarea>("Compilar");
    std::vector<std::shared_ptr<Tarea>> cola;

    tarea->registrar(cola);

    std::cout << "Cola tiene: " << cola[0]->nombre() << std::endl;
    std::cout << "Referencias: " << tarea.use_count() << std::endl; // 2

    return 0;
}
```

#### Constructor de Aliasing (Aliasing Constructor)

Permite crear un `shared_ptr` que comparte la propiedad de un objeto pero apunta a un subobjeto.

```cpp
#include <iostream>
#include <memory>
#include <string>

struct Persona {
    std::string nombre;
    int edad;

    Persona(std::string n, int e) : nombre(std::move(n)), edad(e) {}
};

int main() {
    auto persona = std::make_shared<Persona>("Ana", 30);

    // Aliasing: compartir ownership de Persona, pero apuntar a un miembro
    std::shared_ptr<std::string> nombrePtr(persona, &persona->nombre);
    std::shared_ptr<int> edadPtr(persona, &persona->edad);

    // nombrePtr y edadPtr mantienen viva a Persona
    persona.reset(); // Libera nuestra referencia, pero Persona sigue viva

    std::cout << "Nombre: " << *nombrePtr << std::endl; // Ana
    std::cout << "Edad: " << *edadPtr << std::endl;      // 30
    std::cout << "Refs nombre: " << nombrePtr.use_count() << std::endl; // 2

    return 0;
}
```

#### Equivalentes en Qt: `QSharedPointer`

```cpp
#include <QSharedPointer>
#include <QWeakPointer>
#include <QEnableSharedFromThis>
#include <QDebug>

// QSharedPointer con QEnableSharedFromThis (equivalente de enable_shared_from_this)
class Servicio : public QEnableSharedFromThis<Servicio> {
public:
    Servicio(const QString& nombre) : nombre_(nombre) {
        qDebug() << "Creando servicio:" << nombre_;
    }
    ~Servicio() {
        qDebug() << "Destruyendo servicio:" << nombre_;
    }

    QSharedPointer<Servicio> obtenerPtr() {
        return sharedFromThis();
    }

    QString nombre() const { return nombre_; }

private:
    QString nombre_;
};

void ejemploQSharedPointer() {
    // Crear con QSharedPointer::create (equivalente de make_shared)
    auto servicio = QSharedPointer<Servicio>::create("Base de Datos");

    // Compartir propiedad
    QSharedPointer<Servicio> copia = servicio;
    qDebug() << "Servicio:" << servicio->nombre();

    // QWeakPointer para evitar ciclos
    QWeakPointer<Servicio> observador = servicio;

    if (auto ptr = observador.toStrongRef()) {
        qDebug() << "Servicio vivo:" << ptr->nombre();
    }

    // Conversión entre QSharedPointer y std::shared_ptr (Qt 6)
    // No hay conversión directa — usar raw pointer con precaución

    // Custom deleter en QSharedPointer
    QSharedPointer<int> conDeleter(new int(42), [](int* p) {
        qDebug() << "Deleter personalizado para:" << *p;
        delete p;
    });
}
```

### Conclusión

`std::shared_ptr` es una herramienta esencial en C++ para la gestión segura y eficiente de recursos compartidos. Su uso adecuado en clases, funciones y estructuras de datos complejas permite evitar muchos errores comunes relacionados con la gestión de memoria, como fugas de memoria y accesos a memoria inválida. Al seguir las mejores prácticas y entender cómo utilizar `std::shared_ptr` junto con `std::weak_ptr` para evitar ciclos de referencia, se puede escribir código más robusto y mantenible.
<---FILES--->
Declaración y Asignación
Declaración y Asignación Result
Declaración en el Archivo de Cabecera (.h)
Declaración en el Archivo de Cabecera (.h) Result
Definición en el Archivo de Implementación (.cpp)
Definición en el Archivo de Implementación (.cpp) Result
1. Compartición de Recursos
1. Compartición de Recursos Result
2. Evitar Ciclos de Referencia
2. Evitar Ciclos de Referencia Result
Ejemplo de Ciclo de Referencia
Ejemplo de Ciclo de Referencia Result
Solución usando `std::weak_ptr`
Solución usando `std::weak_ptr` Result
Archivo de Cabecera (.h)
Archivo de Cabecera (.h) Result
Archivo de Implementación (.cpp)
Archivo de Implementación (.cpp) Result
Función Principal
Función Principal Result
<---Declaración y Asignación--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
    std::shared_ptr<int> ptr2 = ptr1; // ptr1 y ptr2 comparten la propiedad del mismo recurso

    std::cout << *ptr1 << std::endl; // Salida: 10
    std::cout << "Use count: " << ptr1.use_count() << std::endl; // Salida: 2

    // Memoria liberada automáticamente cuando el último shared_ptr sale del alcance
    return 0;
}
<---Declaración y Asignación Result--->
<---Declaración en el Archivo de Cabecera (.h)--->
```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <memory>
#include <string>

class MiClase {
public:
    MiClase(const std::string& nombre);
    void mostrar() const;

private:
    std::shared_ptr<std::string> nombre_;
};

#endif // MICLASE_H
<---Declaración en el Archivo de Cabecera (.h) Result--->
<---Definición en el Archivo de Implementación (.cpp)--->
```cpp
// MiClase.cpp
#include "MiClase.h"
#include <iostream>

// Constructor
MiClase::MiClase(const std::string& nombre)
    : nombre_(std::make_shared<std::string>(nombre)) {}

// Método mostrar
void MiClase::mostrar() const {
    std::cout << "Nombre: " << *nombre_ << std::endl;
}
<---Definición en el Archivo de Implementación (.cpp) Result--->
<---1. Compartición de Recursos--->
```cpp
#include <memory>
#include <vector>
#include <iostream>

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void agregarHijo(std::shared_ptr<Nodo> hijo) {
        hijos_.push_back(hijo);
    }

    void mostrar() const {
        std::cout << "Nodo: " << valor_ << std::endl;
        for (const auto& hijo : hijos_) {
            hijo->mostrar();
        }
    }

private:
    int valor_;
    std::vector<std::shared_ptr<Nodo>> hijos_;
};

int main() {
    auto raiz = std::make_shared<Nodo>(1);
    auto hijo1 = std::make_shared<Nodo>(2);
    auto hijo2 = std::make_shared<Nodo>(3);

    raiz->agregarHijo(hijo1);
    raiz->agregarHijo(hijo2);

    raiz->mostrar(); // Muestra toda la jerarquía de nodos

    return 0;
}
<---1. Compartición de Recursos Result--->
<---2. Evitar Ciclos de Referencia--->
<---2. Evitar Ciclos de Referencia Result--->
<---Ejemplo de Ciclo de Referencia--->
```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::shared_ptr<Nodo> padre_; // Ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Ciclo de referencia evita que los nodos sean destruidos

    return 0;
}
<---Ejemplo de Ciclo de Referencia Result--->
<---Solución usando `std::weak_ptr`--->
```cpp
#include <memory>
#include <iostream>

class Nodo;

class Nodo {
public:
    Nodo(int valor) : valor_(valor) {}

    void establecerPadre(std::shared_ptr<Nodo> padre) {
        padre_ = padre;
    }

    void establecerHijo(std::shared_ptr<Nodo> hijo) {
        hijo_ = hijo;
    }

    ~Nodo() {
        std::cout << "Destruyendo nodo: " << valor_ << std::endl;
    }

private:
    int valor_;
    std::shared_ptr<Nodo> hijo_;
    std::weak_ptr<Nodo> padre_; // Evitar ciclo de referencia
};

int main() {
    {
        auto nodo1 = std::make_shared<Nodo>(1);
        auto nodo2 = std::make_shared<Nodo>(2);

        nodo1->establecerHijo(nodo2);
        nodo2->establecerPadre(nodo1);
    } // Nodos correctamente destruidos

    return 0;
}
<---Solución usando `std::weak_ptr` Result--->
<---Archivo de Cabecera (.h)--->
```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

private:
    std::shared_ptr<std::string> recurso_;
};

class Contenedor {
public:
    void establecerRecurso(std::shared_ptr<GestorRecurso> recurso);
    void mostrar() const;

private:
    std::shared_ptr<GestorRecurso> recurso_;
};

#endif // GESTORRECURSO_H
<---Archivo de Cabecera (.h) Result--->
<---Archivo de Implementación (.cpp)--->
```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_shared<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

void Contenedor::establecerRecurso(std::shared_ptr<GestorRecurso> recurso) {
    recurso_ = recurso;
}

void Contenedor::mostrar() const {
    if (recurso_) {
        recurso_->mostrarRecurso();
    } else {
        std::cout << "Sin recurso" << std::endl;
    }
}
<---Archivo de Implementación (.cpp) Result--->
<---Función Principal--->
```cpp
#include <iostream>
#include "GestorRecurso.h"

int main() {
    auto recurso = std::make_shared<GestorRecurso>("MiRecurso");
    Contenedor contenedor;
    contenedor.establecerRecurso(recurso);

    recurso->mostrarRecurso();
    contenedor.mostrar();

    return 0;
}
<---Función Principal Result--->
enable_shared_from_this
enable_shared_from_this Result
Constructor de Aliasing
Constructor de Aliasing Result
QSharedPointer en Qt
QSharedPointer en Qt Result
<---enable_shared_from_this--->
```cpp
#include <iostream>
#include <memory>
#include <vector>

class Tarea : public std::enable_shared_from_this<Tarea> {
public:
    Tarea(const std::string& nombre) : nombre_(nombre) {}

    void registrar(std::vector<std::shared_ptr<Tarea>>& cola) {
        cola.push_back(shared_from_this());
        std::cout << "Tarea '" << nombre_ << "' registrada (refs: "
                  << shared_from_this().use_count() << ")" << std::endl;
    }

    const std::string& nombre() const { return nombre_; }
private:
    std::string nombre_;
};

int main() {
    auto tarea = std::make_shared<Tarea>("Compilar");
    std::vector<std::shared_ptr<Tarea>> cola;
    tarea->registrar(cola);

    std::cout << "Cola tiene: " << cola[0]->nombre() << std::endl;
    std::cout << "Referencias: " << tarea.use_count() << std::endl; // 2
    return 0;
}
<---enable_shared_from_this Result--->
<---Constructor de Aliasing--->
```cpp
#include <iostream>
#include <memory>
#include <string>

struct Persona {
    std::string nombre;
    int edad;
    Persona(std::string n, int e) : nombre(std::move(n)), edad(e) {}
};

int main() {
    auto persona = std::make_shared<Persona>("Ana", 30);

    // Aliasing: compartir ownership de Persona, apuntar a miembro
    std::shared_ptr<std::string> nombrePtr(persona, &persona->nombre);
    std::shared_ptr<int> edadPtr(persona, &persona->edad);

    persona.reset(); // Persona sigue viva por los alias

    std::cout << "Nombre: " << *nombrePtr << std::endl; // Ana
    std::cout << "Edad: " << *edadPtr << std::endl;      // 30
    return 0;
}
<---Constructor de Aliasing Result--->
<---QSharedPointer en Qt--->
```cpp
#include <QSharedPointer>
#include <QWeakPointer>
#include <QEnableSharedFromThis>
#include <QDebug>

class Servicio : public QEnableSharedFromThis<Servicio> {
public:
    Servicio(const QString& nombre) : nombre_(nombre) {
        qDebug() << "Creando servicio:" << nombre_;
    }
    ~Servicio() { qDebug() << "Destruyendo servicio:" << nombre_; }

    QSharedPointer<Servicio> obtenerPtr() { return sharedFromThis(); }
    QString nombre() const { return nombre_; }
private:
    QString nombre_;
};

void ejemploQSharedPointer() {
    auto servicio = QSharedPointer<Servicio>::create("Base de Datos");
    QSharedPointer<Servicio> copia = servicio;
    qDebug() << "Servicio:" << servicio->nombre();

    QWeakPointer<Servicio> observador = servicio;
    if (auto ptr = observador.toStrongRef()) {
        qDebug() << "Servicio vivo:" << ptr->nombre();
    }

    QSharedPointer<int> conDeleter(new int(42), [](int* p) {
        qDebug() << "Deleter personalizado:" << *p;
        delete p;
    });
}
<---QSharedPointer en Qt Result--->
