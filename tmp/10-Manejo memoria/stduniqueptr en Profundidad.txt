<---EXPLANATION--->
### `std::unique_ptr` en Profundidad

`std::unique_ptr` es un puntero inteligente que proporciona propiedad exclusiva sobre un recurso. Es una herramienta poderosa para gestionar la memoria dinámica y asegurar que los recursos sean liberados correctamente cuando ya no se necesiten. Aquí profundizaremos en su uso, las mejores prácticas y cómo integrarlo en proyectos más grandes.

#### Declaraciones y Uso Básico

##### Declaración y Asignación

Para declarar un `std::unique_ptr`, se incluye la cabecera `<memory>` y se puede utilizar `std::make_unique` para asignar memoria.

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10
    // Memoria liberada automáticamente al salir del alcance
    return 0;
}
```

#### En Clases y Archivos de Cabecera

El uso de `std::unique_ptr` en clases permite una gestión de recursos clara y segura. Aquí se muestra cómo declarar y definir una clase que utiliza `std::unique_ptr`.

##### Declaración en el Archivo de Cabecera (.h)

```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <memory>
#include <string>

class MiClase {
public:
    MiClase(const std::string& nombre);
    ~MiClase();

    void mostrar() const;

private:
    std::unique_ptr<std::string> nombre_;
};

#endif // MICLASE_H
```

##### Definición en el Archivo de Implementación (.cpp)

```cpp
// MiClase.cpp
#include "MiClase.h"
#include <iostream>

// Constructor
MiClase::MiClase(const std::string& nombre)
    : nombre_(std::make_unique<std::string>(nombre)) {}

// Destructor
MiClase::~MiClase() {
    // `std::unique_ptr` libera la memoria automáticamente
}

// Método mostrar
void MiClase::mostrar() const {
    std::cout << "Nombre: " << *nombre_ << std::endl;
}
```

#### Transferencia de Propiedad

La propiedad de un `std::unique_ptr` puede transferirse utilizando `std::move`. Esto es útil cuando se necesita transferir la propiedad de un recurso a otra función o objeto.

##### Ejemplo de Transferencia de Propiedad

```cpp
#include <iostream>
#include <memory>

void mostrar(std::unique_ptr<int> ptr) {
    std::cout << *ptr << std::endl;
}

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    mostrar(std::move(ptr)); // Transferir la propiedad
    // ptr ya no es válido aquí
    return 0;
}
```

#### Mejor Uso de `std::unique_ptr`

##### 1. Encapsulación de Recursos

Utilice `std::unique_ptr` para encapsular recursos en clases. Esto asegura que los recursos sean liberados correctamente cuando la instancia de la clase es destruida.

```cpp
class Archivo {
public:
    Archivo(const std::string& nombre) : archivo_(std::fopen(nombre.c_str(), "r")) {
        if (!archivo_) {
            throw std::runtime_error("No se pudo abrir el archivo");
        }
    }

    ~Archivo() {
        if (archivo_) {
            std::fclose(archivo_);
        }
    }

private:
    std::unique_ptr<FILE, decltype(&std::fclose)> archivo_;
};
```

##### 2. Uso en Contenedores

Los contenedores de la STL pueden almacenar `std::unique_ptr`, lo que permite una gestión eficiente de colecciones de recursos dinámicos.

```cpp
#include <vector>
#include <memory>

int main() {
    std::vector<std::unique_ptr<int>> vec;
    vec.push_back(std::make_unique<int>(1));
    vec.push_back(std::make_unique<int>(2));
    vec.push_back(std::make_unique<int>(3));

    for (const auto& ptr : vec) {
        std::cout << *ptr << std::endl;
    }
    return 0;
}
```

##### 3. Evitar el Uso de Punteros Crudos

Prefiera `std::unique_ptr` sobre los punteros crudos para garantizar la gestión automática de la memoria y reducir el riesgo de fugas de memoria y accesos inválidos.

#### Ejemplo Completo

A continuación, se muestra un ejemplo más completo que incluye la declaración y el uso de `std::unique_ptr` en una clase, mostrando la gestión de recursos y la transferencia de propiedad.

##### Archivo de Cabecera (.h)

```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

    // Transferir la propiedad del recurso
    std::unique_ptr<std::string> transferirRecurso();

private:
    std::unique_ptr<std::string> recurso_;
};

#endif // GESTORRECURSO_H
```

##### Archivo de Implementación (.cpp)

```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_unique<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

std::unique_ptr<std::string> GestorRecurso::transferirRecurso() {
    return std::move(recurso_);
}
```

##### Función Principal

```cpp
#include <iostream>
#include "GestorRecurso.h"

int main() {
    GestorRecurso gestor("MiRecurso");
    gestor.mostrarRecurso();

    std::unique_ptr<std::string> recurso = gestor.transferirRecurso();
    if (recurso) {
        std::cout << "Recurso transferido: " << *recurso << std::endl;
    }

    // Intentar mostrar el recurso después de la transferencia
    gestor.mostrarRecurso(); // Esto no imprimirá nada ya que el recurso fue transferido

    return 0;
}
```

### Características Avanzadas de `std::unique_ptr`

#### Custom Deleters Avanzados

Los deleters personalizados permiten usar `std::unique_ptr` con cualquier tipo de recurso, no solo memoria.

```cpp
#include <iostream>
#include <memory>
#include <cstdio>

// Deleter como functor (sin overhead de tamaño en unique_ptr)
struct CierraArchivo {
    void operator()(FILE* f) const {
        if (f) {
            std::cout << "Cerrando archivo" << std::endl;
            std::fclose(f);
        }
    }
};

// Deleter para recursos del SO (handles, sockets, etc.)
struct CierraHandle {
    void operator()(void* handle) const {
        if (handle) {
            // CloseHandle(handle); // Windows
            std::cout << "Handle cerrado" << std::endl;
        }
    }
};

int main() {
    // Con functor — sizeof(unique_ptr) == sizeof(FILE*)
    std::unique_ptr<FILE, CierraArchivo> archivo(std::fopen("datos.txt", "w"));

    // Con lambda — sizeof puede ser mayor
    auto deleter = [](int* p) {
        std::cout << "Liberando " << *p << std::endl;
        delete p;
    };
    std::unique_ptr<int, decltype(deleter)> ptr(new int(42), deleter);

    // unique_ptr para arreglos con deleter
    std::unique_ptr<int[]> arr(new int[10]);
    arr[0] = 100;

    return 0;
}
```

#### Patrón Pimpl (Pointer to Implementation)

El patrón Pimpl oculta los detalles de implementación en el archivo .cpp, reduciendo dependencias de compilación.

```cpp
// === Widget.h ===
#ifndef WIDGET_H
#define WIDGET_H

#include <memory>
#include <string>

class Widget {
public:
    Widget(const std::string& nombre);
    ~Widget(); // Debe declararse — definir en .cpp donde Impl es completo

    // Move operations (declarar en .h, definir en .cpp)
    Widget(Widget&& otro) noexcept;
    Widget& operator=(Widget&& otro) noexcept;

    // Prohibir copia
    Widget(const Widget&) = delete;
    Widget& operator=(const Widget&) = delete;

    void mostrar() const;

private:
    struct Impl; // Forward declaration — los detalles están ocultos
    std::unique_ptr<Impl> pImpl_;
};

#endif

// === Widget.cpp ===
// #include "Widget.h"
#include <iostream>

struct Widget::Impl {
    std::string nombre;
    int dato_interno = 0;
    // Otros miembros pesados que no queremos exponer en el .h
};

Widget::Widget(const std::string& nombre)
    : pImpl_(std::make_unique<Impl>()) {
    pImpl_->nombre = nombre;
}

Widget::~Widget() = default; // Aquí Impl es tipo completo

Widget::Widget(Widget&& otro) noexcept = default;
Widget& Widget::operator=(Widget&& otro) noexcept = default;

void Widget::mostrar() const {
    std::cout << "Widget: " << pImpl_->nombre << std::endl;
}
```

#### Equivalentes en Qt: `QScopedPointer` y d-pointer

```cpp
#include <QObject>
#include <QScopedPointer>
#include <QDebug>

// Qt usa el patrón d-pointer (Pimpl) extensivamente
// Macro Q_DECLARE_PRIVATE lo facilita

// === MiClaseQt.h ===
class MiClaseQtPrivate; // Forward declaration

class MiClaseQt : public QObject {
    Q_OBJECT
public:
    explicit MiClaseQt(const QString& nombre, QObject* parent = nullptr);
    ~MiClaseQt() override;

    QString nombre() const;
    void setNombre(const QString& nombre);

private:
    QScopedPointer<MiClaseQtPrivate> d_ptr;
    // En Qt real se usa: Q_DECLARE_PRIVATE(MiClaseQt)
};

// === MiClaseQt.cpp ===
class MiClaseQtPrivate {
public:
    QString nombre;
    int datoInterno = 0;
};

MiClaseQt::MiClaseQt(const QString& nombre, QObject* parent)
    : QObject(parent), d_ptr(new MiClaseQtPrivate) {
    d_ptr->nombre = nombre;
}

MiClaseQt::~MiClaseQt() = default;

QString MiClaseQt::nombre() const {
    return d_ptr->nombre;
}

void MiClaseQt::setNombre(const QString& nombre) {
    d_ptr->nombre = nombre;
}
```

### Conclusión

`std::unique_ptr` es una herramienta esencial en C++ para la gestión segura y eficiente de recursos. Su uso adecuado en clases, funciones y contenedores permite evitar muchos errores comunes relacionados con la gestión de memoria, como fugas de memoria y accesos a memoria inválida. Al seguir las mejores prácticas y entender cómo transferir la propiedad de recursos, se puede escribir código más robusto y mantenible.
<---FILES--->
Declaración y Asignación
Declaración y Asignación Result
Declaración en el Archivo de Cabecera (.h)
Declaración en el Archivo de Cabecera (.h) Result
Definición en el Archivo de Implementación (.cpp)
Definición en el Archivo de Implementación (.cpp) Result
Ejemplo de Transferencia de Propiedad
Ejemplo de Transferencia de Propiedad Result
1. Encapsulación de Recursos
1. Encapsulación de Recursos Result
2. Uso en Contenedores
2. Uso en Contenedores Result
3. Evitar el Uso de Punteros Crudos
3. Evitar el Uso de Punteros Crudos Result
Archivo de Cabecera (.h)
Archivo de Cabecera (.h) Result
Archivo de Implementación (.cpp)
Archivo de Implementación (.cpp) Result
Función Principal
Función Principal Result
<---Declaración y Asignación--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10);
    std::cout << *ptr << std::endl; // Salida: 10
    // Memoria liberada automáticamente al salir del alcance
    return 0;
}
<---Declaración y Asignación Result--->
<---Declaración en el Archivo de Cabecera (.h)--->
```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <memory>
#include <string>

class MiClase {
public:
    MiClase(const std::string& nombre);
    ~MiClase();

    void mostrar() const;

private:
    std::unique_ptr<std::string> nombre_;
};

#endif // MICLASE_H
<---Declaración en el Archivo de Cabecera (.h) Result--->
<---Definición en el Archivo de Implementación (.cpp)--->
```cpp
// MiClase.cpp
#include "MiClase.h"
#include <iostream>

// Constructor
MiClase::MiClase(const std::string& nombre)
    : nombre_(std::make_unique<std::string>(nombre)) {}

// Destructor
MiClase::~MiClase() {
    // `std::unique_ptr` libera la memoria automáticamente
}

// Método mostrar
void MiClase::mostrar() const {
    std::cout << "Nombre: " << *nombre_ << std::endl;
}
<---Definición en el Archivo de Implementación (.cpp) Result--->
<---Ejemplo de Transferencia de Propiedad--->
```cpp
#include <iostream>
#include <memory>

void mostrar(std::unique_ptr<int> ptr) {
    std::cout << *ptr << std::endl;
}

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(42);
    mostrar(std::move(ptr)); // Transferir la propiedad
    // ptr ya no es válido aquí
    return 0;
}
<---Ejemplo de Transferencia de Propiedad Result--->
<---1. Encapsulación de Recursos--->
```cpp
class Archivo {
public:
    Archivo(const std::string& nombre) : archivo_(std::fopen(nombre.c_str(), "r")) {
        if (!archivo_) {
            throw std::runtime_error("No se pudo abrir el archivo");
        }
    }

    ~Archivo() {
        if (archivo_) {
            std::fclose(archivo_);
        }
    }

private:
    std::unique_ptr<FILE, decltype(&std::fclose)> archivo_;
};
<---1. Encapsulación de Recursos Result--->
<---2. Uso en Contenedores--->
```cpp
#include <vector>
#include <memory>

int main() {
    std::vector<std::unique_ptr<int>> vec;
    vec.push_back(std::make_unique<int>(1));
    vec.push_back(std::make_unique<int>(2));
    vec.push_back(std::make_unique<int>(3));

    for (const auto& ptr : vec) {
        std::cout << *ptr << std::endl;
    }
    return 0;
}
<---2. Uso en Contenedores Result--->
<---3. Evitar el Uso de Punteros Crudos--->
<---3. Evitar el Uso de Punteros Crudos Result--->
<---Archivo de Cabecera (.h)--->
```cpp
// GestorRecurso.h
#ifndef GESTORRECURSO_H
#define GESTORRECURSO_H

#include <memory>
#include <string>

class GestorRecurso {
public:
    GestorRecurso(const std::string& nombre);
    void mostrarRecurso() const;

    // Transferir la propiedad del recurso
    std::unique_ptr<std::string> transferirRecurso();

private:
    std::unique_ptr<std::string> recurso_;
};

#endif // GESTORRECURSO_H
<---Archivo de Cabecera (.h) Result--->
<---Archivo de Implementación (.cpp)--->
```cpp
// GestorRecurso.cpp
#include "GestorRecurso.h"
#include <iostream>

GestorRecurso::GestorRecurso(const std::string& nombre)
    : recurso_(std::make_unique<std::string>(nombre)) {}

void GestorRecurso::mostrarRecurso() const {
    std::cout << "Recurso: " << *recurso_ << std::endl;
}

std::unique_ptr<std::string> GestorRecurso::transferirRecurso() {
    return std::move(recurso_);
}
<---Archivo de Implementación (.cpp) Result--->
<---Función Principal--->
```cpp
#include <iostream>
#include "GestorRecurso.h"

int main() {
    GestorRecurso gestor("MiRecurso");
    gestor.mostrarRecurso();

    std::unique_ptr<std::string> recurso = gestor.transferirRecurso();
    if (recurso) {
        std::cout << "Recurso transferido: " << *recurso << std::endl;
    }

    // Intentar mostrar el recurso después de la transferencia
    gestor.mostrarRecurso(); // Esto no imprimirá nada ya que el recurso fue transferido

    return 0;
}
<---Función Principal Result--->
Custom Deleters Avanzados
Custom Deleters Avanzados Result
Patrón Pimpl con unique_ptr
Patrón Pimpl con unique_ptr Result
QScopedPointer y d-pointer en Qt
QScopedPointer y d-pointer en Qt Result
<---Custom Deleters Avanzados--->
```cpp
#include <iostream>
#include <memory>
#include <cstdio>

struct CierraArchivo {
    void operator()(FILE* f) const {
        if (f) {
            std::cout << "Cerrando archivo" << std::endl;
            std::fclose(f);
        }
    }
};

int main() {
    // Con functor — sizeof(unique_ptr) == sizeof(FILE*)
    std::unique_ptr<FILE, CierraArchivo> archivo(std::fopen("datos.txt", "w"));

    // Con lambda
    auto deleter = [](int* p) {
        std::cout << "Liberando " << *p << std::endl;
        delete p;
    };
    std::unique_ptr<int, decltype(deleter)> ptr(new int(42), deleter);

    // unique_ptr para arreglos
    std::unique_ptr<int[]> arr(new int[10]);
    arr[0] = 100;
    return 0;
}
<---Custom Deleters Avanzados Result--->
<---Patrón Pimpl con unique_ptr--->
```cpp
// === Widget.h ===
#include <memory>
#include <string>

class Widget {
public:
    Widget(const std::string& nombre);
    ~Widget();
    Widget(Widget&& otro) noexcept;
    Widget& operator=(Widget&& otro) noexcept;
    Widget(const Widget&) = delete;
    Widget& operator=(const Widget&) = delete;
    void mostrar() const;
private:
    struct Impl;
    std::unique_ptr<Impl> pImpl_;
};

// === Widget.cpp ===
#include <iostream>

struct Widget::Impl {
    std::string nombre;
    int dato_interno = 0;
};

Widget::Widget(const std::string& nombre) : pImpl_(std::make_unique<Impl>()) {
    pImpl_->nombre = nombre;
}
Widget::~Widget() = default;
Widget::Widget(Widget&&) noexcept = default;
Widget& Widget::operator=(Widget&&) noexcept = default;

void Widget::mostrar() const {
    std::cout << "Widget: " << pImpl_->nombre << std::endl;
}
<---Patrón Pimpl con unique_ptr Result--->
<---QScopedPointer y d-pointer en Qt--->
```cpp
#include <QObject>
#include <QScopedPointer>
#include <QDebug>

class MiClaseQtPrivate;

class MiClaseQt : public QObject {
    Q_OBJECT
public:
    explicit MiClaseQt(const QString& nombre, QObject* parent = nullptr);
    ~MiClaseQt() override;
    QString nombre() const;
private:
    QScopedPointer<MiClaseQtPrivate> d_ptr;
};

class MiClaseQtPrivate {
public:
    QString nombre;
    int datoInterno = 0;
};

MiClaseQt::MiClaseQt(const QString& nombre, QObject* parent)
    : QObject(parent), d_ptr(new MiClaseQtPrivate) {
    d_ptr->nombre = nombre;
}
MiClaseQt::~MiClaseQt() = default;

QString MiClaseQt::nombre() const { return d_ptr->nombre; }
<---QScopedPointer y d-pointer en Qt Result--->
