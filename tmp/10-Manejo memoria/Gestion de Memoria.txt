<---EXPLANATION--->
### Gestión de Memoria en C++

La gestión de memoria en C++ es un aspecto fundamental que todo desarrollador debe entender profundamente para evitar errores comunes como fugas de memoria y accesos inválidos. A diferencia de lenguajes de programación que manejan la memoria automáticamente, C++ permite y requiere que el programador gestione la asignación y liberación de memoria.

#### Tipos de Memoria en C++

En C++, la memoria se puede clasificar en dos tipos principales: memoria estática y memoria dinámica.

1. **Memoria Estática**: Se asigna en el tiempo de compilación. Incluye variables globales, variables estáticas y constantes.
2. **Memoria Dinámica**: Se asigna en el tiempo de ejecución usando operadores como `new` y `delete`.

#### Asignación y Liberación de Memoria

##### Memoria Estática

La memoria estática se gestiona automáticamente. Por ejemplo:

```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
```

##### Memoria Dinámica

La memoria dinámica se asigna y libera manualmente usando `new` y `delete` para variables simples, y `new[]` y `delete[]` para arreglos.

##### Ejemplo Básico de Asignación Dinámica

```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
```

##### Ejemplo de Arreglo Dinámico

```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
```

### Buenas Prácticas para la Gestión de Memoria

#### 1. Siempre Liberar la Memoria Asignada

No liberar la memoria asignada dinámicamente resulta en fugas de memoria, lo que puede llevar a que una aplicación consuma más memoria de la necesaria y eventualmente falle.

##### Ejemplo Incorrecto

```cpp
int* ptr = new int; // Asignar memoria
// ... uso de ptr
// Olvidar liberar la memoria: fuga de memoria
```

##### Ejemplo Correcto

```cpp
int* ptr = new int; // Asignar memoria
// ... uso de ptr
delete ptr; // Liberar memoria
```

#### 2. Usar Smart Pointers

Los punteros inteligentes (`smart pointers`) en la biblioteca estándar de C++ (`std::unique_ptr`, `std::shared_ptr`, etc.) ayudan a manejar la memoria de manera automática y evitar fugas de memoria.

##### Ejemplo con `std::unique_ptr`

```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(100); // Asignar memoria
    std::cout << *ptr << std::endl; // Salida: 100
    // Memoria se libera automáticamente cuando ptr sale del alcance

    return 0;
}
```

#### 3. Evitar Accesos Inválidos a Memoria

Acceder a memoria después de haberla liberado resulta en comportamiento indefinido. Siempre asegúrese de no usar punteros después de haber llamado a `delete`.

##### Ejemplo Incorrecto

```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
```

##### Ejemplo Correcto

```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```

### Gestión de Memoria en Clases

Cuando se diseñan clases que manejan recursos dinámicos, es esencial implementar correctamente el constructor de copia, el operador de asignación y el destructor.

#### Ejemplo: Clase con Gestión de Memoria

```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
```

### Características Modernas de C++ para Gestión de Memoria

#### Regla de Cero, Tres y Cinco

En C++ moderno, la gestión correcta de recursos se resume en estas reglas:

```cpp
#include <iostream>
#include <string>
#include <memory>
#include <vector>

// REGLA DE CERO: Preferir tipos RAII y no definir nada manualmente
class PersonaModerna {
    std::string nombre_;        // Se gestiona solo
    std::vector<int> datos_;    // Se gestiona solo
    std::unique_ptr<int> extra_; // Se gestiona solo
public:
    PersonaModerna(std::string nombre, int extra)
        : nombre_(std::move(nombre))
        , extra_(std::make_unique<int>(extra)) {}

    // NO necesitamos definir destructor, copy, move — el compilador lo hace bien
    // Porque TODOS los miembros se gestionan solos (RAII)
};

// REGLA DE CINCO: Si defines uno, define los cinco
class BufferManual {
    int* datos_;
    size_t tam_;
public:
    // 1. Constructor
    BufferManual(size_t tam) : tam_(tam), datos_(new int[tam]{}) {}

    // 2. Destructor
    ~BufferManual() { delete[] datos_; }

    // 3. Constructor de copia
    BufferManual(const BufferManual& otro) : tam_(otro.tam_), datos_(new int[otro.tam_]) {
        std::copy(otro.datos_, otro.datos_ + tam_, datos_);
    }

    // 4. Operador de asignación por copia
    BufferManual& operator=(const BufferManual& otro) {
        if (this != &otro) {
            BufferManual tmp(otro); // Copy-and-swap
            std::swap(datos_, tmp.datos_);
            std::swap(tam_, tmp.tam_);
        }
        return *this;
    }

    // 5. Constructor de movimiento
    BufferManual(BufferManual&& otro) noexcept
        : datos_(otro.datos_), tam_(otro.tam_) {
        otro.datos_ = nullptr;
        otro.tam_ = 0;
    }

    // 5b. Operador de asignación por movimiento
    BufferManual& operator=(BufferManual&& otro) noexcept {
        if (this != &otro) {
            delete[] datos_;
            datos_ = otro.datos_;
            tam_ = otro.tam_;
            otro.datos_ = nullptr;
            otro.tam_ = 0;
        }
        return *this;
    }
};

int main() {
    // Regla de Cero — la mejor opción
    PersonaModerna p("Ana", 42);

    // Regla de Cinco — solo cuando se gestiona memoria cruda
    BufferManual b1(100);
    BufferManual b2 = b1;           // Copia
    BufferManual b3 = std::move(b1); // Movimiento

    return 0;
}
```

#### `[[nodiscard]]` para Prevenir Fugas (C++17)

```cpp
#include <memory>
#include <iostream>

// [[nodiscard]] advierte si se ignora el valor de retorno
class Fabrica {
public:
    [[nodiscard]] static std::unique_ptr<int> crear(int valor) {
        return std::make_unique<int>(valor);
    }
};

int main() {
    auto ptr = Fabrica::crear(42); // Correcto: se captura el resultado
    // Fabrica::crear(42);         // Warning del compilador: resultado ignorado
    std::cout << *ptr << std::endl;
    return 0;
}
```

#### Equivalentes en Qt: Gestión de Memoria con QObject

```cpp
#include <QObject>
#include <QDebug>
#include <QScopedPointer>
#include <QSharedPointer>

class Servicio : public QObject {
    Q_OBJECT
public:
    explicit Servicio(QObject* parent = nullptr)
        : QObject(parent) {
        qDebug() << "Servicio creado";
    }
    ~Servicio() override {
        qDebug() << "Servicio destruido";
    }
};

void gestionMemoriaQt() {
    // 1. Modelo padre-hijo (el más común en Qt)
    {
        auto* padre = new QObject();
        auto* hijo1 = new Servicio(padre);
        auto* hijo2 = new Servicio(padre);
        delete padre; // Destruye hijo1 e hijo2 automáticamente
    }

    // 2. QScopedPointer (equivalente Qt de unique_ptr)
    {
        QScopedPointer<Servicio> servicio(new Servicio());
        // Se destruye al salir del ámbito
    }

    // 3. QSharedPointer (equivalente Qt de shared_ptr)
    {
        QSharedPointer<int> ptr1 = QSharedPointer<int>::create(42);
        QSharedPointer<int> ptr2 = ptr1; // Compartido
        qDebug() << "Valor compartido:" << *ptr1;
    }
}
```

### Conclusión

La gestión de memoria en C++ es un tema crítico que requiere atención cuidadosa para evitar errores como fugas de memoria y accesos inválidos. El uso de buenas prácticas como liberar memoria correctamente, usar punteros inteligentes y manejar adecuadamente la memoria en clases asegura que las aplicaciones sean eficientes y robustas. Al entender y aplicar estos conceptos, los desarrolladores pueden escribir código más seguro y mantenible.
<---FILES--->
Memoria Estática
Memoria Estática Result
Memoria Dinámica
Memoria Dinámica Result
Ejemplo Básico de Asignación Dinámica
Ejemplo Básico de Asignación Dinámica Result
Ejemplo de Arreglo Dinámico
Ejemplo de Arreglo Dinámico Result
Ejemplo Incorrecto
Ejemplo Incorrecto Result
Ejemplo Correcto
Ejemplo Correcto Result
Ejemplo con `std::unique_ptr`
Ejemplo con `std::unique_ptr` Result
<---Memoria Estática--->
```cpp
#include <iostream>

int globalVariable = 10; // Variable global (memoria estática)

int main() {
    static int staticVariable = 20; // Variable estática local (memoria estática)
    return 0;
}
<---Memoria Estática Result--->
<---Memoria Dinámica--->
<---Memoria Dinámica Result--->
<---Ejemplo Básico de Asignación Dinámica--->
```cpp
#include <iostream>

int main() {
    int* ptr = new int; // Asignar memoria para un entero
    *ptr = 100; // Usar la memoria asignada
    std::cout << *ptr << std::endl; // Salida: 100
    delete ptr; // Liberar la memoria

    return 0;
}
<---Ejemplo Básico de Asignación Dinámica Result--->
<---Ejemplo de Arreglo Dinámico--->
```cpp
#include <iostream>

int main() {
    int size = 5;
    int* array = new int[size]; // Asignar memoria para un arreglo de enteros

    for(int i = 0; i < size; ++i) {
        array[i] = i * 10; // Inicializar el arreglo
    }

    for(int i = 0; i < size; ++i) {
        std::cout << array[i] << " "; // Salida: 0 10 20 30 40
    }
    std::cout << std::endl;

    delete[] array; // Liberar la memoria

    return 0;
}
<---Ejemplo de Arreglo Dinámico Result--->
<---Ejemplo Incorrecto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
std::cout << *ptr << std::endl; // Acceso inválido: comportamiento indefinido
<---Ejemplo Incorrecto Result--->
<---Ejemplo Correcto--->
```cpp
int* ptr = new int(10);
delete ptr; // Liberar memoria
ptr = nullptr; // Evitar acceso inválido
```cpp
#include <iostream>
#include <cstring>

class String {
private:
    char* data;
    size_t size;

public:
    String(const char* str) {
        size = strlen(str);
        data = new char[size + 1];
        strcpy(data, str);
    }

    ~String() {
        delete[] data;
    }

    // Constructor de copia
    String(const String& other) {
        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
    }

    // Operador de asignación
    String& operator=(const String& other) {
        if (this == &other) return *this;

        delete[] data;

        size = other.size;
        data = new char[size + 1];
        strcpy(data, other.data);
        return *this;
    }

    void print() const {
        std::cout << data << std::endl;
    }
};

int main() {
    String str1("Hello");
    String str2 = str1; // Constructor de copia
    String str3("World");
    str3 = str1; // Operador de asignación
    str1.print(); // Salida: Hello
    str2.print(); // Salida: Hello
    str3.print(); // Salida: Hello

    return 0;
}
<---Ejemplo Correcto Result--->
<---Ejemplo con `std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

int main() {
    std::unique_ptr<int> ptr = std::make_unique<int>(100); // Asignar memoria
    std::cout << *ptr << std::endl; // Salida: 100
    // Memoria se libera automáticamente cuando ptr sale del alcance

    return 0;
}
<---Ejemplo con `std::unique_ptr` Result--->
Regla de Cero, Tres y Cinco
Regla de Cero, Tres y Cinco Result
[[nodiscard]] para Prevenir Fugas (C++17)
[[nodiscard]] para Prevenir Fugas (C++17) Result
Gestión de Memoria con QObject en Qt
Gestión de Memoria con QObject en Qt Result
<---Regla de Cero, Tres y Cinco--->
```cpp
#include <iostream>
#include <string>
#include <memory>
#include <vector>

// REGLA DE CERO: Preferir tipos RAII
class PersonaModerna {
    std::string nombre_;
    std::vector<int> datos_;
    std::unique_ptr<int> extra_;
public:
    PersonaModerna(std::string nombre, int extra)
        : nombre_(std::move(nombre))
        , extra_(std::make_unique<int>(extra)) {}
    // NO necesitamos definir destructor, copy, move
};

// REGLA DE CINCO: Si defines uno, define los cinco
class BufferManual {
    int* datos_;
    size_t tam_;
public:
    BufferManual(size_t tam) : tam_(tam), datos_(new int[tam]{}) {}
    ~BufferManual() { delete[] datos_; }
    BufferManual(const BufferManual& otro) : tam_(otro.tam_), datos_(new int[otro.tam_]) {
        std::copy(otro.datos_, otro.datos_ + tam_, datos_);
    }
    BufferManual& operator=(const BufferManual& otro) {
        if (this != &otro) {
            BufferManual tmp(otro);
            std::swap(datos_, tmp.datos_);
            std::swap(tam_, tmp.tam_);
        }
        return *this;
    }
    BufferManual(BufferManual&& otro) noexcept
        : datos_(otro.datos_), tam_(otro.tam_) {
        otro.datos_ = nullptr; otro.tam_ = 0;
    }
    BufferManual& operator=(BufferManual&& otro) noexcept {
        if (this != &otro) {
            delete[] datos_;
            datos_ = otro.datos_; tam_ = otro.tam_;
            otro.datos_ = nullptr; otro.tam_ = 0;
        }
        return *this;
    }
};

int main() {
    PersonaModerna p("Ana", 42);
    BufferManual b1(100);
    BufferManual b2 = b1;
    BufferManual b3 = std::move(b1);
    return 0;
}
<---Regla de Cero, Tres y Cinco Result--->
<---[[nodiscard]] para Prevenir Fugas (C++17)--->
```cpp
#include <memory>
#include <iostream>

class Fabrica {
public:
    [[nodiscard]] static std::unique_ptr<int> crear(int valor) {
        return std::make_unique<int>(valor);
    }
};

int main() {
    auto ptr = Fabrica::crear(42);
    // Fabrica::crear(42); // Warning: resultado ignorado
    std::cout << *ptr << std::endl;
    return 0;
}
<---[[nodiscard]] para Prevenir Fugas (C++17) Result--->
<---Gestión de Memoria con QObject en Qt--->
```cpp
#include <QObject>
#include <QDebug>
#include <QScopedPointer>
#include <QSharedPointer>

class Servicio : public QObject {
    Q_OBJECT
public:
    explicit Servicio(QObject* parent = nullptr) : QObject(parent) {
        qDebug() << "Servicio creado";
    }
    ~Servicio() override { qDebug() << "Servicio destruido"; }
};

void gestionMemoriaQt() {
    // Modelo padre-hijo
    {
        auto* padre = new QObject();
        new Servicio(padre);
        delete padre; // Destruye hijos automáticamente
    }
    // QScopedPointer (equivalente de unique_ptr)
    {
        QScopedPointer<Servicio> servicio(new Servicio());
    }
    // QSharedPointer (equivalente de shared_ptr)
    {
        QSharedPointer<int> ptr1 = QSharedPointer<int>::create(42);
        QSharedPointer<int> ptr2 = ptr1;
        qDebug() << "Valor compartido:" << *ptr1;
    }
}
<---Gestión de Memoria con QObject en Qt Result--->
