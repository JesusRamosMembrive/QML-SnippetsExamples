<---EXPLANATION--->
### Fugas de Memoria en C++

Una fuga de memoria ocurre cuando un programa no libera la memoria que ha asignado dinámicamente, lo que puede llevar a un consumo excesivo de memoria y, eventualmente, al fallo del programa. En aplicaciones de larga duración o sistemas embebidos, las fugas de memoria pueden tener consecuencias graves.

#### ¿Qué es una Fuga de Memoria?

Una fuga de memoria se produce cuando la memoria que se ha asignado en el heap no se libera adecuadamente. Esto ocurre principalmente cuando se pierde la referencia al puntero que apunta a esa memoria, lo que impide que el programa la reutilice o la libere.

#### Ejemplos Comunes de Fugas de Memoria

##### Fuga de Memoria Simple

```cpp
#include <iostream>

void funcion() {
    int* ptr = new int(10); // Asignar memoria en el heap
    // ptr se pierde al salir de la función sin liberar la memoria
}

int main() {
    funcion();
    // La memoria asignada no se libera
    return 0;
}
```

##### Fuga de Memoria en un Bucle

```cpp
#include <iostream>

void funcion() {
    for (int i = 0; i < 10; ++i) {
        int* ptr = new int(i); // Asignar memoria en el heap en cada iteración
        // Sin delete, cada iteración causa una fuga de memoria
    }
}

int main() {
    funcion();
    return 0;
}
```

### Cómo Detectar y Evitar Fugas de Memoria

#### 1. Liberar Memoria Manualmente

Asegúrese de liberar toda la memoria asignada dinámicamente usando `delete` o `delete[]` cuando ya no se necesite.

```cpp
#include <iostream>

void funcion() {
    int* ptr = new int(10);
    // Usar ptr
    delete ptr; // Liberar la memoria
}

int main() {
    funcion();
    return 0;
}
```

#### 2. Uso de Smart Pointers

Los punteros inteligentes, introducidos en C++11, ayudan a gestionar automáticamente la vida útil de los objetos en el heap, evitando fugas de memoria.

##### `std::unique_ptr`

```cpp
#include <iostream>
#include <memory>

void funcion() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Memoria gestionada automáticamente
    // Usar ptr
}

int main() {
    funcion();
    return 0;
}
```

##### `std::shared_ptr`

```cpp
#include <iostream>
#include <memory>

void funcion() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad del recurso
    // Usar ptr1 y ptr2
}

int main() {
    funcion();
    return 0;
}
```

#### 3. Uso de Herramientas de Análisis de Memoria

Existen varias herramientas que pueden ayudar a detectar fugas de memoria en el código, tales como:

- **Valgrind**: Una herramienta de análisis de memoria que detecta fugas de memoria y errores de acceso a memoria.
- **AddressSanitizer**: Un runtime que detecta errores de memoria como desbordamientos de buffer y fugas de memoria.

##### Uso Básico de Valgrind

```sh
valgrind --leak-check=full ./mi_programa
```

### Ejemplos Avanzados

#### Fugas de Memoria en Clases

Las fugas de memoria pueden ser más complejas en clases, especialmente si las clases manejan recursos dinámicos.

##### Ejemplo de Clase con Fuga de Memoria

```cpp
#include <iostream>

class MiClase {
public:
    MiClase() {
        ptr_ = new int[10]; // Asignar memoria dinámica
    }
    ~MiClase() {
        // Falta delete[] ptr_, causando una fuga de memoria
    }

private:
    int* ptr_;
};

int main() {
    MiClase obj;
    return 0;
}
```

##### Solución con Destructor Correcto

```cpp
#include <iostream>

class MiClase {
public:
    MiClase() {
        ptr_ = new int[10]; // Asignar memoria dinámica
    }
    ~MiClase() {
        delete[] ptr_; // Liberar la memoria asignada
    }

private:
    int* ptr_;
};

int main() {
    MiClase obj;
    return 0;
}
```

#### Uso de Smart Pointers en Clases

Encapsular la gestión de memoria en clases usando punteros inteligentes.

```cpp
#include <iostream>
#include <memory>

class MiClase {
public:
    MiClase() {
        ptr_ = std::make_unique<int[]>(10); // Uso de unique_ptr
    }
    // No se necesita destructor explícito

private:
    std::unique_ptr<int[]> ptr_;
};

int main() {
    MiClase obj;
    return 0;
}
```

### Mejores Prácticas para Evitar Fugas de Memoria

1. **Usar Smart Pointers**: Siempre que sea posible, use `std::unique_ptr` y `std::shared_ptr` en lugar de punteros crudos.
2. **Liberar Memoria Manualmente**: Si usa `new`, asegúrese de emparejarlo siempre con `delete`.
3. **RAII (Resource Acquisition Is Initialization)**: Utilice el principio RAII para asegurar que los recursos se liberen cuando los objetos salen de su ámbito.
4. **Revisiones y Pruebas de Código**: Realice revisiones de código y pruebas exhaustivas para detectar y corregir fugas de memoria.
5. **Herramientas de Análisis**: Use herramientas como Valgrind y AddressSanitizer para detectar fugas de memoria y otros errores de memoria en su código.

### Características Modernas para Prevenir Fugas de Memoria

#### RAII como Prevención Fundamental

El patrón RAII es la principal defensa contra fugas de memoria. Si todos los recursos se encapsulan en objetos con destructores, las fugas son imposibles.

```cpp
#include <iostream>
#include <memory>
#include <vector>
#include <fstream>

// MAL: gestión manual propensa a fugas
void funcionInsegura() {
    int* datos = new int[1000];
    // Si se lanza una excepción aquí, la memoria se pierde
    throw std::runtime_error("Error!");
    delete[] datos; // Nunca se ejecuta
}

// BIEN: RAII previene fugas incluso con excepciones
void funcionSegura() {
    auto datos = std::make_unique<int[]>(1000);
    // Si se lanza una excepción, datos se destruye automáticamente
    throw std::runtime_error("Error!");
    // No necesitamos delete — el destructor de unique_ptr lo hace
}

// BIEN: usar contenedores RAII
void funcionConVectorSeguro() {
    std::vector<int> datos(1000); // RAII: se limpia solo
    // No importa cómo salgamos de la función
}

int main() {
    try {
        funcionSegura();
    } catch (const std::exception& e) {
        std::cout << "Excepción capturada: " << e.what() << std::endl;
        std::cout << "Pero no hubo fuga de memoria" << std::endl;
    }
    return 0;
}
```

#### Herramientas de Detección: ASan, LSan y Valgrind

```cpp
// Compilar con AddressSanitizer (ASan) — detecta fugas en tiempo de ejecución
// g++ -fsanitize=address -g programa.cpp -o programa
// clang++ -fsanitize=address -g programa.cpp -o programa
// MSVC: /fsanitize=address

// Compilar con LeakSanitizer (LSan) — solo detección de fugas
// g++ -fsanitize=leak -g programa.cpp -o programa

#include <iostream>

// Este programa tiene una fuga deliberada para demostrar ASan
int main() {
    int* fuga = new int(42);
    std::cout << *fuga << std::endl;
    // delete fuga; // Comentado para demostrar la detección

    // ASan reportará:
    // ==12345==ERROR: LeakSanitizer: detected memory leaks
    // Direct leak of 4 byte(s) in 1 object(s) allocated from:
    //     #0 ... in operator new(unsigned long)
    //     #1 ... in main programa.cpp:8

    return 0;
}
```

#### Equivalentes en Qt: Depuración de Fugas

```cpp
#include <QObject>
#include <QDebug>
#include <QCoreApplication>

class MiObjeto : public QObject {
    Q_OBJECT
public:
    explicit MiObjeto(const QString& nombre, QObject* parent = nullptr)
        : QObject(parent) {
        setObjectName(nombre);
    }
};

void depurarFugasQt() {
    auto* raiz = new QObject();
    raiz->setObjectName("Raíz");

    new MiObjeto("Hijo1", raiz);
    new MiObjeto("Hijo2", raiz);
    auto* nieto = new MiObjeto("Nieto", raiz->children().first());

    // dumpObjectTree() muestra la jerarquía de objetos — útil para detectar huérfanos
    raiz->dumpObjectTree();
    // Salida:
    // QObject::Raíz
    //   MiObjeto::Hijo1
    //     MiObjeto::Nieto
    //   MiObjeto::Hijo2

    // dumpObjectInfo() muestra conexiones de señales
    raiz->dumpObjectInfo();

    delete raiz; // Limpia todo el árbol

    // En Qt Creator: usar el profiler de memoria integrado
    // Tools → QML Profiler o Analyze → Valgrind Memory Analyzer
}
```

### Conclusión

Las fugas de memoria pueden tener efectos severos en el rendimiento y la estabilidad de un programa. Es crucial entender cómo se producen y adoptar buenas prácticas para prevenirlas. El uso de punteros inteligentes, la liberación manual de memoria y el uso de herramientas de análisis son estrategias efectivas para gestionar la memoria de manera eficiente y segura en C++. Al seguir estas prácticas, se puede escribir código más robusto y mantenible.
<---FILES--->
Fuga de Memoria Simple
Fuga de Memoria Simple Result
Fuga de Memoria en un Bucle
Fuga de Memoria en un Bucle Result
`std::unique_ptr`
`std::unique_ptr` Result
`std::shared_ptr`
`std::shared_ptr` Result
Uso Básico de Valgrind
Uso Básico de Valgrind Result
Ejemplo de Clase con Fuga de Memoria
Ejemplo de Clase con Fuga de Memoria Result
Solución con Destructor Correcto
Solución con Destructor Correcto Result
<---Fuga de Memoria Simple--->
```cpp
#include <iostream>

void funcion() {
    int* ptr = new int(10); // Asignar memoria en el heap
    // ptr se pierde al salir de la función sin liberar la memoria
}

int main() {
    funcion();
    // La memoria asignada no se libera
    return 0;
}
<---Fuga de Memoria Simple Result--->
<---Fuga de Memoria en un Bucle--->
```cpp
#include <iostream>

void funcion() {
    for (int i = 0; i < 10; ++i) {
        int* ptr = new int(i); // Asignar memoria en el heap en cada iteración
        // Sin delete, cada iteración causa una fuga de memoria
    }
}

int main() {
    funcion();
    return 0;
}
```cpp
#include <iostream>

void funcion() {
    int* ptr = new int(10);
    // Usar ptr
    delete ptr; // Liberar la memoria
}

int main() {
    funcion();
    return 0;
}
<---Fuga de Memoria en un Bucle Result--->
<---`std::unique_ptr`--->
```cpp
#include <iostream>
#include <memory>

void funcion() {
    std::unique_ptr<int> ptr = std::make_unique<int>(10); // Memoria gestionada automáticamente
    // Usar ptr
}

int main() {
    funcion();
    return 0;
}
<---`std::unique_ptr` Result--->
<---`std::shared_ptr`--->
```cpp
#include <iostream>
#include <memory>

void funcion() {
    std::shared_ptr<int> ptr1 = std::make_shared<int>(10);
    std::shared_ptr<int> ptr2 = ptr1; // Compartir la propiedad del recurso
    // Usar ptr1 y ptr2
}

int main() {
    funcion();
    return 0;
}
<---`std::shared_ptr` Result--->
<---Uso Básico de Valgrind--->
<---Uso Básico de Valgrind Result--->
<---Ejemplo de Clase con Fuga de Memoria--->
```cpp
#include <iostream>

class MiClase {
public:
    MiClase() {
        ptr_ = new int[10]; // Asignar memoria dinámica
    }
    ~MiClase() {
        // Falta delete[] ptr_, causando una fuga de memoria
    }

private:
    int* ptr_;
};

int main() {
    MiClase obj;
    return 0;
}
<---Ejemplo de Clase con Fuga de Memoria Result--->
<---Solución con Destructor Correcto--->
```cpp
#include <iostream>

class MiClase {
public:
    MiClase() {
        ptr_ = new int[10]; // Asignar memoria dinámica
    }
    ~MiClase() {
        delete[] ptr_; // Liberar la memoria asignada
    }

private:
    int* ptr_;
};

int main() {
    MiClase obj;
    return 0;
}
```cpp
#include <iostream>
#include <memory>

class MiClase {
public:
    MiClase() {
        ptr_ = std::make_unique<int[]>(10); // Uso de unique_ptr
    }
    // No se necesita destructor explícito

private:
    std::unique_ptr<int[]> ptr_;
};

int main() {
    MiClase obj;
    return 0;
}
<---Solución con Destructor Correcto Result--->
RAII como Prevención de Fugas
RAII como Prevención de Fugas Result
Detección con ASan y LSan
Detección con ASan y LSan Result
Depuración de Fugas en Qt
Depuración de Fugas en Qt Result
<---RAII como Prevención de Fugas--->
```cpp
#include <iostream>
#include <memory>
#include <vector>

// MAL: gestión manual propensa a fugas
void funcionInsegura() {
    int* datos = new int[1000];
    throw std::runtime_error("Error!");
    delete[] datos; // Nunca se ejecuta
}

// BIEN: RAII previene fugas incluso con excepciones
void funcionSegura() {
    auto datos = std::make_unique<int[]>(1000);
    throw std::runtime_error("Error!");
    // unique_ptr destruye automáticamente
}

int main() {
    try {
        funcionSegura();
    } catch (const std::exception& e) {
        std::cout << "Excepción: " << e.what() << std::endl;
        std::cout << "Sin fuga de memoria" << std::endl;
    }
    return 0;
}
<---RAII como Prevención de Fugas Result--->
<---Detección con ASan y LSan--->
```cpp
// Compilar con AddressSanitizer:
// g++ -fsanitize=address -g programa.cpp -o programa
// MSVC: /fsanitize=address

#include <iostream>

int main() {
    int* fuga = new int(42);
    std::cout << *fuga << std::endl;
    // delete fuga; // Fuga deliberada — ASan la detectará
    // ASan reportará: detected memory leaks
    return 0;
}
<---Detección con ASan y LSan Result--->
<---Depuración de Fugas en Qt--->
```cpp
#include <QObject>
#include <QDebug>

class MiObjeto : public QObject {
    Q_OBJECT
public:
    explicit MiObjeto(const QString& nombre, QObject* parent = nullptr)
        : QObject(parent) { setObjectName(nombre); }
};

void depurarFugasQt() {
    auto* raiz = new QObject();
    raiz->setObjectName("Raíz");
    new MiObjeto("Hijo1", raiz);
    new MiObjeto("Hijo2", raiz);

    // dumpObjectTree() muestra la jerarquía — útil para detectar huérfanos
    raiz->dumpObjectTree();
    // Salida:
    // QObject::Raíz
    //   MiObjeto::Hijo1
    //   MiObjeto::Hijo2

    delete raiz; // Limpia todo el árbol
}
<---Depuración de Fugas en Qt Result--->
