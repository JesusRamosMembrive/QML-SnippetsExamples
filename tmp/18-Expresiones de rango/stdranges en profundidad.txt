<---EXPLANATION--->
### std::ranges en Profundidad

La introducción de `std::ranges` en C++20 proporciona una forma unificada y poderosa de trabajar con secuencias de datos. Vamos a explorar en detalle algunas de las características clave, incluyendo adaptadores de vista (`std::views`), acciones de rango (`std::ranges::actions`), y conceptos de rango (`std::ranges::concepts`).

#### Adaptadores de Vista (`std::views`)

Los adaptadores de vista transforman o filtran los elementos de un rango sin copiar los datos subyacentes. Esto hace que las operaciones sean eficientes en términos de memoria y tiempo de ejecución.

##### Adaptadores Comunes

1. **`std::views::filter`**: Filtra elementos basados en un predicado.
2. **`std::views::transform`**: Transforma elementos aplicando una función.
3. **`std::views::take`**: Toma los primeros `n` elementos de un rango.
4. **`std::views::drop`**: Omite los primeros `n` elementos de un rango.
5. **`std::views::reverse`**: Invierte el orden de los elementos de un rango.
6. **`std::views::iota`**: Genera un rango de valores incrementales.
7. **`std::views::join`**: Une múltiples rangos en uno solo.
8. **`std::views::split`**: Divide un rango en subrangos.

##### Ejemplo con `std::views::filter` y `std::views::transform`

```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // Filtrar números pares y luego cuadrarlos
    auto even_squares = vec
                        | std::views::filter([](int n) { return n % 2 == 0; })
                        | std::views::transform([](int n) { return n * n; });

    // Mostrar los resultados
    std::cout << "Cuadrados de números pares: ";
    for (int n : even_squares) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo, usamos `std::views::filter` para filtrar los números pares y `std::views::transform` para cuadrar esos números. La combinación de estos adaptadores proporciona una manera concisa y eficiente de operar sobre el rango.

#### Acciones de Rango (`std::ranges::actions`)

Las acciones de rango permiten modificar los rangos directamente, ofreciendo una forma conveniente de aplicar transformaciones in situ.

##### Ejemplo con `std::ranges::actions::sort` y `std::ranges::actions::unique`

```cpp
#include <iostream>
#include <vector>
#include <ranges>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 3, 1, 4, 2, 2, 4, 3};

    // Ordenar y eliminar duplicados
    auto result = vec
                  | std::views::all
                  | std::ranges::actions::sort
                  | std::ranges::actions::unique;

    // Mostrar los resultados
    std::cout << "Elementos ordenados y únicos: ";
    for (int n : result) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo, usamos `std::ranges::actions::sort` para ordenar el rango y `std::ranges::actions::unique` para eliminar elementos duplicados.

#### Conceptos de Rango (`std::ranges::concepts`)

Los conceptos de rango proporcionan una forma de definir y verificar las propiedades que deben cumplir los rangos y sus adaptadores. Algunos conceptos importantes son:

- **`std::ranges::range`**: Indica que un tipo es un rango.
- **`std::ranges::view`**: Indica que un tipo es una vista.
- **`std::ranges::sized_range`**: Indica que un rango tiene un tamaño conocido.
- **`std::ranges::input_range`**: Indica que un rango puede ser leído desde el principio al final.
- **`std::ranges::forward_range`**: Indica que un rango puede ser recorrido múltiples veces.
- **`std::ranges::bidirectional_range`**: Indica que un rango puede ser recorrido hacia adelante y hacia atrás.
- **`std::ranges::random_access_range`**: Indica que un rango permite acceso aleatorio.

##### Ejemplo de Comprobación de Conceptos

```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    static_assert(std::ranges::range<std::vector<int>>, "std::vector<int> es un rango");
    static_assert(std::ranges::view<std::ranges::iota_view<int>>, "std::ranges::iota_view<int> es una vista");
    static_assert(std::ranges::sized_range<std::vector<int>>, "std::vector<int> es un rango con tamaño conocido");
    static_assert(std::ranges::random_access_range<std::vector<int>>, "std::vector<int> permite acceso aleatorio");

    std::cout << "Todos los conceptos se verificaron correctamente." << std::endl;

    return 0;
}
```

En este ejemplo, usamos `static_assert` para verificar que `std::vector<int>` cumple con varios conceptos de rango.

### Ejemplos Adicionales

#### Uso de `std::views::take_while`

```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // Tomar elementos mientras sean menores o iguales a 5
    auto taken = vec | std::views::take_while([](int n) { return n <= 5; });

    // Mostrar los elementos tomados
    std::cout << "Elementos tomados: ";
    for (int n : taken) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo, `std::views::take_while` toma los elementos de `vec` mientras la condición `n <= 5` sea verdadera.

#### Uso de `std::views::join` para Unir Rangos

```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<std::vector<int>> vec_of_vecs = {{1, 2, 3}, {4, 5}, {6, 7, 8, 9}};

    // Unir todos los subrangos en un solo rango
    auto joined = vec_of_vecs | std::views::join;

    // Mostrar los elementos unidos
    std::cout << "Elementos unidos: ";
    for (int n : joined) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo, `std::views::join` une todos los subrangos de `vec_of_vecs` en un solo rango.

### Conclusión

Las expresiones de rango y `std::ranges` en C++20 introducen una manera poderosa y flexible de trabajar con secuencias de datos. Los adaptadores de vista permiten transformar y filtrar datos de manera eficiente, mientras que las acciones de rango proporcionan herramientas para modificar los rangos directamente. Los conceptos de rango ayudan a definir y verificar las propiedades de los rangos y sus adaptadores, mejorando la capacidad de comprobación y documentación del código. Utilizar estas características puede simplificar significativamente la manipulación de secuencias en C++.
<---FILES--->
Adaptadores Comunes
Adaptadores Comunes Result
Ejemplo con `std::views::filter` y `std::views::transform`
Ejemplo con `std::views::filter` y `std::views::transform` Result
Ejemplo con `std::ranges::actions::sort` y `std::ranges::actions::unique`
Ejemplo con `std::ranges::actions::sort` y `std::ranges::actions::unique` Result
Ejemplo de Comprobación de Conceptos
Ejemplo de Comprobación de Conceptos Result
<---Adaptadores Comunes--->
<---Adaptadores Comunes Result--->
<---Ejemplo con `std::views::filter` y `std::views::transform`--->
```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // Filtrar números pares y luego cuadrarlos
    auto even_squares = vec
                        | std::views::filter([](int n) { return n % 2 == 0; })
                        | std::views::transform([](int n) { return n * n; });

    // Mostrar los resultados
    std::cout << "Cuadrados de números pares: ";
    for (int n : even_squares) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::views::filter` y `std::views::transform` Result--->
<---Ejemplo con `std::ranges::actions::sort` y `std::ranges::actions::unique`--->
```cpp
#include <iostream>
#include <vector>
#include <ranges>
#include <algorithm>

int main() {
    std::vector<int> vec = {5, 3, 1, 4, 2, 2, 4, 3};

    // Ordenar y eliminar duplicados
    auto result = vec
                  | std::views::all
                  | std::ranges::actions::sort
                  | std::ranges::actions::unique;

    // Mostrar los resultados
    std::cout << "Elementos ordenados y únicos: ";
    for (int n : result) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo con `std::ranges::actions::sort` y `std::ranges::actions::unique` Result--->
<---Ejemplo de Comprobación de Conceptos--->
```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    static_assert(std::ranges::range<std::vector<int>>, "std::vector<int> es un rango");
    static_assert(std::ranges::view<std::ranges::iota_view<int>>, "std::ranges::iota_view<int> es una vista");
    static_assert(std::ranges::sized_range<std::vector<int>>, "std::vector<int> es un rango con tamaño conocido");
    static_assert(std::ranges::random_access_range<std::vector<int>>, "std::vector<int> permite acceso aleatorio");

    std::cout << "Todos los conceptos se verificaron correctamente." << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // Tomar elementos mientras sean menores o iguales a 5
    auto taken = vec | std::views::take_while([](int n) { return n <= 5; });

    // Mostrar los elementos tomados
    std::cout << "Elementos tomados: ";
    for (int n : taken) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    return 0;
}
```cpp
#include <iostream>
#include <vector>
#include <ranges>

int main() {
    std::vector<std::vector<int>> vec_of_vecs = {{1, 2, 3}, {4, 5}, {6, 7, 8, 9}};

    // Unir todos los subrangos en un solo rango
    auto joined = vec_of_vecs | std::views::join;

    // Mostrar los elementos unidos
    std::cout << "Elementos unidos: ";
    for (int n : joined) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Comprobación de Conceptos Result--->
