<---EXPLANATION--->
### Definición y Propósito de los Namespaces en C++

En C++, un namespace (espacio de nombres) es una directiva utilizada para organizar el código y evitar conflictos de nombres. Los namespaces permiten agrupar funciones, variables, clases y otros identificadores en un contexto específico, evitando colisiones de nombres que pueden ocurrir cuando diferentes partes del programa definen elementos con el mismo nombre.

#### Definición de Namespace

Un namespace se define utilizando la palabra clave `namespace` seguida del nombre del espacio de nombres y un bloque de código que contiene las definiciones de los identificadores que pertenecen a ese espacio de nombres.

##### Sintaxis

```cpp
namespace nombre_del_namespace {
    // Definiciones de variables, funciones, clases, etc.
}
```

##### Ejemplo

```cpp
#include <iostream>
using namespace std;

namespace Matematicas {
    const double PI = 3.141592653589793;

    double cuadrado(double x) {
        return x * x;
    }

    double areaCirculo(double radio) {
        return PI * cuadrado(radio);
    }
}

int main() {
    double radio = 5.0;
    cout << "El área del círculo con radio " << radio << " es " << Matematicas::areaCirculo(radio) << endl;
    return 0;
}
```

En este ejemplo:
- El namespace `Matematicas` contiene una constante `PI` y dos funciones, `cuadrado` y `areaCirculo`.
- En el `main`, se accede a `areaCirculo` utilizando el prefijo `Matematicas::` para evitar colisiones de nombres y especificar claramente de qué espacio de nombres provienen.

#### Propósito de los Namespaces

1. **Evitar Conflictos de Nombres:** Al organizar el código en namespaces, se pueden evitar conflictos de nombres que ocurren cuando dos partes diferentes del programa definen identificadores con el mismo nombre.
2. **Organización del Código:** Permiten agrupar lógicamente las definiciones relacionadas, mejorando la legibilidad y el mantenimiento del código.
3. **Modularidad:** Facilitan la modularidad del código, permitiendo dividir un programa grande en partes más manejables y coherentes.
4. **Integración de Librerías:** Ayudan a integrar múltiples librerías en un mismo programa sin que los nombres de sus componentes colisionen.

#### Uso de Namespaces

1. **Acceso a Miembros de un Namespace:** Los miembros de un namespace se acceden utilizando el operador de resolución de ámbito `::`.

##### Ejemplo

```cpp
namespace Ejemplo {
    void funcion() {
        std::cout << "Función en el namespace Ejemplo" << std::endl;
    }
}

int main() {
    Ejemplo::funcion(); // Llamada a la función utilizando el operador de resolución de ámbito
    return 0;
}
```

2. **Declaración de Usos (`using`):** La directiva `using` se puede utilizar para traer todos los miembros de un namespace al ámbito actual, evitando la necesidad de usar el operador de resolución de ámbito repetidamente.

##### Ejemplo

```cpp
#include <iostream>
using namespace std;

namespace Matematicas {
    double suma(double a, double b) {
        return a + b;
    }
}

using namespace Matematicas;

int main() {
    cout << "La suma de 3 y 4 es " << suma(3, 4) << endl; // No necesita Matematicas::
    return 0;
}
```

3. **Alias de Namespace:** Se pueden crear alias para namespaces largos o anidados, facilitando su uso.

##### Ejemplo

```cpp
namespace Empresa {
    namespace Departamento {
        namespace Proyecto {
            void mostrarMensaje() {
                std::cout << "Mensaje del proyecto" << std::endl;
            }
        }
    }
}

// Crear un alias para un namespace largo
namespace Proyecto = Empresa::Departamento::Proyecto;

int main() {
    Proyecto::mostrarMensaje(); // Usando el alias para llamar a la función
    return 0;
}
```

#### Namespaces Anónimos

Los namespaces anónimos se utilizan para definir miembros que deben tener alcance en el archivo (file scope) y no deben ser accesibles desde otros archivos, lo cual es útil para evitar colisiones de nombres en programas grandes.

##### Ejemplo

```cpp
#include <iostream>

namespace {
    void funcionPrivada() {
        std::cout << "Función en el namespace anónimo" << std::endl;
    }
}

int main() {
    funcionPrivada(); // Llamada válida dentro del mismo archivo
    return 0;
}
```

En este ejemplo, `funcionPrivada` solo es accesible dentro del archivo donde se define, ya que está en un namespace anónimo.

#### `inline namespace` (C++11): Versionado de APIs

A partir de C++11, se introdujo el concepto de `inline namespace`. Un `inline namespace` hace que todos sus miembros sean accesibles como si estuvieran directamente en el namespace que lo contiene. Esto es especialmente útil para el **versionado de APIs**: se pueden mantener múltiples versiones de una biblioteca y seleccionar cuál es la versión predeterminada marcándola como `inline`.

Cuando un namespace se declara como `inline`, el compilador permite acceder a sus miembros tanto con el nombre completo como sin el nivel intermedio del namespace inline. Las versiones anteriores siguen disponibles usando su calificador completo.

##### Ejemplo de inline namespace para Versionado

```cpp
#include <iostream>

namespace Graficos {
    namespace v1 {
        void renderizar() {
            std::cout << "Graficos v1: Renderizado básico con rasterización" << std::endl;
        }
    }

    // La versión 2 es la predeterminada gracias a 'inline'
    inline namespace v2 {
        void renderizar() {
            std::cout << "Graficos v2: Renderizado avanzado con ray tracing" << std::endl;
        }
    }
}

int main() {
    // Usa v2 automáticamente (es el inline namespace)
    Graficos::renderizar();

    // Se puede acceder explícitamente a v1 si se necesita
    Graficos::v1::renderizar();

    // También se puede acceder explícitamente a v2
    Graficos::v2::renderizar();

    return 0;
}
```

En este ejemplo:
- `Graficos::v2` está marcado como `inline`, por lo que `Graficos::renderizar()` llama a la versión v2 automáticamente.
- Los usuarios que necesiten la versión anterior pueden usar `Graficos::v1::renderizar()` explícitamente.
- Este patrón es el estándar para versionado de APIs en bibliotecas de C++ moderno.

#### Módulos en C++20: El Futuro de la Organización de Código

C++20 introdujo los **módulos**, una nueva forma de organizar y compartir código que complementa y en muchos casos puede reemplazar el modelo tradicional de namespaces + archivos de cabecera (`#include`). Los módulos ofrecen varias ventajas significativas:

1. **Mejor encapsulación:** Solo se exporta lo que se declara explícitamente con `export`, a diferencia de los headers donde todo lo incluido es visible.
2. **Compilación más rápida:** Los módulos se compilan una sola vez y se reutilizan, eliminando la recompilación repetida de headers.
3. **Sin problemas de headers:** No hay dependencias de orden de inclusión, guardas de inclusión (`#pragma once` / `#ifndef`), ni macros que se filtren entre archivos.
4. **Independencia del preprocesador:** Los módulos no dependen de `#include` ni del preprocesador de C.

##### Ejemplo de Módulos en C++20

```cpp
// --- Archivo: matematicas.cppm (declaración del módulo) ---
export module Matematicas;

export const double PI = 3.141592653589793;

export double cuadrado(double x) {
    return x * x;
}

export double areaCirculo(double radio) {
    return PI * cuadrado(radio);
}

// --- Archivo: main.cpp (uso del módulo) ---
import Matematicas;
#include <iostream>

int main() {
    double radio = 5.0;
    std::cout << "El área del círculo con radio " << radio
              << " es " << areaCirculo(radio) << std::endl;
    // Se accede directamente a las funciones exportadas
    std::cout << "PI = " << PI << std::endl;
    return 0;
}
```

En este ejemplo:
- `export module Matematicas;` declara un módulo llamado `Matematicas`.
- Las funciones y constantes marcadas con `export` son accesibles desde otros archivos que importen el módulo.
- `import Matematicas;` importa el módulo sin necesidad de `#include` ni archivos de cabecera.
- Los módulos y los namespaces pueden usarse juntos: un módulo puede contener namespaces internos para organizar su contenido.

### Conclusión

Los namespaces en C++ son una herramienta poderosa para organizar el código y evitar conflictos de nombres. Permiten agrupar definiciones relacionadas, mejorar la modularidad y la mantenibilidad del código, y facilitar la integración de múltiples librerías en un programa. Utilizar namespaces de manera adecuada es crucial para escribir código limpio, organizado y libre de colisiones de nombres.
<---FILES--->
Sintaxis
Sintaxis Result
Ejemplo
Ejemplo Result
Ejemplo de inline namespace para Versionado
Ejemplo de inline namespace para Versionado Result
Ejemplo de Módulos en C++20
Ejemplo de Módulos en C++20 Result
<---Sintaxis--->
```cpp
namespace nombre_del_namespace {
    // Definiciones de variables, funciones, clases, etc.
}
<---Sintaxis Result--->
<---Ejemplo--->
```cpp
#include <iostream>

namespace {
    void funcionPrivada() {
        std::cout << "Función en el namespace anónimo" << std::endl;
    }
}

int main() {
    funcionPrivada(); // Llamada válida dentro del mismo archivo
    return 0;
}
<---Ejemplo Result--->
<---Ejemplo de inline namespace para Versionado--->
```cpp
#include <iostream>

namespace Graficos {
    namespace v1 {
        void renderizar() {
            std::cout << "Graficos v1: Renderizado básico con rasterización" << std::endl;
        }
    }

    // La versión 2 es la predeterminada gracias a 'inline'
    inline namespace v2 {
        void renderizar() {
            std::cout << "Graficos v2: Renderizado avanzado con ray tracing" << std::endl;
        }
    }
}

int main() {
    // Usa v2 automáticamente (es el inline namespace)
    Graficos::renderizar();

    // Se puede acceder explícitamente a v1 si se necesita
    Graficos::v1::renderizar();

    // También se puede acceder explícitamente a v2
    Graficos::v2::renderizar();

    return 0;
}
<---Ejemplo de inline namespace para Versionado Result--->
<---Ejemplo de Módulos en C++20--->
```cpp
// --- Archivo: matematicas.cppm (declaración del módulo) ---
export module Matematicas;

export const double PI = 3.141592653589793;

export double cuadrado(double x) {
    return x * x;
}

export double areaCirculo(double radio) {
    return PI * cuadrado(radio);
}

// --- Archivo: main.cpp (uso del módulo) ---
import Matematicas;
#include <iostream>

int main() {
    double radio = 5.0;
    std::cout << "El área del círculo con radio " << radio
              << " es " << areaCirculo(radio) << std::endl;
    // Se accede directamente a las funciones exportadas
    std::cout << "PI = " << PI << std::endl;
    return 0;
}
<---Ejemplo de Módulos en C++20 Result--->
