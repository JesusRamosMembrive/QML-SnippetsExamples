<---EXPLANATION--->
### Namespace Estándar `std` en C++

El namespace `std` (abreviatura de "standard") es un namespace especial en C++ que contiene todas las definiciones de la Biblioteca Estándar de C++. Esto incluye clases, funciones, objetos, y otros elementos definidos en la librería estándar del lenguaje. El uso del namespace `std` es fundamental para aprovechar las funcionalidades que ofrece C++.

#### Elementos Clave en el Namespace `std`

1. **Contenedores:** Clases que almacenan y organizan datos, como `vector`, `list`, `map`, `set`, etc.
2. **Algoritmos:** Funciones que operan en contenedores, como `sort`, `find`, `copy`, etc.
3. **Funciones de Entrada/Salida:** Clases y funciones para manejar la entrada y salida, como `cout`, `cin`, `ifstream`, `ofstream`, etc.
4. **Cadenas de Caracteres:** Clases y funciones para manipular cadenas, como `string`.
5. **Utilidades de Función:** Funciones y clases auxiliares, como `pair`, `tuple`, `function`, etc.

#### Uso del Namespace `std`

Para utilizar las definiciones dentro del namespace `std`, hay dos enfoques comunes: usar el operador de resolución de ámbito `::` o la directiva `using`.

##### Uso con el Operador de Resolución de Ámbito

El operador de resolución de ámbito `::` se utiliza para acceder a los miembros del namespace `std` especificando el nombre del namespace seguido de `::` y el nombre del miembro.

###### Ejemplo

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};

    for (int num : numeros) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::vector` y `std::cout` se utilizan para acceder a las definiciones de `vector` y `cout` dentro del namespace `std`.

##### Uso de la Directiva `using`

La directiva `using` puede simplificar el código al traer todos los miembros de un namespace al ámbito actual, evitando la necesidad de usar el operador de resolución de ámbito repetidamente.

###### Ejemplo

```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> numeros = {1, 2, 3, 4, 5};

    for (int num : numeros) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
```

En este ejemplo, `using namespace std` permite usar `vector` y `cout` directamente sin el prefijo `std::`.

#### Consideraciones sobre el Uso de `using namespace std`

Aunque la directiva `using namespace std` puede simplificar el código, su uso indiscriminado en archivos de cabecera (`.h`) y grandes proyectos puede llevar a conflictos de nombres y ambigüedades. Es una buena práctica limitar su uso a los archivos de implementación (`.cpp`) y evitarlo en los archivos de cabecera para mantener un código limpio y evitar problemas de nombres.

##### Ejemplo de Problema con `using namespace std`

```cpp
// En un archivo de cabecera (.h)
#include <iostream>
using namespace std;

void mostrarMensaje() {
    cout << "Hola, mundo!" << endl;
}
```

En este ejemplo, `using namespace std` en un archivo de cabecera puede causar problemas si otro archivo incluye este archivo de cabecera y tiene sus propios nombres que pueden entrar en conflicto con los de `std`.

#### Componentes Principales en el Namespace `std`

1. **Contenedores:**
   - `vector`: Un arreglo dinámico.
   - `list`: Una lista doblemente enlazada.
   - `map`: Un contenedor asociativo de pares clave-valor ordenados.
   - `set`: Un contenedor de elementos únicos ordenados.

###### Ejemplo de Uso de `vector`

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};
    numeros.push_back(6);

    for (int num : numeros) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

2. **Algoritmos:**
   - `sort`: Ordena los elementos en un rango.
   - `find`: Encuentra un elemento en un rango.

###### Ejemplo de Uso de `sort`

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 3, 4, 1, 2};
    std::sort(numeros.begin(), numeros.end());

    for (int num : numeros) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

3. **Funciones de Entrada/Salida:**
   - `cout`: Para salida estándar.
   - `cin`: Para entrada estándar.
   - `ifstream`: Para leer de archivos.
   - `ofstream`: Para escribir en archivos.

###### Ejemplo de Uso de `ifstream`

```cpp
#include <iostream>
#include <fstream>
#include <string>

int main() {
    std::ifstream archivo("ejemplo.txt");
    std::string linea;

    if (archivo.is_open()) {
        while (getline(archivo, linea)) {
            std::cout << linea << std::endl;
        }
        archivo.close();
    } else {
        std::cout << "No se pudo abrir el archivo." << std::endl;
    }

    return 0;
}
```

4. **Cadenas de Caracteres:**
   - `string`: Clase para manipulación de cadenas.

###### Ejemplo de Uso de `string`

```cpp
#include <iostream>
#include <string>

int main() {
    std::string saludo = "Hola, ";
    saludo += "mundo!";
    std::cout << saludo << std::endl;

    return 0;
}
```

5. **Utilidades de Función:**
   - `pair`: Para almacenar un par de valores.
   - `tuple`: Para almacenar un conjunto de valores.
   - `function`: Para almacenar y usar funciones.

###### Ejemplo de Uso de `pair`

```cpp
#include <iostream>
#include <utility>

int main() {
    std::pair<int, std::string> par(1, "uno");
    std::cout << "Clave: " << par.first << ", Valor: " << par.second << std::endl;

    return 0;
}
```

#### `std::ranges` y `std::views` (C++20)

C++20 introdujo el namespace `std::ranges` con versiones mejoradas de los algoritmos clásicos y `std::views` para **adaptadores de rango perezosos** (lazy range adaptors). La diferencia principal es que `std::ranges` acepta contenedores directamente (sin necesidad de `.begin()` y `.end()`), y los views permiten componer transformaciones de datos de forma declarativa sin crear copias intermedias.

##### Ejemplo de `std::ranges` y `std::views`

```cpp
#include <iostream>
#include <vector>
#include <ranges>
#include <algorithm>

int main() {
    std::vector<int> numeros = {8, 3, 15, 1, 22, 7, 10, 4, 18, 6};

    // =============================================
    // Comparación: algoritmos clásicos vs std::ranges
    // =============================================

    // Clásico: requiere iteradores begin/end
    std::sort(numeros.begin(), numeros.end());

    // C++20 ranges: acepta el contenedor directamente
    std::ranges::sort(numeros);

    std::cout << "Ordenados: ";
    for (int n : numeros) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    // Búsqueda con ranges
    auto it = std::ranges::find(numeros, 10);
    if (it != numeros.end()) {
        std::cout << "Encontrado: " << *it << std::endl;
    }

    // =============================================
    // std::views: composición de transformaciones perezosas
    // =============================================

    // Filtrar pares y multiplicar por 10, sin copias intermedias
    auto resultado = numeros
        | std::views::filter([](int n) { return n % 2 == 0; })
        | std::views::transform([](int n) { return n * 10; });

    std::cout << "Pares x10: ";
    for (int n : resultado) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    // Tomar los primeros 3 elementos
    std::cout << "Primeros 3: ";
    for (int n : numeros | std::views::take(3)) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    // Cadena compleja: saltar 2, tomar 4, filtrar impares
    auto cadena = numeros
        | std::views::drop(2)
        | std::views::take(4)
        | std::views::filter([](int n) { return n % 2 != 0; });

    std::cout << "Cadena compuesta: ";
    for (int n : cadena) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

En este ejemplo:
- `std::ranges::sort(numeros)` es más limpio que `std::sort(numeros.begin(), numeros.end())`.
- Los `std::views` son perezosos: no crean vectores intermedios, sino que transforman los datos sobre la marcha al iterar.
- El operador `|` (pipe) permite encadenar vistas de forma legible y declarativa.

#### `std::chrono`: Manejo de Tiempo en la STL

El namespace `std::chrono` proporciona un sistema completo para el manejo de tiempo en C++. Incluye tipos para duraciones (`duration`), puntos en el tiempo (`time_point`), y relojes (`system_clock`, `steady_clock`, `high_resolution_clock`). C++20 agregó soporte para calendarios y zonas horarias.

##### Ejemplo de `std::chrono`

```cpp
#include <iostream>
#include <chrono>
#include <thread>
#include <vector>
#include <algorithm>
#include <numeric>

int main() {
    // =============================================
    // Medir tiempo de ejecución con steady_clock
    // =============================================
    auto inicio = std::chrono::steady_clock::now();

    // Operación a medir: llenar y ordenar un vector grande
    std::vector<int> datos(100000);
    std::iota(datos.begin(), datos.end(), 0);  // Llenar con 0, 1, 2, ...
    std::sort(datos.rbegin(), datos.rend());    // Ordenar en reversa
    std::sort(datos.begin(), datos.end());      // Ordenar de nuevo

    auto fin = std::chrono::steady_clock::now();

    // Calcular duración en diferentes unidades
    auto duracionMs = std::chrono::duration_cast<std::chrono::milliseconds>(fin - inicio);
    auto duracionUs = std::chrono::duration_cast<std::chrono::microseconds>(fin - inicio);

    std::cout << "Tiempo de ejecución: " << duracionMs.count() << " ms" << std::endl;
    std::cout << "Tiempo de ejecución: " << duracionUs.count() << " µs" << std::endl;

    // =============================================
    // Trabajar con duraciones tipadas
    // =============================================
    using namespace std::chrono_literals;  // Habilita sufijos como 500ms, 2s, etc.

    auto espera = 100ms;
    auto timeout = 2s;
    auto preciso = 1500us;

    std::cout << "Espera: " << espera.count() << " ms" << std::endl;
    std::cout << "Timeout: " << timeout.count() << " s" << std::endl;

    // Conversión entre unidades
    auto enMicrosegundos = std::chrono::duration_cast<std::chrono::microseconds>(timeout);
    std::cout << "Timeout en µs: " << enMicrosegundos.count() << std::endl;

    // =============================================
    // Fecha y hora actual con system_clock
    // =============================================
    auto ahora = std::chrono::system_clock::now();
    std::time_t tiempo = std::chrono::system_clock::to_time_t(ahora);
    std::cout << "Fecha y hora actual: " << std::ctime(&tiempo);

    return 0;
}
```

En este ejemplo:
- `steady_clock` es ideal para medir duraciones porque no se ve afectado por ajustes del reloj del sistema.
- `duration_cast` convierte entre distintas unidades de tiempo (milisegundos, microsegundos, etc.).
- Los literales `100ms`, `2s`, `1500us` proporcionan una forma expresiva de crear duraciones.
- `system_clock` se usa para obtener la fecha/hora actual del sistema.

#### Extensión del Namespace `std`: Reglas y Especialización

Agregar nuevas declaraciones al namespace `std` (funciones, clases, variables) es **comportamiento indefinido** según el estándar de C++. Sin embargo, **especializar plantillas existentes** de `std` para tipos definidos por el usuario **sí está permitido**. Los casos más comunes son especializar `std::hash` (para usar tipos propios en `unordered_set`/`unordered_map`) y `std::formatter` (para formateo con `std::format` en C++20).

##### Ejemplo de Especialización de `std::hash`

```cpp
#include <iostream>
#include <unordered_set>
#include <functional>
#include <string>

// Clase definida por el usuario
struct Punto {
    double x;
    double y;

    // Operador de igualdad (requerido por unordered_set)
    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

// =============================================
// PERMITIDO: Especializar std::hash para Punto
// =============================================
template<>
struct std::hash<Punto> {
    std::size_t operator()(const Punto& p) const noexcept {
        // Combinar hashes de cada miembro
        std::size_t h1 = std::hash<double>{}(p.x);
        std::size_t h2 = std::hash<double>{}(p.y);
        // Técnica de combinación de hashes
        return h1 ^ (h2 << 1);
    }
};

// Función auxiliar para mostrar un Punto
std::ostream& operator<<(std::ostream& os, const Punto& p) {
    return os << "(" << p.x << ", " << p.y << ")";
}

int main() {
    // Ahora Punto se puede usar en unordered_set gracias a std::hash<Punto>
    std::unordered_set<Punto> puntos;

    puntos.insert({1.0, 2.0});
    puntos.insert({3.0, 4.0});
    puntos.insert({1.0, 2.0});  // Duplicado, no se inserta
    puntos.insert({5.0, 6.0});

    std::cout << "Puntos en el conjunto (" << puntos.size() << "):" << std::endl;
    for (const auto& p : puntos) {
        std::cout << "  " << p << std::endl;
    }

    // Verificar si un punto existe
    Punto buscar{3.0, 4.0};
    if (puntos.count(buscar)) {
        std::cout << "El punto " << buscar << " existe en el conjunto" << std::endl;
    }

    // =============================================
    // PROHIBIDO (comportamiento indefinido):
    // namespace std {
    //     void miFuncion() { }         // NO: agregar función nueva
    //     class MiClase { };            // NO: agregar clase nueva
    // }
    // =============================================

    return 0;
}
```

En este ejemplo:
- `std::hash<Punto>` es una especialización **válida** de una plantilla existente en `std`.
- La especialización permite usar `Punto` como clave en `std::unordered_set` y `std::unordered_map`.
- Se muestra qué operaciones sobre `std` están prohibidas (agregar funciones o clases nuevas).
- La técnica de combinación de hashes (`h1 ^ (h2 << 1)`) es un patrón común para tipos compuestos.

### Conclusión

El namespace `std` en C++ es esencial para acceder a las numerosas funcionalidades proporcionadas por la Biblioteca Estándar de C++. Utilizar correctamente el namespace `std` mediante el operador de resolución de ámbito o la directiva `using` puede simplificar y mejorar la legibilidad del código. Sin embargo, se debe tener cuidado con el uso indiscriminado de `using namespace std` en archivos de cabecera para evitar conflictos de nombres y mantener un código limpio y mantenible.
<---FILES--->
Uso con el Operador de Resolución de Ámbito
Uso con el Operador de Resolución de Ámbito Result
Ejemplo
Ejemplo Result
Uso de la Directiva `using`
Uso de la Directiva `using` Result
Ejemplo de Problema con `using namespace std`
Ejemplo de Problema con `using namespace std` Result
Ejemplo de Uso de `vector`
Ejemplo de Uso de `vector` Result
Ejemplo de Uso de `sort`
Ejemplo de Uso de `sort` Result
Ejemplo de Uso de `ifstream`
Ejemplo de Uso de `ifstream` Result
Ejemplo de Uso de `string`
Ejemplo de Uso de `string` Result
Ejemplo de Uso de `pair`
Ejemplo de Uso de `pair` Result
Ejemplo de `std::ranges` y `std::views`
Ejemplo de `std::ranges` y `std::views` Result
Ejemplo de `std::chrono`
Ejemplo de `std::chrono` Result
Ejemplo de Especialización de `std::hash`
Ejemplo de Especialización de `std::hash` Result
<---Uso con el Operador de Resolución de Ámbito--->
<---Uso con el Operador de Resolución de Ámbito Result--->
<---Ejemplo--->
```cpp
#include <iostream>
#include <vector>

using namespace std;

int main() {
    vector<int> numeros = {1, 2, 3, 4, 5};

    for (int num : numeros) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}
<---Ejemplo Result--->
<---Uso de la Directiva `using`--->
<---Uso de la Directiva `using` Result--->
<---Ejemplo de Problema con `using namespace std`--->
```cpp
// En un archivo de cabecera (.h)
#include <iostream>
using namespace std;

void mostrarMensaje() {
    cout << "Hola, mundo!" << endl;
}
<---Ejemplo de Problema con `using namespace std` Result--->
<---Ejemplo de Uso de `vector`--->
```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> numeros = {1, 2, 3, 4, 5};
    numeros.push_back(6);

    for (int num : numeros) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Uso de `vector` Result--->
<---Ejemplo de Uso de `sort`--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numeros = {5, 3, 4, 1, 2};
    std::sort(numeros.begin(), numeros.end());

    for (int num : numeros) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de Uso de `sort` Result--->
<---Ejemplo de Uso de `ifstream`--->
```cpp
#include <iostream>
#include <fstream>
#include <string>

int main() {
    std::ifstream archivo("ejemplo.txt");
    std::string linea;

    if (archivo.is_open()) {
        while (getline(archivo, linea)) {
            std::cout << linea << std::endl;
        }
        archivo.close();
    } else {
        std::cout << "No se pudo abrir el archivo." << std::endl;
    }

    return 0;
}
<---Ejemplo de Uso de `ifstream` Result--->
<---Ejemplo de Uso de `string`--->
```cpp
#include <iostream>
#include <string>

int main() {
    std::string saludo = "Hola, ";
    saludo += "mundo!";
    std::cout << saludo << std::endl;

    return 0;
}
<---Ejemplo de Uso de `string` Result--->
<---Ejemplo de Uso de `pair`--->
```cpp
#include <iostream>
#include <utility>

int main() {
    std::pair<int, std::string> par(1, "uno");
    std::cout << "Clave: " << par.first << ", Valor: " << par.second << std::endl;

    return 0;
}
<---Ejemplo de Uso de `pair` Result--->
<---Ejemplo de `std::ranges` y `std::views`--->
```cpp
#include <iostream>
#include <vector>
#include <ranges>
#include <algorithm>

int main() {
    std::vector<int> numeros = {8, 3, 15, 1, 22, 7, 10, 4, 18, 6};

    // =============================================
    // Comparación: algoritmos clásicos vs std::ranges
    // =============================================

    // Clásico: requiere iteradores begin/end
    std::sort(numeros.begin(), numeros.end());

    // C++20 ranges: acepta el contenedor directamente
    std::ranges::sort(numeros);

    std::cout << "Ordenados: ";
    for (int n : numeros) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    // Búsqueda con ranges
    auto it = std::ranges::find(numeros, 10);
    if (it != numeros.end()) {
        std::cout << "Encontrado: " << *it << std::endl;
    }

    // =============================================
    // std::views: composición de transformaciones perezosas
    // =============================================

    // Filtrar pares y multiplicar por 10, sin copias intermedias
    auto resultado = numeros
        | std::views::filter([](int n) { return n % 2 == 0; })
        | std::views::transform([](int n) { return n * 10; });

    std::cout << "Pares x10: ";
    for (int n : resultado) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    // Tomar los primeros 3 elementos
    std::cout << "Primeros 3: ";
    for (int n : numeros | std::views::take(3)) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    // Cadena compleja: saltar 2, tomar 4, filtrar impares
    auto cadena = numeros
        | std::views::drop(2)
        | std::views::take(4)
        | std::views::filter([](int n) { return n % 2 != 0; });

    std::cout << "Cadena compuesta: ";
    for (int n : cadena) {
        std::cout << n << " ";
    }
    std::cout << std::endl;

    return 0;
}
<---Ejemplo de `std::ranges` y `std::views` Result--->
<---Ejemplo de `std::chrono`--->
```cpp
#include <iostream>
#include <chrono>
#include <thread>
#include <vector>
#include <algorithm>
#include <numeric>

int main() {
    // =============================================
    // Medir tiempo de ejecución con steady_clock
    // =============================================
    auto inicio = std::chrono::steady_clock::now();

    // Operación a medir: llenar y ordenar un vector grande
    std::vector<int> datos(100000);
    std::iota(datos.begin(), datos.end(), 0);  // Llenar con 0, 1, 2, ...
    std::sort(datos.rbegin(), datos.rend());    // Ordenar en reversa
    std::sort(datos.begin(), datos.end());      // Ordenar de nuevo

    auto fin = std::chrono::steady_clock::now();

    // Calcular duración en diferentes unidades
    auto duracionMs = std::chrono::duration_cast<std::chrono::milliseconds>(fin - inicio);
    auto duracionUs = std::chrono::duration_cast<std::chrono::microseconds>(fin - inicio);

    std::cout << "Tiempo de ejecución: " << duracionMs.count() << " ms" << std::endl;
    std::cout << "Tiempo de ejecución: " << duracionUs.count() << " µs" << std::endl;

    // =============================================
    // Trabajar con duraciones tipadas
    // =============================================
    using namespace std::chrono_literals;  // Habilita sufijos como 500ms, 2s, etc.

    auto espera = 100ms;
    auto timeout = 2s;
    auto preciso = 1500us;

    std::cout << "Espera: " << espera.count() << " ms" << std::endl;
    std::cout << "Timeout: " << timeout.count() << " s" << std::endl;

    // Conversión entre unidades
    auto enMicrosegundos = std::chrono::duration_cast<std::chrono::microseconds>(timeout);
    std::cout << "Timeout en µs: " << enMicrosegundos.count() << std::endl;

    // =============================================
    // Fecha y hora actual con system_clock
    // =============================================
    auto ahora = std::chrono::system_clock::now();
    std::time_t tiempo = std::chrono::system_clock::to_time_t(ahora);
    std::cout << "Fecha y hora actual: " << std::ctime(&tiempo);

    return 0;
}
<---Ejemplo de `std::chrono` Result--->
<---Ejemplo de Especialización de `std::hash`--->
```cpp
#include <iostream>
#include <unordered_set>
#include <functional>
#include <string>

// Clase definida por el usuario
struct Punto {
    double x;
    double y;

    // Operador de igualdad (requerido por unordered_set)
    bool operator==(const Punto& otro) const {
        return x == otro.x && y == otro.y;
    }
};

// =============================================
// PERMITIDO: Especializar std::hash para Punto
// =============================================
template<>
struct std::hash<Punto> {
    std::size_t operator()(const Punto& p) const noexcept {
        // Combinar hashes de cada miembro
        std::size_t h1 = std::hash<double>{}(p.x);
        std::size_t h2 = std::hash<double>{}(p.y);
        // Técnica de combinación de hashes
        return h1 ^ (h2 << 1);
    }
};

// Función auxiliar para mostrar un Punto
std::ostream& operator<<(std::ostream& os, const Punto& p) {
    return os << "(" << p.x << ", " << p.y << ")";
}

int main() {
    // Ahora Punto se puede usar en unordered_set gracias a std::hash<Punto>
    std::unordered_set<Punto> puntos;

    puntos.insert({1.0, 2.0});
    puntos.insert({3.0, 4.0});
    puntos.insert({1.0, 2.0});  // Duplicado, no se inserta
    puntos.insert({5.0, 6.0});

    std::cout << "Puntos en el conjunto (" << puntos.size() << "):" << std::endl;
    for (const auto& p : puntos) {
        std::cout << "  " << p << std::endl;
    }

    // Verificar si un punto existe
    Punto buscar{3.0, 4.0};
    if (puntos.count(buscar)) {
        std::cout << "El punto " << buscar << " existe en el conjunto" << std::endl;
    }

    // =============================================
    // PROHIBIDO (comportamiento indefinido):
    // namespace std {
    //     void miFuncion() { }         // NO: agregar función nueva
    //     class MiClase { };            // NO: agregar clase nueva
    // }
    // =============================================

    return 0;
}
<---Ejemplo de Especialización de `std::hash` Result--->
