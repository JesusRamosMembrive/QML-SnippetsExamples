<---EXPLANATION--->
### Orden de Invocación de Constructores y Destructores en Herencia en C++

En C++, el orden de invocación de constructores y destructores en una jerarquía de herencia sigue reglas específicas. Estas reglas aseguran que los objetos se construyan y destruyan de manera consistente y que todos los recursos se manejen correctamente.

#### Orden de Invocación de Constructores

Cuando se crea un objeto de una clase derivada, los constructores se invocan en un orden específico:

1. **Constructor de la Clase Base:** Primero se llama al constructor de la clase base. Si hay una cadena de herencia, se llama primero al constructor del ancestro más alto y luego se procede hacia abajo hasta llegar a la clase derivada.
2. **Constructores de las Clases Derivadas:** Después de que todos los constructores de las clases base hayan sido invocados, se llama al constructor de la clase derivada más específica.

##### Ejemplo de Invocación de Constructores

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
```

En este ejemplo, el orden de invocación de los constructores es:

1. **Base**
2. **Intermedia**
3. **Derivada**

La salida será:
```
Constructor de Base
Constructor de Intermedia
Constructor de Derivada
```

#### Orden de Invocación de Destructores

El orden de invocación de los destructores es el inverso al de los constructores:

1. **Destructor de la Clase Derivada:** Primero se llama al destructor de la clase derivada más específica.
2. **Destructores de las Clases Base:** Después de que el destructor de la clase derivada ha sido invocado, se llama a los destructores de las clases base en el orden inverso al de la construcción.

##### Ejemplo de Invocación de Destructores

Continuando con el ejemplo anterior, si añadimos destructores a cada clase:

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
    ~Intermedia() {
        cout << "Destructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
```

La salida será:
```
Constructor de Base
Constructor de Intermedia
Constructor de Derivada
Destructor de Derivada
Destructor de Intermedia
Destructor de Base
```

Esto demuestra que los destructores se invocan en el orden inverso al de los constructores, garantizando que los recursos asignados por las clases derivadas se liberen antes de que se liberen los recursos asignados por las clases base.

### Consideraciones Adicionales

1. **Constructores y Destructores Virtuales:**
   - Si se espera que una clase base se utilice de manera polimórfica, sus destructores deben ser declarados como `virtual`. Esto asegura que el destructor adecuado se llame cuando se elimine un objeto a través de un puntero a la clase base.

##### Ejemplo de Destructor Virtual

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj;
    return 0;
}
```

La salida será:
```
Constructor de Base
Constructor de Derivada
Destructor de Derivada
Destructor de Base
```

Sin el destructor virtual en la clase base, el destructor de la clase derivada no se llamaría, lo que podría llevar a fugas de memoria y otros problemas.

2. **Lista de Inicialización del Constructor:**
   - La lista de inicialización del constructor se utiliza para inicializar los miembros de la clase base y los miembros de la clase derivada antes de que el cuerpo del constructor se ejecute.

##### Ejemplo de Lista de Inicialización del Constructor

```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int valorBase;
public:
    Base(int v) : valorBase(v) {
        cout << "Constructor de Base con valor " << valorBase << endl;
    }
};

class Derivada : public Base {
private:
    int valorDerivada;
public:
    Derivada(int vb, int vd) : Base(vb), valorDerivada(vd) {
        cout << "Constructor de Derivada con valor " << valorDerivada << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    return 0;
}
```

La salida será:
```
Constructor de Base con valor 10
Constructor de Derivada con valor 20
```

En este ejemplo, `Base` se inicializa con el valor `10` antes de que `Derivada` se inicialice con el valor `20`.

#### Destructores `= default` y Orden de Destrucción con Smart Pointers

En C++11, se puede usar `= default` para indicarle al compilador que genere la implementación por defecto de un destructor virtual. Esto es más limpio que escribir un cuerpo vacío y deja claro la intención del programador. Cuando se trabaja con polimorfismo y `std::unique_ptr`, es **obligatorio** que la clase base tenga un destructor virtual; de lo contrario, al destruir el `unique_ptr<Base>` que apunta a un objeto derivado, solo se llamará al destructor de la base y se producirá comportamiento indefinido.

##### Ejemplo de Destructores `= default` con Smart Pointers

```cpp
#include <iostream>
#include <memory>
#include <string>
using namespace std;

class Recurso {
protected:
    string nombre;

public:
    Recurso(const string& n) : nombre(n) {
        cout << "Constructor de Recurso: " << nombre << endl;
    }

    // Destructor virtual con implementación por defecto del compilador
    virtual ~Recurso() = default;

    virtual void usar() const {
        cout << "Usando recurso: " << nombre << endl;
    }
};

class ArchivoRecurso : public Recurso {
private:
    string rutaArchivo;

public:
    ArchivoRecurso(const string& n, const string& ruta)
        : Recurso(n), rutaArchivo(ruta) {
        cout << "Constructor de ArchivoRecurso: " << rutaArchivo << endl;
    }

    ~ArchivoRecurso() override {
        cout << "Destructor de ArchivoRecurso: cerrando " << rutaArchivo << endl;
    }

    void usar() const override {
        cout << "Leyendo archivo: " << rutaArchivo << endl;
    }
};

class ConexionRecurso : public Recurso {
private:
    string host;

public:
    ConexionRecurso(const string& n, const string& h)
        : Recurso(n), host(h) {
        cout << "Constructor de ConexionRecurso: " << host << endl;
    }

    ~ConexionRecurso() override {
        cout << "Destructor de ConexionRecurso: desconectando de " << host << endl;
    }

    void usar() const override {
        cout << "Conectado a: " << host << endl;
    }
};

int main() {
    cout << "=== Creando recursos con unique_ptr ===" << endl;

    // unique_ptr destruye correctamente gracias al destructor virtual en Recurso
    unique_ptr<Recurso> r1 = make_unique<ArchivoRecurso>("Datos", "/tmp/datos.csv");
    unique_ptr<Recurso> r2 = make_unique<ConexionRecurso>("DB", "localhost:5432");

    r1->usar();
    r2->usar();

    cout << "\n=== Destruyendo recursos (orden inverso de creación en el stack) ===" << endl;
    // Al salir del scope, unique_ptr destruye los objetos automáticamente
    // r2 se destruye primero (último en el stack), luego r1
    return 0;
}
```

En este ejemplo, `Recurso` usa `virtual ~Recurso() = default;` para obtener un destructor virtual sin escribir implementación manual. Gracias a esto, `unique_ptr<Recurso>` destruye correctamente tanto `ArchivoRecurso` como `ConexionRecurso`, llamando a los destructores derivados antes que al de la base.

#### Orden de Construcción y Destrucción en Qt (Parent-Child)

Qt implementa un sistema de propiedad padre-hijo a través de `QObject`. Cuando un `QObject` tiene un padre, el padre se encarga de destruir a sus hijos automáticamente cuando él mismo es destruido. El orden de destrucción es el **inverso al orden de creación** de los hijos, y esta destrucción ocurre antes de que el destructor del propio padre finalice. Es importante **no usar `std::unique_ptr` para gestionar un `QObject` que ya tiene un padre**, ya que esto causaría doble liberación de memoria (double-free).

##### Ejemplo de Orden de Construcción y Destrucción en Qt

```cpp
#include <QObject>
#include <QDebug>
#include <QCoreApplication>

class MiComponente : public QObject {
    Q_OBJECT
public:
    MiComponente(const QString& nombre, QObject* parent = nullptr)
        : QObject(parent) {
        setObjectName(nombre);
        qDebug() << "Construido:" << objectName();
    }

    ~MiComponente() override {
        qDebug() << "Destruido:" << objectName();
    }
};

int main(int argc, char* argv[]) {
    QCoreApplication app(argc, argv);

    // El padre se crea primero
    auto* padre = new MiComponente("Padre");

    // Los hijos se crean con el padre como propietario
    new MiComponente("Hijo_1", padre);
    new MiComponente("Hijo_2", padre);
    new MiComponente("Hijo_3", padre);

    // Verificar los hijos registrados
    qDebug() << "\nHijos del padre:";
    for (QObject* hijo : padre->children()) {
        qDebug() << "  -" << hijo->objectName();
    }

    // Al destruir el padre, se destruyen los hijos en orden inverso
    qDebug() << "\nDestruyendo el padre:";
    delete padre;
    // Salida esperada:
    // Destruido: Hijo_3  (último creado, primero destruido)
    // Destruido: Hijo_2
    // Destruido: Hijo_1
    // Destruido: Padre

    // PELIGRO: NO hacer esto con QObjects que tienen padre
    // auto* padre2 = new MiComponente("Padre2");
    // std::unique_ptr<MiComponente> hijo(new MiComponente("HijoUP", padre2));
    // delete padre2; // padre2 destruye "HijoUP", luego unique_ptr intenta
    //                // destruirlo de nuevo -> DOUBLE FREE / CRASH

    return 0;
}
```

En este ejemplo, `MiComponente` es un `QObject` que imprime mensajes al construirse y destruirse. Los hijos se crean con un padre, y al destruir el padre, Qt destruye automáticamente los hijos en orden inverso al de creación. El comentario al final muestra el error común de combinar `unique_ptr` con el sistema padre-hijo de Qt, lo cual provoca doble liberación de memoria.

### Conclusión

El orden de invocación de constructores y destructores en C++ es crucial para garantizar que los recursos se gestionen adecuadamente. Los constructores se invocan desde la clase base hasta la clase derivada, mientras que los destructores se invocan en el orden inverso. Entender este orden ayuda a diseñar jerarquías de herencia robustas y evitar problemas relacionados con la gestión de recursos y la integridad de los objetos.
<---FILES--->
Ejemplo de Invocación de Constructores
Ejemplo de Invocación de Constructores Result
Ejemplo de Invocación de Destructores
Ejemplo de Invocación de Destructores Result
Ejemplo de Destructor Virtual
Ejemplo de Destructor Virtual Result
Ejemplo de Lista de Inicialización del Constructor
Ejemplo de Lista de Inicialización del Constructor Result
Ejemplo de Destructores `= default` con Smart Pointers
Ejemplo de Destructores `= default` con Smart Pointers Result
Ejemplo de Orden de Construcción y Destrucción en Qt
Ejemplo de Orden de Construcción y Destrucción en Qt Result
<---Ejemplo de Invocación de Constructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
<---Ejemplo de Invocación de Constructores Result--->
<---Ejemplo de Invocación de Destructores--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Intermedia : public Base {
public:
    Intermedia() {
        cout << "Constructor de Intermedia" << endl;
    }
    ~Intermedia() {
        cout << "Destructor de Intermedia" << endl;
    }
};

class Derivada : public Intermedia {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Derivada obj;
    return 0;
}
<---Ejemplo de Invocación de Destructores Result--->
<---Ejemplo de Destructor Virtual--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() {
        cout << "Constructor de Base" << endl;
    }
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada();
    delete obj;
    return 0;
}
<---Ejemplo de Destructor Virtual Result--->
<---Ejemplo de Lista de Inicialización del Constructor--->
```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int valorBase;
public:
    Base(int v) : valorBase(v) {
        cout << "Constructor de Base con valor " << valorBase << endl;
    }
};

class Derivada : public Base {
private:
    int valorDerivada;
public:
    Derivada(int vb, int vd) : Base(vb), valorDerivada(vd) {
        cout << "Constructor de Derivada con valor " << valorDerivada << endl;
    }
};

int main() {
    Derivada obj(10, 20);
    return 0;
}
<---Ejemplo de Lista de Inicialización del Constructor Result--->
<---Ejemplo de Destructores `= default` con Smart Pointers--->
```cpp
#include <iostream>
#include <memory>
#include <string>
using namespace std;

class Recurso {
protected:
    string nombre;

public:
    Recurso(const string& n) : nombre(n) {
        cout << "Constructor de Recurso: " << nombre << endl;
    }

    // Destructor virtual con implementación por defecto del compilador
    virtual ~Recurso() = default;

    virtual void usar() const {
        cout << "Usando recurso: " << nombre << endl;
    }
};

class ArchivoRecurso : public Recurso {
private:
    string rutaArchivo;

public:
    ArchivoRecurso(const string& n, const string& ruta)
        : Recurso(n), rutaArchivo(ruta) {
        cout << "Constructor de ArchivoRecurso: " << rutaArchivo << endl;
    }

    ~ArchivoRecurso() override {
        cout << "Destructor de ArchivoRecurso: cerrando " << rutaArchivo << endl;
    }

    void usar() const override {
        cout << "Leyendo archivo: " << rutaArchivo << endl;
    }
};

class ConexionRecurso : public Recurso {
private:
    string host;

public:
    ConexionRecurso(const string& n, const string& h)
        : Recurso(n), host(h) {
        cout << "Constructor de ConexionRecurso: " << host << endl;
    }

    ~ConexionRecurso() override {
        cout << "Destructor de ConexionRecurso: desconectando de " << host << endl;
    }

    void usar() const override {
        cout << "Conectado a: " << host << endl;
    }
};

int main() {
    cout << "=== Creando recursos con unique_ptr ===" << endl;

    // unique_ptr destruye correctamente gracias al destructor virtual en Recurso
    unique_ptr<Recurso> r1 = make_unique<ArchivoRecurso>("Datos", "/tmp/datos.csv");
    unique_ptr<Recurso> r2 = make_unique<ConexionRecurso>("DB", "localhost:5432");

    r1->usar();
    r2->usar();

    cout << "\n=== Destruyendo recursos (orden inverso de creación en el stack) ===" << endl;
    // Al salir del scope, unique_ptr destruye los objetos automáticamente
    // r2 se destruye primero (último en el stack), luego r1
    return 0;
}
<---Ejemplo de Destructores `= default` con Smart Pointers Result--->
<---Ejemplo de Orden de Construcción y Destrucción en Qt--->
```cpp
#include <QObject>
#include <QDebug>
#include <QCoreApplication>

class MiComponente : public QObject {
    Q_OBJECT
public:
    MiComponente(const QString& nombre, QObject* parent = nullptr)
        : QObject(parent) {
        setObjectName(nombre);
        qDebug() << "Construido:" << objectName();
    }

    ~MiComponente() override {
        qDebug() << "Destruido:" << objectName();
    }
};

int main(int argc, char* argv[]) {
    QCoreApplication app(argc, argv);

    // El padre se crea primero
    auto* padre = new MiComponente("Padre");

    // Los hijos se crean con el padre como propietario
    new MiComponente("Hijo_1", padre);
    new MiComponente("Hijo_2", padre);
    new MiComponente("Hijo_3", padre);

    // Verificar los hijos registrados
    qDebug() << "\nHijos del padre:";
    for (QObject* hijo : padre->children()) {
        qDebug() << "  -" << hijo->objectName();
    }

    // Al destruir el padre, se destruyen los hijos en orden inverso
    qDebug() << "\nDestruyendo el padre:";
    delete padre;
    // Salida esperada:
    // Destruido: Hijo_3  (último creado, primero destruido)
    // Destruido: Hijo_2
    // Destruido: Hijo_1
    // Destruido: Padre

    // PELIGRO: NO hacer esto con QObjects que tienen padre
    // auto* padre2 = new MiComponente("Padre2");
    // std::unique_ptr<MiComponente> hijo(new MiComponente("HijoUP", padre2));
    // delete padre2; // padre2 destruye "HijoUP", luego unique_ptr intenta
    //                // destruirlo de nuevo -> DOUBLE FREE / CRASH

    return 0;
}
<---Ejemplo de Orden de Construcción y Destrucción en Qt Result--->
