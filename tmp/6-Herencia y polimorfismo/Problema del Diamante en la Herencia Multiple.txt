<---EXPLANATION--->
### Problema del Diamante en la Herencia Múltiple

El problema del diamante es una complicación que surge en lenguajes de programación que permiten la herencia múltiple, como C++. Se produce cuando una clase deriva de dos clases base que a su vez derivan de una misma clase ancestro. Esto crea una ambigüedad en la jerarquía de herencia y puede llevar a problemas de duplicación de miembros de la clase ancestro.

#### Estructura del Problema del Diamante

Imaginemos una jerarquía de clases en la que `ClaseA` es la clase base más alta, `ClaseB` y `ClaseC` derivan de `ClaseA`, y `ClaseD` deriva de `ClaseB` y `ClaseC`. Esto crea una estructura de diamante:

```
       ClaseA
      /     \
  ClaseB   ClaseC
      \     /
       ClaseD
```

##### Ejemplo sin Solución

```cpp
#include <iostream>
using namespace std;

class ClaseA {
public:
    void mostrar() {
        cout << "ClaseA" << endl;
    }
};

class ClaseB : public ClaseA {
};

class ClaseC : public ClaseA {
};

class ClaseD : public ClaseB, public ClaseC {
};

int main() {
    ClaseD obj;
    // obj.mostrar(); // Error: llamada ambigua a mostrar()
    return 0;
}
```

En este ejemplo, `ClaseD` hereda de `ClaseB` y `ClaseC`, que ambos heredan de `ClaseA`. Si intentamos llamar a `mostrar` en un objeto de `ClaseD`, el compilador no sabrá cuál versión de `mostrar` usar, la heredada de `ClaseB` o la heredada de `ClaseC`.

#### Solución: Herencia Virtual

Para resolver el problema del diamante, se utiliza la herencia virtual. La herencia virtual asegura que solo se crea una instancia de la clase base compartida (`ClaseA`) cuando se utiliza en una estructura de diamante. Esto elimina la ambigüedad y la duplicación de miembros de la clase base.

##### Ejemplo con Herencia Virtual

```cpp
#include <iostream>
using namespace std;

class ClaseA {
public:
    void mostrar() {
        cout << "ClaseA" << endl;
    }
};

class ClaseB : public virtual ClaseA {
};

class ClaseC : public virtual ClaseA {
};

class ClaseD : public ClaseB, public ClaseC {
};

int main() {
    ClaseD obj;
    obj.mostrar(); // Ahora funciona correctamente
    return 0;
}
```

En este ejemplo:
- `ClaseB` y `ClaseC` heredan virtualmente de `ClaseA` utilizando la sintaxis `public virtual ClaseA`.
- `ClaseD` hereda de `ClaseB` y `ClaseC`, pero solo hay una instancia de `ClaseA` compartida entre ellas.

#### Herencia Virtual en Detalle

1. **Declaración:** La herencia virtual se declara añadiendo la palabra clave `virtual` antes del nombre de la clase base en la lista de herencia.
2. **Instancias Únicas:** La herencia virtual garantiza que solo se crea una única instancia de la clase base en la jerarquía de herencia, eliminando la ambigüedad en la llamada a funciones miembro y la duplicación de datos miembro.

##### Ejemplo Ampliado

```cpp
#include <iostream>
using namespace std;

class ClaseA {
public:
    int valor;

    ClaseA() : valor(0) {}

    void mostrar() {
        cout << "ClaseA: valor = " << valor << endl;
    }
};

class ClaseB : public virtual ClaseA {
public:
    ClaseB() {
        valor = 10;
    }
};

class ClaseC : public virtual ClaseA {
public:
    ClaseC() {
        valor = 20;
    }
};

class ClaseD : public ClaseB, public ClaseC {
public:
    ClaseD() {
        // Se puede acceder a `valor` de ClaseA directamente
        valor = 30;
    }
};

int main() {
    ClaseD obj;
    obj.mostrar(); // Muestra: ClaseA: valor = 30
    return 0;
}
```

En este ejemplo:
- `ClaseA` tiene un miembro `valor` y una función `mostrar`.
- `ClaseB` y `ClaseC` heredan virtualmente de `ClaseA` y asignan diferentes valores a `valor`.
- `ClaseD` hereda de `ClaseB` y `ClaseC`, y se asegura que solo hay una instancia de `ClaseA`, permitiendo que `valor` sea accesible y modificado sin ambigüedad.

#### Herencia Virtual Internamente: Cómo Funciona

Para entender por qué la herencia virtual resuelve el problema del diamante, es importante comprender el mecanismo interno que utiliza el compilador.

**Sin herencia virtual**, cada clase derivada contiene una copia completa de la clase base. En el diamante, `ClaseD` tendría **dos copias** de `ClaseA`: una heredada a través de `ClaseB` y otra a través de `ClaseC`.

**Con herencia virtual**, el compilador añade un **puntero a la base virtual (vbptr)** en cada clase que hereda virtualmente. Este puntero apunta a una tabla que indica el desplazamiento (offset) desde la clase actual hasta la única instancia de la base virtual. La base virtual se ubica al final del layout del objeto.

**Implicación clave en los constructores:** En herencia virtual, la **clase más derivada** es responsable de construir la base virtual directamente. Las clases intermedias (`ClaseB`, `ClaseC`) no llaman al constructor de la base virtual cuando son parte de un diamante; solo la clase final (`ClaseD`) lo hace. Esto se especifica en la lista de inicialización del constructor de `ClaseD`.

**Orden de construcción:**
1. Primero se construyen todas las bases virtuales (en orden de declaración de izquierda a derecha, profundidad primero).
2. Luego las bases no virtuales.
3. Finalmente los miembros y el cuerpo del constructor.

##### Ejemplo de Herencia Virtual con Constructores

```cpp
#include <iostream>
using namespace std;

class ClaseA {
public:
    int valor;

    // Constructor con parámetro
    ClaseA(int v) : valor(v) {
        cout << "Constructor ClaseA(" << v << ")" << endl;
    }
};

class ClaseB : public virtual ClaseA {
public:
    // ClaseB inicializa ClaseA, pero esta inicialización se IGNORA
    // cuando ClaseB es parte del diamante (ClaseD la sobreescribe)
    ClaseB(int v) : ClaseA(v) {
        cout << "Constructor ClaseB(" << v << ")" << endl;
    }
};

class ClaseC : public virtual ClaseA {
public:
    // Lo mismo: esta inicialización de ClaseA se ignora en el diamante
    ClaseC(int v) : ClaseA(v) {
        cout << "Constructor ClaseC(" << v << ")" << endl;
    }
};

class ClaseD : public ClaseB, public ClaseC {
public:
    // ¡ClaseD DEBE inicializar ClaseA directamente!
    // Si no se incluye ClaseA en la lista de inicialización,
    // se usa el constructor por defecto de ClaseA (si existe)
    ClaseD(int a, int b, int c)
        : ClaseA(a),      // La clase más derivada inicializa la base virtual
          ClaseB(b),
          ClaseC(c)
    {
        cout << "Constructor ClaseD" << endl;
    }
};

int main() {
    // Orden de construcción:
    // 1. ClaseA(100)  - base virtual, inicializada por ClaseD
    // 2. ClaseB(200)  - (su inicialización de ClaseA se ignora)
    // 3. ClaseC(300)  - (su inicialización de ClaseA se ignora)
    // 4. ClaseD
    ClaseD obj(100, 200, 300);

    cout << "\nValor de ClaseA: " << obj.valor << endl; // 100 (el valor que pasó ClaseD)

    // Solo hay UNA instancia de ClaseA
    cout << "Acceso sin ambigüedad: " << obj.ClaseA::valor << endl;

    return 0;
}
```

#### Qt y Herencia Simple: Evitando el Diamante

Qt toma una decisión de diseño deliberada: **`QObject` y todas las clases que heredan de él solo permiten herencia simple**. Esto elimina por completo el problema del diamante en la jerarquía de objetos Qt. El sistema de meta-objetos de Qt (`moc`) no soporta herencia múltiple de clases `QObject`.

Sin embargo, Qt sí permite **herencia múltiple de interfaces**. Las interfaces en Qt se definen como **clases abstractas puras que NO heredan de `QObject`**. De esta forma, una clase puede heredar de un solo `QObject` (como `QWidget`) y de múltiples interfaces al mismo tiempo, sin crear un diamante.

Para declarar una interfaz compatible con el sistema de meta-objetos, se usa `Q_DECLARE_INTERFACE`, que permite usar `qobject_cast` para verificar si un objeto implementa una interfaz específica.

##### Ejemplo de Interfaces en Qt

```cpp
#include <QObject>
#include <QWidget>
#include <QDebug>

// Interfaz 1: NO hereda de QObject
class ISerializable {
public:
    virtual ~ISerializable() = default;
    virtual QByteArray serializar() const = 0;
    virtual void deserializar(const QByteArray& datos) = 0;
};

// Interfaz 2: NO hereda de QObject
class IConfigurable {
public:
    virtual ~IConfigurable() = default;
    virtual void cargarConfiguracion(const QString& ruta) = 0;
    virtual void guardarConfiguracion(const QString& ruta) const = 0;
};

// Declarar las interfaces para el sistema de meta-objetos de Qt
Q_DECLARE_INTERFACE(ISerializable, "com.ejemplo.ISerializable/1.0")
Q_DECLARE_INTERFACE(IConfigurable, "com.ejemplo.IConfigurable/1.0")

// Clase que hereda de QWidget (único QObject) + múltiples interfaces
class MiWidget : public QWidget, public ISerializable, public IConfigurable {
    Q_OBJECT
    Q_INTERFACES(ISerializable IConfigurable)

public:
    explicit MiWidget(QWidget* parent = nullptr) : QWidget(parent) {}

    // Implementación de ISerializable
    QByteArray serializar() const override {
        qDebug() << "Serializando MiWidget";
        return QByteArray("datos_widget");
    }

    void deserializar(const QByteArray& datos) override {
        qDebug() << "Deserializando:" << datos;
    }

    // Implementación de IConfigurable
    void cargarConfiguracion(const QString& ruta) override {
        qDebug() << "Cargando configuración desde:" << ruta;
    }

    void guardarConfiguracion(const QString& ruta) const override {
        qDebug() << "Guardando configuración en:" << ruta;
    }
};

void procesarObjeto(QObject* obj) {
    // qobject_cast permite verificar interfaces en tiempo de ejecución
    if (auto* serializable = qobject_cast<ISerializable*>(obj)) {
        QByteArray datos = serializable->serializar();
        qDebug() << "Datos serializados:" << datos;
    }

    if (auto* configurable = qobject_cast<IConfigurable*>(obj)) {
        configurable->cargarConfiguracion("/config/mi_widget.json");
    }
}

// Uso:
// MiWidget* widget = new MiWidget();
// procesarObjeto(widget);
// No hay problema del diamante: QWidget es el único QObject en la jerarquía
```

**Regla de oro en Qt:** Una clase nunca debe heredar de más de un `QObject`. Las interfaces adicionales deben ser clases abstractas puras sin relación con `QObject`.

#### Mixins y CRTP como Alternativa a la Herencia Múltiple

Los **mixins** son clases que proporcionan funcionalidad reutilizable que puede ser "mezclada" en otras clases. Combinados con el **CRTP (Curiously Recurring Template Pattern)**, los mixins permiten componer funcionalidad de manera segura sin los problemas de la herencia múltiple tradicional, ya que cada mixin es una plantilla independiente que no comparte una clase base común.

Un mixin CRTP:
- Recibe la clase derivada como parámetro de plantilla.
- Puede acceder a los miembros de la derivada mediante `static_cast`.
- No introduce ambigüedad porque cada mixin es una instanciación única de la plantilla.

##### Ejemplo de Mixins con CRTP

```cpp
#include <iostream>
#include <string>
#include <sstream>
using namespace std;

// Mixin 1: Agrega capacidad de impresión
template <typename T>
class Printable {
public:
    void imprimir() const {
        const T& self = static_cast<const T&>(*this);
        cout << self.toString() << endl;
    }

    void imprimirConEtiqueta(const string& etiqueta) const {
        const T& self = static_cast<const T&>(*this);
        cout << etiqueta << ": " << self.toString() << endl;
    }
};

// Mixin 2: Agrega capacidad de serialización
template <typename T>
class Serializable {
public:
    string serializar() const {
        const T& self = static_cast<const T&>(*this);
        return "{ \"tipo\": \"" + self.tipoNombre() + "\", \"datos\": \"" + self.toString() + "\" }";
    }

    void mostrarSerializado() const {
        cout << "JSON: " << serializar() << endl;
    }
};

// Mixin 3: Agrega capacidad de comparación
template <typename T>
class Comparable {
public:
    bool operator==(const T& otro) const {
        const T& self = static_cast<const T&>(*this);
        return self.valorComparacion() == otro.valorComparacion();
    }

    bool operator<(const T& otro) const {
        const T& self = static_cast<const T&>(*this);
        return self.valorComparacion() < otro.valorComparacion();
    }

    bool operator>(const T& otro) const {
        return otro < static_cast<const T&>(*this);
    }
};

// Clase que combina múltiples mixins (sin problema del diamante)
class Producto
    : public Printable<Producto>,
      public Serializable<Producto>,
      public Comparable<Producto>
{
    string nombre_;
    double precio_;

public:
    Producto(const string& n, double p) : nombre_(n), precio_(p) {}

    // Métodos requeridos por los mixins
    string toString() const {
        ostringstream oss;
        oss << nombre_ << " ($" << precio_ << ")";
        return oss.str();
    }

    string tipoNombre() const { return "Producto"; }
    double valorComparacion() const { return precio_; }
};

// Otra clase que usa los mismos mixins
class Empleado
    : public Printable<Empleado>,
      public Serializable<Empleado>
{
    string nombre_;
    int id_;

public:
    Empleado(const string& n, int id) : nombre_(n), id_(id) {}

    string toString() const {
        return nombre_ + " (ID: " + to_string(id_) + ")";
    }

    string tipoNombre() const { return "Empleado"; }
};

int main() {
    Producto laptop("Laptop", 999.99);
    Producto mouse("Mouse", 29.99);

    // Funcionalidad de Printable
    laptop.imprimir();                           // Laptop ($999.99)
    laptop.imprimirConEtiqueta("Producto");      // Producto: Laptop ($999.99)

    // Funcionalidad de Serializable
    laptop.mostrarSerializado();
    // JSON: { "tipo": "Producto", "datos": "Laptop ($999.99)" }

    // Funcionalidad de Comparable
    cout << "Laptop > Mouse: " << (laptop > mouse ? "sí" : "no") << endl; // sí
    cout << "Laptop == Mouse: " << (laptop == mouse ? "sí" : "no") << endl; // no

    // Empleado usa Printable y Serializable (pero no Comparable)
    Empleado emp("Ana García", 1234);
    emp.imprimir();           // Ana García (ID: 1234)
    emp.mostrarSerializado(); // JSON: { "tipo": "Empleado", "datos": "Ana García (ID: 1234)" }

    // No hay problema del diamante: cada mixin es una plantilla diferente
    // Printable<Producto> y Serializable<Producto> no comparten base común

    return 0;
}
```

**Ventajas de los mixins CRTP:**
- **Sin problema del diamante:** Cada mixin es una instanciación de plantilla independiente.
- **Composición flexible:** Se pueden combinar libremente diferentes mixins según las necesidades.
- **Sin overhead en ejecución:** Todo se resuelve en compilación, sin vtable.
- **Reutilización:** El mismo mixin puede usarse en clases completamente diferentes.

### Conclusión

El problema del diamante es una complicación común en la herencia múltiple que puede llevar a ambigüedades y duplicación de miembros de la clase base. La herencia virtual en C++ es la solución para este problema, garantizando que solo se cree una instancia de la clase base compartida en la jerarquía de herencia. Comprender y aplicar correctamente la herencia virtual es crucial para diseñar jerarquías de clases complejas y evitar problemas de ambigüedad y duplicación en C++.
<---FILES--->
Ejemplo sin Solución
Ejemplo sin Solución Result
Ejemplo con Herencia Virtual
Ejemplo con Herencia Virtual Result
Ejemplo Ampliado
Ejemplo Ampliado Result
Ejemplo de Herencia Virtual con Constructores
Ejemplo de Herencia Virtual con Constructores Result
Ejemplo de Interfaces en Qt
Ejemplo de Interfaces en Qt Result
Ejemplo de Mixins con CRTP
Ejemplo de Mixins con CRTP Result
<---Ejemplo sin Solución--->
```cpp
#include <iostream>
using namespace std;

class ClaseA {
public:
    void mostrar() {
        cout << "ClaseA" << endl;
    }
};

class ClaseB : public ClaseA {
};

class ClaseC : public ClaseA {
};

class ClaseD : public ClaseB, public ClaseC {
};

int main() {
    ClaseD obj;
    // obj.mostrar(); // Error: llamada ambigua a mostrar()
    return 0;
}
<---Ejemplo sin Solución Result--->
<---Ejemplo con Herencia Virtual--->
```cpp
#include <iostream>
using namespace std;

class ClaseA {
public:
    void mostrar() {
        cout << "ClaseA" << endl;
    }
};

class ClaseB : public virtual ClaseA {
};

class ClaseC : public virtual ClaseA {
};

class ClaseD : public ClaseB, public ClaseC {
};

int main() {
    ClaseD obj;
    obj.mostrar(); // Ahora funciona correctamente
    return 0;
}
<---Ejemplo con Herencia Virtual Result--->
<---Ejemplo Ampliado--->
```cpp
#include <iostream>
using namespace std;

class ClaseA {
public:
    int valor;

    ClaseA() : valor(0) {}

    void mostrar() {
        cout << "ClaseA: valor = " << valor << endl;
    }
};

class ClaseB : public virtual ClaseA {
public:
    ClaseB() {
        valor = 10;
    }
};

class ClaseC : public virtual ClaseA {
public:
    ClaseC() {
        valor = 20;
    }
};

class ClaseD : public ClaseB, public ClaseC {
public:
    ClaseD() {
        // Se puede acceder a `valor` de ClaseA directamente
        valor = 30;
    }
};

int main() {
    ClaseD obj;
    obj.mostrar(); // Muestra: ClaseA: valor = 30
    return 0;
}
<---Ejemplo Ampliado Result--->
<---Ejemplo de Herencia Virtual con Constructores--->
```cpp
#include <iostream>
using namespace std;

class ClaseA {
public:
    int valor;

    // Constructor con parámetro
    ClaseA(int v) : valor(v) {
        cout << "Constructor ClaseA(" << v << ")" << endl;
    }
};

class ClaseB : public virtual ClaseA {
public:
    // ClaseB inicializa ClaseA, pero esta inicialización se IGNORA
    // cuando ClaseB es parte del diamante (ClaseD la sobreescribe)
    ClaseB(int v) : ClaseA(v) {
        cout << "Constructor ClaseB(" << v << ")" << endl;
    }
};

class ClaseC : public virtual ClaseA {
public:
    // Lo mismo: esta inicialización de ClaseA se ignora en el diamante
    ClaseC(int v) : ClaseA(v) {
        cout << "Constructor ClaseC(" << v << ")" << endl;
    }
};

class ClaseD : public ClaseB, public ClaseC {
public:
    // ¡ClaseD DEBE inicializar ClaseA directamente!
    // Si no se incluye ClaseA en la lista de inicialización,
    // se usa el constructor por defecto de ClaseA (si existe)
    ClaseD(int a, int b, int c)
        : ClaseA(a),      // La clase más derivada inicializa la base virtual
          ClaseB(b),
          ClaseC(c)
    {
        cout << "Constructor ClaseD" << endl;
    }
};

int main() {
    // Orden de construcción:
    // 1. ClaseA(100)  - base virtual, inicializada por ClaseD
    // 2. ClaseB(200)  - (su inicialización de ClaseA se ignora)
    // 3. ClaseC(300)  - (su inicialización de ClaseA se ignora)
    // 4. ClaseD
    ClaseD obj(100, 200, 300);

    cout << "\nValor de ClaseA: " << obj.valor << endl; // 100 (el valor que pasó ClaseD)

    // Solo hay UNA instancia de ClaseA
    cout << "Acceso sin ambigüedad: " << obj.ClaseA::valor << endl;

    return 0;
}
<---Ejemplo de Herencia Virtual con Constructores Result--->
<---Ejemplo de Interfaces en Qt--->
```cpp
#include <QObject>
#include <QWidget>
#include <QDebug>

// Interfaz 1: NO hereda de QObject
class ISerializable {
public:
    virtual ~ISerializable() = default;
    virtual QByteArray serializar() const = 0;
    virtual void deserializar(const QByteArray& datos) = 0;
};

// Interfaz 2: NO hereda de QObject
class IConfigurable {
public:
    virtual ~IConfigurable() = default;
    virtual void cargarConfiguracion(const QString& ruta) = 0;
    virtual void guardarConfiguracion(const QString& ruta) const = 0;
};

// Declarar las interfaces para el sistema de meta-objetos de Qt
Q_DECLARE_INTERFACE(ISerializable, "com.ejemplo.ISerializable/1.0")
Q_DECLARE_INTERFACE(IConfigurable, "com.ejemplo.IConfigurable/1.0")

// Clase que hereda de QWidget (único QObject) + múltiples interfaces
class MiWidget : public QWidget, public ISerializable, public IConfigurable {
    Q_OBJECT
    Q_INTERFACES(ISerializable IConfigurable)

public:
    explicit MiWidget(QWidget* parent = nullptr) : QWidget(parent) {}

    // Implementación de ISerializable
    QByteArray serializar() const override {
        qDebug() << "Serializando MiWidget";
        return QByteArray("datos_widget");
    }

    void deserializar(const QByteArray& datos) override {
        qDebug() << "Deserializando:" << datos;
    }

    // Implementación de IConfigurable
    void cargarConfiguracion(const QString& ruta) override {
        qDebug() << "Cargando configuración desde:" << ruta;
    }

    void guardarConfiguracion(const QString& ruta) const override {
        qDebug() << "Guardando configuración en:" << ruta;
    }
};

void procesarObjeto(QObject* obj) {
    // qobject_cast permite verificar interfaces en tiempo de ejecución
    if (auto* serializable = qobject_cast<ISerializable*>(obj)) {
        QByteArray datos = serializable->serializar();
        qDebug() << "Datos serializados:" << datos;
    }

    if (auto* configurable = qobject_cast<IConfigurable*>(obj)) {
        configurable->cargarConfiguracion("/config/mi_widget.json");
    }
}

// Uso:
// MiWidget* widget = new MiWidget();
// procesarObjeto(widget);
// No hay problema del diamante: QWidget es el único QObject en la jerarquía
<---Ejemplo de Interfaces en Qt Result--->
<---Ejemplo de Mixins con CRTP--->
```cpp
#include <iostream>
#include <string>
#include <sstream>
using namespace std;

// Mixin 1: Agrega capacidad de impresión
template <typename T>
class Printable {
public:
    void imprimir() const {
        const T& self = static_cast<const T&>(*this);
        cout << self.toString() << endl;
    }

    void imprimirConEtiqueta(const string& etiqueta) const {
        const T& self = static_cast<const T&>(*this);
        cout << etiqueta << ": " << self.toString() << endl;
    }
};

// Mixin 2: Agrega capacidad de serialización
template <typename T>
class Serializable {
public:
    string serializar() const {
        const T& self = static_cast<const T&>(*this);
        return "{ \"tipo\": \"" + self.tipoNombre() + "\", \"datos\": \"" + self.toString() + "\" }";
    }

    void mostrarSerializado() const {
        cout << "JSON: " << serializar() << endl;
    }
};

// Mixin 3: Agrega capacidad de comparación
template <typename T>
class Comparable {
public:
    bool operator==(const T& otro) const {
        const T& self = static_cast<const T&>(*this);
        return self.valorComparacion() == otro.valorComparacion();
    }

    bool operator<(const T& otro) const {
        const T& self = static_cast<const T&>(*this);
        return self.valorComparacion() < otro.valorComparacion();
    }

    bool operator>(const T& otro) const {
        return otro < static_cast<const T&>(*this);
    }
};

// Clase que combina múltiples mixins (sin problema del diamante)
class Producto
    : public Printable<Producto>,
      public Serializable<Producto>,
      public Comparable<Producto>
{
    string nombre_;
    double precio_;

public:
    Producto(const string& n, double p) : nombre_(n), precio_(p) {}

    // Métodos requeridos por los mixins
    string toString() const {
        ostringstream oss;
        oss << nombre_ << " ($" << precio_ << ")";
        return oss.str();
    }

    string tipoNombre() const { return "Producto"; }
    double valorComparacion() const { return precio_; }
};

// Otra clase que usa los mismos mixins
class Empleado
    : public Printable<Empleado>,
      public Serializable<Empleado>
{
    string nombre_;
    int id_;

public:
    Empleado(const string& n, int id) : nombre_(n), id_(id) {}

    string toString() const {
        return nombre_ + " (ID: " + to_string(id_) + ")";
    }

    string tipoNombre() const { return "Empleado"; }
};

int main() {
    Producto laptop("Laptop", 999.99);
    Producto mouse("Mouse", 29.99);

    // Funcionalidad de Printable
    laptop.imprimir();                           // Laptop ($999.99)
    laptop.imprimirConEtiqueta("Producto");      // Producto: Laptop ($999.99)

    // Funcionalidad de Serializable
    laptop.mostrarSerializado();
    // JSON: { "tipo": "Producto", "datos": "Laptop ($999.99)" }

    // Funcionalidad de Comparable
    cout << "Laptop > Mouse: " << (laptop > mouse ? "sí" : "no") << endl; // sí
    cout << "Laptop == Mouse: " << (laptop == mouse ? "sí" : "no") << endl; // no

    // Empleado usa Printable y Serializable (pero no Comparable)
    Empleado emp("Ana García", 1234);
    emp.imprimir();           // Ana García (ID: 1234)
    emp.mostrarSerializado(); // JSON: { "tipo": "Empleado", "datos": "Ana García (ID: 1234)" }

    // No hay problema del diamante: cada mixin es una plantilla diferente
    // Printable<Producto> y Serializable<Producto> no comparten base común

    return 0;
}
<---Ejemplo de Mixins con CRTP Result--->
