<---EXPLANATION--->
### Sobrecarga de Funciones en Herencia

La sobrecarga de funciones es un concepto importante en la programación orientada a objetos en C++. Permite definir múltiples funciones con el mismo nombre pero con diferentes parámetros en la misma clase o en clases derivadas. En el contexto de herencia, la sobrecarga de funciones se vuelve aún más poderosa, permitiendo a las clases derivadas extender y modificar el comportamiento de las funciones miembro de las clases base.

#### Sobrecarga de Funciones

La sobrecarga de funciones se refiere a la capacidad de definir múltiples funciones con el mismo nombre pero con diferentes listas de parámetros. Esto permite que una función se comporte de manera diferente según los argumentos que se le pasen.

##### Ejemplo Básico de Sobrecarga de Funciones

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

int main() {
    Base b;
    b.mostrar();
    b.mostrar(10);

    return 0;
}
```

En este ejemplo, la clase `Base` tiene dos funciones `mostrar` sobrecargadas: una sin parámetros y otra con un parámetro entero.

#### Sobrecarga de Funciones en Herencia

En herencia, una clase derivada puede sobrecargar funciones miembro de la clase base, proporcionando diferentes versiones de la función en la clase derivada. Esto permite que la clase derivada extienda el comportamiento de la clase base.

##### Ejemplo de Sobrecarga de Funciones en Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
```

En este ejemplo, la clase `Derivada` hereda de `Base` y sobrecarga la función `mostrar` añadiendo una versión que toma un parámetro de tipo `double`. Las funciones `mostrar` de la clase base también están disponibles en la clase derivada.

#### Uso de `using` para Sobrecargar Funciones

En algunos casos, es posible que desee sobrecargar una función de la clase base en la clase derivada y también exponer las versiones de la función de la clase base. Puede utilizar la declaración `using` para hacer esto explícitamente.

##### Ejemplo de Uso de `using`

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    using Base::mostrar; // Hacer visibles las funciones sobrecargadas de la clase base

    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
```

En este ejemplo, `using Base::mostrar;` en la clase `Derivada` hace visibles las funciones `mostrar` sobrecargadas de la clase base, permitiendo que las versiones de la clase base y la nueva versión en la clase derivada se utilicen en la instancia de la clase derivada.

#### Sobrecarga de Operadores en Herencia

Al igual que las funciones miembro, los operadores pueden ser sobrecargados en las clases derivadas. Esto permite que las clases derivadas extiendan el comportamiento de los operadores definidos en las clases base.

##### Ejemplo de Sobrecarga de Operadores en Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Mostrar en la clase Base" << endl;
    }

    virtual void operador() const {
        cout << "Operador en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar() const override {
        cout << "Mostrar en la clase Derivada" << endl;
    }

    void operador() const override {
        cout << "Operador en la clase Derivada" << endl;
    }
};

int main() {
    Base* ptrBase = new Derivada();
    ptrBase->mostrar();    // Llama a Derivada::mostrar()
    ptrBase->operador();   // Llama a Derivada::operador()

    delete ptrBase;
    return 0;
}
```

En este ejemplo, `Derivada` sobrecarga los operadores definidos en la clase `Base`, extendiendo su comportamiento.

#### Reintroducción de Sobrecargas con `using` y Extensión (C++11)

En C++11 y posteriores, la declaración `using Base::funcion;` no solo hace visibles las sobrecargas de la clase base, sino que permite a la clase derivada **añadir nuevas sobrecargas** que coexisten con las heredadas. Esto es especialmente útil cuando una clase derivada necesita extender la funcionalidad sin perder acceso a las versiones originales. Todas las sobrecargas (tanto las de la base como las nuevas de la derivada) participan en la resolución de sobrecarga de forma unificada.

##### Ejemplo de Reintroducción de Sobrecargas con `using` y Extensión

```cpp
#include <iostream>
#include <string>
using namespace std;

class Logger {
public:
    void log(const string& mensaje) {
        cout << "[LOG] " << mensaje << endl;
    }

    void log(int codigo) {
        cout << "[LOG] Codigo de evento: " << codigo << endl;
    }

    void log(const string& nivel, const string& mensaje) {
        cout << "[" << nivel << "] " << mensaje << endl;
    }
};

class FileLogger : public Logger {
private:
    string archivoDestino;

public:
    FileLogger(const string& archivo) : archivoDestino(archivo) {}

    // Trae TODAS las sobrecargas de log() de Logger al scope de FileLogger
    using Logger::log;

    // Nueva sobrecarga exclusiva de FileLogger
    void log(const string& archivo, const string& nivel, const string& mensaje) {
        cout << "[" << nivel << " -> " << archivo << "] " << mensaje << endl;
    }

    // Otra sobrecarga nueva con doble entero
    void log(int codigo, int linea) {
        cout << "[LOG] Codigo: " << codigo << " en linea: " << linea << endl;
    }
};

int main() {
    FileLogger flog("app.log");

    // Sobrecargas heredadas de Logger (accesibles gracias a 'using')
    flog.log("Aplicacion iniciada");           // Logger::log(const string&)
    flog.log(404);                              // Logger::log(int)
    flog.log("WARN", "Memoria baja");           // Logger::log(const string&, const string&)

    // Sobrecargas nuevas de FileLogger
    flog.log("errores.log", "ERROR", "Archivo no encontrado");  // FileLogger::log(3 params)
    flog.log(500, 42);                                            // FileLogger::log(int, int)

    return 0;
}
```

En este ejemplo, `FileLogger` usa `using Logger::log;` para traer las tres sobrecargas de `log()` de la clase `Logger`. Luego, añade dos sobrecargas propias. Todas las versiones de `log()` coexisten y el compilador selecciona la correcta según los argumentos proporcionados.

#### Despacho de Tipos con `if constexpr` (C++17)

C++17 introdujo `if constexpr`, que permite evaluar condiciones en **tiempo de compilación** dentro de funciones template. Esto puede usarse como alternativa a la sobrecarga de funciones cuando se necesita un comportamiento diferente según el tipo del argumento. A diferencia de un `if` normal, las ramas no seleccionadas por `if constexpr` no se compilan, lo que permite usar operaciones específicas de cada tipo sin errores de compilación.

##### Ejemplo de Despacho de Tipos con `if constexpr`

```cpp
#include <iostream>
#include <string>
#include <type_traits>
#include <cmath>
using namespace std;

// Función template que despacha según el tipo en tiempo de compilación
template <typename T>
void procesar(const T& valor) {
    if constexpr (is_integral_v<T>) {
        // Solo se compila cuando T es un tipo entero
        cout << "Entero: " << valor
             << " | Es par: " << (valor % 2 == 0 ? "si" : "no")
             << " | Bits: " << sizeof(T) * 8 << endl;
    }
    else if constexpr (is_floating_point_v<T>) {
        // Solo se compila cuando T es punto flotante
        cout << "Flotante: " << valor
             << " | Parte entera: " << static_cast<long long>(valor)
             << " | Parte decimal: " << fmod(valor, 1.0)
             << " | Precision: " << sizeof(T) << " bytes" << endl;
    }
    else if constexpr (is_same_v<T, string>) {
        // Solo se compila cuando T es std::string
        cout << "String: \"" << valor << "\""
             << " | Longitud: " << valor.length()
             << " | Primera letra: " << (valor.empty() ? '?' : valor[0]) << endl;
    }
    else {
        // Tipo no soportado
        cout << "Tipo no soportado, tamanio: " << sizeof(T) << " bytes" << endl;
    }
}

int main() {
    procesar(42);                // Entero
    procesar(3.14159);           // Flotante (double)
    procesar(2.5f);              // Flotante (float)
    procesar(string("Hola C++")); // String
    procesar(true);              // Entero (bool es integral)

    return 0;
}
```

En este ejemplo, la función `procesar()` usa `if constexpr` para determinar en tiempo de compilación qué bloque de código ejecutar según el tipo `T`. Para enteros se calcula la paridad, para flotantes se separa la parte entera y decimal, y para strings se muestra la longitud. Las ramas que no corresponden al tipo no se compilan, lo que evita errores con operaciones incompatibles (como `%` en strings o `.length()` en enteros).

### Conclusión

La sobrecarga de funciones en herencia es una herramienta poderosa en C++ que permite a las clases derivadas extender y modificar el comportamiento de las funciones miembro de las clases base. Utilizando la declaración `using`, puede exponer las versiones de la función de la clase base en la clase derivada. Además, la sobrecarga de operadores puede ser utilizada de manera similar para extender el comportamiento de los operadores en las clases derivadas. Comprender y utilizar adecuadamente la sobrecarga de funciones en herencia es crucial para aprovechar al máximo las capacidades de la programación orientada a objetos en C++.
<---FILES--->
Ejemplo Básico de Sobrecarga de Funciones
Ejemplo Básico de Sobrecarga de Funciones Result
Ejemplo de Sobrecarga de Funciones en Herencia
Ejemplo de Sobrecarga de Funciones en Herencia Result
Ejemplo de Uso de `using`
Ejemplo de Uso de `using` Result
Ejemplo de Sobrecarga de Operadores en Herencia
Ejemplo de Sobrecarga de Operadores en Herencia Result
Ejemplo de Reintroducción de Sobrecargas con `using` y Extensión
Ejemplo de Reintroducción de Sobrecargas con `using` y Extensión Result
Ejemplo de Despacho de Tipos con `if constexpr`
Ejemplo de Despacho de Tipos con `if constexpr` Result
<---Ejemplo Básico de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

int main() {
    Base b;
    b.mostrar();
    b.mostrar(10);

    return 0;
}
<---Ejemplo Básico de Sobrecarga de Funciones Result--->
<---Ejemplo de Sobrecarga de Funciones en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Sobrecarga de Funciones en Herencia Result--->
<---Ejemplo de Uso de `using`--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    void mostrar() {
        cout << "Mostrar sin parámetros en la clase Base" << endl;
    }

    void mostrar(int x) {
        cout << "Mostrar con un parámetro en la clase Base: " << x << endl;
    }
};

class Derivada : public Base {
public:
    using Base::mostrar; // Hacer visibles las funciones sobrecargadas de la clase base

    void mostrar(double y) {
        cout << "Mostrar con un parámetro double en la clase Derivada: " << y << endl;
    }
};

int main() {
    Derivada d;
    d.mostrar();       // Llama a Base::mostrar()
    d.mostrar(10);     // Llama a Base::mostrar(int)
    d.mostrar(3.14);   // Llama a Derivada::mostrar(double)

    return 0;
}
<---Ejemplo de Uso de `using` Result--->
<---Ejemplo de Sobrecarga de Operadores en Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual void mostrar() const {
        cout << "Mostrar en la clase Base" << endl;
    }

    virtual void operador() const {
        cout << "Operador en la clase Base" << endl;
    }
};

class Derivada : public Base {
public:
    void mostrar() const override {
        cout << "Mostrar en la clase Derivada" << endl;
    }

    void operador() const override {
        cout << "Operador en la clase Derivada" << endl;
    }
};

int main() {
    Base* ptrBase = new Derivada();
    ptrBase->mostrar();    // Llama a Derivada::mostrar()
    ptrBase->operador();   // Llama a Derivada::operador()

    delete ptrBase;
    return 0;
}
<---Ejemplo de Sobrecarga de Operadores en Herencia Result--->
<---Ejemplo de Reintroducción de Sobrecargas con `using` y Extensión--->
```cpp
#include <iostream>
#include <string>
using namespace std;

class Logger {
public:
    void log(const string& mensaje) {
        cout << "[LOG] " << mensaje << endl;
    }

    void log(int codigo) {
        cout << "[LOG] Codigo de evento: " << codigo << endl;
    }

    void log(const string& nivel, const string& mensaje) {
        cout << "[" << nivel << "] " << mensaje << endl;
    }
};

class FileLogger : public Logger {
private:
    string archivoDestino;

public:
    FileLogger(const string& archivo) : archivoDestino(archivo) {}

    // Trae TODAS las sobrecargas de log() de Logger al scope de FileLogger
    using Logger::log;

    // Nueva sobrecarga exclusiva de FileLogger
    void log(const string& archivo, const string& nivel, const string& mensaje) {
        cout << "[" << nivel << " -> " << archivo << "] " << mensaje << endl;
    }

    // Otra sobrecarga nueva con doble entero
    void log(int codigo, int linea) {
        cout << "[LOG] Codigo: " << codigo << " en linea: " << linea << endl;
    }
};

int main() {
    FileLogger flog("app.log");

    // Sobrecargas heredadas de Logger (accesibles gracias a 'using')
    flog.log("Aplicacion iniciada");           // Logger::log(const string&)
    flog.log(404);                              // Logger::log(int)
    flog.log("WARN", "Memoria baja");           // Logger::log(const string&, const string&)

    // Sobrecargas nuevas de FileLogger
    flog.log("errores.log", "ERROR", "Archivo no encontrado");  // FileLogger::log(3 params)
    flog.log(500, 42);                                            // FileLogger::log(int, int)

    return 0;
}
<---Ejemplo de Reintroducción de Sobrecargas con `using` y Extensión Result--->
<---Ejemplo de Despacho de Tipos con `if constexpr`--->
```cpp
#include <iostream>
#include <string>
#include <type_traits>
#include <cmath>
using namespace std;

// Función template que despacha según el tipo en tiempo de compilación
template <typename T>
void procesar(const T& valor) {
    if constexpr (is_integral_v<T>) {
        // Solo se compila cuando T es un tipo entero
        cout << "Entero: " << valor
             << " | Es par: " << (valor % 2 == 0 ? "si" : "no")
             << " | Bits: " << sizeof(T) * 8 << endl;
    }
    else if constexpr (is_floating_point_v<T>) {
        // Solo se compila cuando T es punto flotante
        cout << "Flotante: " << valor
             << " | Parte entera: " << static_cast<long long>(valor)
             << " | Parte decimal: " << fmod(valor, 1.0)
             << " | Precision: " << sizeof(T) << " bytes" << endl;
    }
    else if constexpr (is_same_v<T, string>) {
        // Solo se compila cuando T es std::string
        cout << "String: \"" << valor << "\""
             << " | Longitud: " << valor.length()
             << " | Primera letra: " << (valor.empty() ? '?' : valor[0]) << endl;
    }
    else {
        // Tipo no soportado
        cout << "Tipo no soportado, tamanio: " << sizeof(T) << " bytes" << endl;
    }
}

int main() {
    procesar(42);                // Entero
    procesar(3.14159);           // Flotante (double)
    procesar(2.5f);              // Flotante (float)
    procesar(string("Hola C++")); // String
    procesar(true);              // Entero (bool es integral)

    return 0;
}
<---Ejemplo de Despacho de Tipos con `if constexpr` Result--->
