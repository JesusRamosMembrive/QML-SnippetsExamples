<---EXPLANATION--->
### Introducción a las Plantillas en C++

Las plantillas en C++ son una característica poderosa que permite escribir código genérico, capaz de trabajar con cualquier tipo de dato. Esto facilita la reutilización de código y la creación de funciones y clases que operan de manera eficiente con diferentes tipos de datos.

#### Definición de Plantillas de Función

Las plantillas de función permiten crear funciones que pueden trabajar con cualquier tipo de dato.

##### Ejemplo Básico

```cpp
// plantilla_funcion.cpp
#include <iostream>

template <typename T>
T obtenerMayor(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    std::cout << "Mayor entre 3 y 7: " << obtenerMayor(3, 7) << std::endl;
    std::cout << "Mayor entre 5.5 y 2.2: " << obtenerMayor(5.5, 2.2) << std::endl;
    return 0;
}
```

En este ejemplo:
- La función `obtenerMayor` utiliza una plantilla para trabajar con cualquier tipo de dato (`int`, `double`, etc.).
- La palabra clave `template` seguida de `<typename T>` define una plantilla de función donde `T` es un parámetro de tipo.

#### Definición de Plantillas de Clase

Las plantillas de clase permiten crear clases genéricas que pueden manejar diferentes tipos de datos.

##### Ejemplo Básico

```cpp
// plantilla_clase.h
#ifndef PLANTILLA_CLASE_H
#define PLANTILLA_CLASE_H

template <typename T>
class MiClase {
public:
    MiClase(T valor);
    void mostrarValor();
private:
    T valor;
};

#include "plantilla_clase.cpp"
#endif // PLANTILLA_CLASE_H
```

```cpp
// plantilla_clase.cpp
#include <iostream>
#include "plantilla_clase.h"

template <typename T>
MiClase<T>::MiClase(T v) : valor(v) {}

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}
```

```cpp
// main.cpp
#include "plantilla_clase.h"

int main() {
    MiClase<int> obj1(5);
    obj1.mostrarValor();
    
    MiClase<double> obj2(3.14);
    obj2.mostrarValor();

    return 0;
}
```

En este ejemplo:
- La clase `MiClase` es una plantilla que puede manejar diferentes tipos de datos (`int`, `double`, etc.).
- La palabra clave `template` seguida de `<typename T>` define una plantilla de clase.
- La implementación de los métodos de la plantilla de clase se encuentra en un archivo separado (`plantilla_clase.cpp`), y se incluye al final del archivo de cabecera.

### Buenas Prácticas para el Uso de Plantillas

#### 1. Mantener la Implementación de Plantillas en el Archivo de Cabecera

Aunque se puede separar la declaración y la implementación de plantillas en archivos `.h` y `.cpp` respectivamente, a menudo se recomienda mantener ambas en el archivo de cabecera para evitar problemas de enlace.

##### Ejemplo

```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <iostream>

template <typename T>
class MiClase {
public:
    MiClase(T valor) : valor(valor) {}
    void mostrarValor();
private:
    T valor;
};

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}

#endif // MICLASE_H
```

#### 2. Utilizar Nombres Significativos para Parámetros de Tipo

Utilice nombres de parámetros de tipo que sean significativos para mejorar la legibilidad del código.

##### Ejemplo

```cpp
template <typename Tipo>
class Contenedor {
    Tipo elemento;
public:
    Contenedor(Tipo e) : elemento(e) {}
    Tipo obtenerElemento() { return elemento; }
};
```

#### 3. Documentar las Plantillas Adecuadamente

Asegúrese de documentar las plantillas para explicar el propósito de los parámetros de tipo y cómo se deben utilizar.

##### Ejemplo

```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <iostream>

// Clase plantilla que almacena y muestra un valor de cualquier tipo
template <typename T>
class MiClase {
public:
    // Constructor que inicializa el valor
    MiClase(T valor) : valor(valor) {}
    // Muestra el valor almacenado en la salida estándar
    void mostrarValor();
private:
    T valor; // El valor almacenado, de tipo T
};

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}

#endif // MICLASE_H
```

### Plantillas en el Ecosistema de Qt

Qt hace un uso extensivo de las plantillas para sus clases base, contenedores y utilidades, permitiendo que el framework sea flexible y soporte tipos personalizados.

#### Contenedores Genéricos de Qt

Clases como `QList<T>`, `QVector<T>` y `QMap<Key, T>` son plantillas que funcionan de manera similar a la STL, pero con optimizaciones específicas (como la compartición implícita).

```cpp
#include <QVector>
#include <QString>
#include <QDebug>

void ejemploContenedoresQt() {
    // Definimos un vector genérico de enteros
    QVector<int> numeros = {10, 20, 30};
    numeros.append(40);

    // Definimos un vector genérico de cadenas
    QVector<QString> nombres;
    nombres << "Ana" << "Carlos"; // Uso de operador sobrecargado en plantilla

    qDebug() << "Números:" << numeros;
    qDebug() << "Nombres:" << nombres;
}
```

#### Funciones Útiles: `qMax`, `qMin` y `qBound`

Qt proporciona funciones globales que son plantillas para operaciones comunes, evitando la necesidad de reescribirlas para cada tipo.

```cpp
#include <QtGlobal>
#include <QDebug>

void ejemploFuncionesQt() {
    int m1 = qMax(10, 20);           // Retorna 20
    double m2 = qMax(15.5, 12.2);    // Retorna 15.5
    
    // qBound asegura que un valor esté dentro de un rango
    int valor = qBound(0, 150, 100); // Retorna 100 (está en el rango)
    int fuera = qBound(0, -50, 100); // Retorna 0 (ajusta al límite inferior)

    qDebug() << "Máximo:" << m1 << m2;
}
```

### Conclusión

Las plantillas en C++ son una herramienta poderosa para escribir código genérico y reutilizable. Al seguir buenas prácticas como mantener la implementación en el archivo de cabecera, utilizar nombres significativos para los parámetros de tipo y documentar adecuadamente, se puede crear código claro y mantenible. Las plantillas permiten a los desarrolladores escribir funciones y clases que trabajan de manera eficiente con cualquier tipo de dato, mejorando la flexibilidad y reutilización del código.
<---FILES--->
Ejemplo Básico
Ejemplo Básico Result
Ejemplo
Ejemplo Result
<---Ejemplo Básico--->
```cpp
// plantilla_clase.h
#ifndef PLANTILLA_CLASE_H
#define PLANTILLA_CLASE_H

template <typename T>
class MiClase {
public:
    MiClase(T valor);
    void mostrarValor();
private:
    T valor;
};

#include "plantilla_clase.cpp"
#endif // PLANTILLA_CLASE_H
```cpp
// plantilla_clase.cpp
#include <iostream>
#include "plantilla_clase.h"

template <typename T>
MiClase<T>::MiClase(T v) : valor(v) {}

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}
```cpp
// main.cpp
#include "plantilla_clase.h"

int main() {
    MiClase<int> obj1(5);
    obj1.mostrarValor();
    
    MiClase<double> obj2(3.14);
    obj2.mostrarValor();

    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo--->
```cpp
// MiClase.h
#ifndef MICLASE_H
#define MICLASE_H

#include <iostream>

// Clase plantilla que almacena y muestra un valor de cualquier tipo
template <typename T>
class MiClase {
public:
    // Constructor que inicializa el valor
    MiClase(T valor) : valor(valor) {}
    // Muestra el valor almacenado en la salida estándar
    void mostrarValor();
private:
    T valor; // El valor almacenado, de tipo T
};

template <typename T>
void MiClase<T>::mostrarValor() {
    std::cout << "El valor es: " << valor << std::endl;
}

#endif // MICLASE_H
<---Ejemplo Result--->
