<---EXPLANATION--->
### Control de Flujo: Bucles en C++

Los bucles son estructuras de control de flujo que permiten ejecutar un bloque de código repetidamente. C++ proporciona varios tipos de bucles: `for`, `while`, y `do-while`, cada uno con sus propias características y usos específicos.

#### 1. **Bucle `for`**

El bucle `for` se utiliza cuando se conoce de antemano el número de iteraciones que se desea realizar. Se compone de tres partes: inicialización, condición y actualización.

##### Sintaxis Básica

```cpp
for (inicializacion; condicion; actualizacion) {
    // Código a ejecutar en cada iteración
}
```

##### Ejemplo

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 0; i < 10; ++i) {
        cout << "Iteración " << i << endl;
    }
    return 0;
}
```

#### 2. **Bucle `while`**

El bucle `while` se utiliza cuando se desea repetir un bloque de código mientras se cumpla una condición específica. La condición se evalúa antes de cada iteración.

##### Sintaxis Básica

```cpp
while (condicion) {
    // Código a ejecutar en cada iteración
}
```

##### Ejemplo

```cpp
#include <iostream>
using namespace std;

int main() {
    int i = 0;
    while (i < 10) {
        cout << "Iteración " << i << endl;
        ++i;
    }
    return 0;
}
```

#### 3. **Bucle `do-while`**

El bucle `do-while` es similar al bucle `while`, pero garantiza que el bloque de código se ejecuta al menos una vez, ya que la condición se evalúa al final de cada iteración.

##### Sintaxis Básica

```cpp
do {
    // Código a ejecutar en cada iteración
} while (condicion);
```

##### Ejemplo

```cpp
#include <iostream>
using namespace std;

int main() {
    int i = 0;
    do {
        cout << "Iteración " << i << endl;
        ++i;
    } while (i < 10);
    return 0;
}
```

### Bucles Anidados

Los bucles pueden anidarse, lo que significa que un bucle puede contener otro bucle dentro de su cuerpo. Esto es útil para trabajar con estructuras de datos multidimensionales, como matrices.

##### Ejemplo de Bucles Anidados

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 5; ++j) {
            cout << "(" << i << ", " << j << ") ";
        }
        cout << endl;
    }
    return 0;
}
```

### Control de Flujo en Bucles

- **`break`**: Termina el bucle inmediatamente.
- **`continue`**: Salta la iteración actual y continúa con la siguiente iteración del bucle.

##### Ejemplo de `break` y `continue`

```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 0; i < 10; ++i) {
        if (i == 5) {
            break; // Salir del bucle cuando i es 5
        }
        if (i % 2 == 0) {
            continue; // Saltar los números pares
        }
        cout << "Iteración " << i << endl;
    }
    return 0;
}
```

### Bucles con Rango (C++11 y Posterior)

El bucle `for` basado en rango simplifica la iteración sobre contenedores, como vectores y arrays, introducido en C++11.

##### Ejemplo de Bucle con Rango

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> numeros = {1, 2, 3, 4, 5};

    for (int numero : numeros) {
        cout << "Número: " << numero << endl;
    }

    return 0;
}
```

### Buenas Prácticas

- **Evitar Bucles Infinito:** Asegúrate de que las condiciones de terminación de los bucles se cumplan para evitar bucles infinitos.
- **Usar Comentarios:** Documenta bucles complejos con comentarios claros.
- **Evitar Uso Excesivo de `break` y `continue`:** Aunque útiles, un uso excesivo puede hacer que el código sea difícil de leer y mantener. Utilízalos con moderación y cuando sea absolutamente necesario.

### Ejemplo Completo

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    // Bucle for
    for (int i = 0; i < 5; ++i) {
        cout << "For loop, iteración: " << i << endl;
    }

    // Bucle while
    int j = 0;
    while (j < 5) {
        cout << "While loop, iteración: " << j << endl;
        ++j;
    }

    // Bucle do-while
    int k = 0;
    do {
        cout << "Do-While loop, iteración: " << k << endl;
        ++k;
    } while (k < 5);

    // Bucle for con rango
    vector<int> numeros = {10, 20, 30, 40, 50};
    for (int numero : numeros) {
        cout << "Bucle con rango, número: " << numero << endl;
    }

    // Bucle anidado
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            cout << "(" << i << ", " << j << ") ";
        }
        cout << endl;
    }

    return 0;
}
```

### Bucles con Contenedores Qt

#### Range-for con `QList`, `QStringList`, `QMap`

El range-for de C++11 funciona directamente con contenedores Qt:

```cpp
#include <QList>
#include <QMap>
#include <QDebug>

QList<int> numeros = {1, 2, 3, 4, 5};
for (int n : numeros) {
    qDebug() << n;
}

QStringList nombres = {"Ana", "Carlos", "Lucía"};
for (const QString &nombre : nombres) {
    qDebug() << nombre;
}
```

#### Cuidado con la copia implícita (detach)

Los contenedores Qt usan **Copy-on-Write (COW)**. Al iterar con range-for sobre un contenedor no-const, Qt puede hacer una copia innecesaria (detach). Para evitarlo, usa `std::as_const()` o `qAsConst()`:

```cpp
QList<int> numeros = {1, 2, 3};

// MAL: puede causar detach si 'numeros' no es const
for (int n : numeros) { ... }

// BIEN: fuerza iterador const, evita detach
for (int n : std::as_const(numeros)) { ... }
for (int n : qAsConst(numeros)) { ... }  // Equivalente Qt
```

#### Iterar sobre `QMap` / `QHash`

```cpp
QMap<QString, int> edades = {{"Ana", 25}, {"Carlos", 30}};

// Iterar sobre claves
for (const QString &nombre : edades.keys()) {
    qDebug() << nombre << ":" << edades[nombre];
}

// Iterar con iterador (más eficiente, evita crear lista de keys)
for (auto it = edades.cbegin(); it != edades.cend(); ++it) {
    qDebug() << it.key() << ":" << it.value();
}
```

#### `QListIterator` de Java-style (legacy)

Qt también ofrece iteradores estilo Java, aunque el range-for es preferido en código moderno:

```cpp
QListIterator<int> it(numeros);
while (it.hasNext()) {
    qDebug() << it.next();
}
```

### Conclusión

Comprender y utilizar correctamente los diferentes tipos de bucles en C++ es fundamental para controlar el flujo de ejecución de un programa y realizar tareas repetitivas de manera eficiente. Cada tipo de bucle tiene sus propias ventajas y se adapta a diferentes situaciones de programación, lo que permite escribir código más limpio, legible y eficiente.
<---FILES--->
Bucle do-while
Bucle do-while Result
Bucles Anidados
Bucles Anidados Result
break y continue
break y continue Result
Bucle con Rango
Bucle con Rango Result
Ejemplo Completo
Ejemplo Completo Result
<---Bucle do-while--->
```cpp
#include <iostream>
using namespace std;

int main() {
    int i = 0;
    do {
        cout << "Iteración " << i << endl;
        ++i;
    } while (i < 10);
    return 0;
}
```
<---Bucle do-while Result--->
<---Bucles Anidados--->
```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 0; i < 5; ++i) {
        for (int j = 0; j < 5; ++j) {
            cout << "(" << i << ", " << j << ") ";
        }
        cout << endl;
    }
    return 0;
}
```
<---Bucles Anidados Result--->
<---break y continue--->
```cpp
#include <iostream>
using namespace std;

int main() {
    for (int i = 0; i < 10; ++i) {
        if (i == 5) break;
        if (i % 2 == 0) continue;
        cout << "Iteración " << i << endl;
    }
    return 0;
}
```
<---break y continue Result--->
<---Bucle con Rango--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> numeros = {1, 2, 3, 4, 5};
    for (int numero : numeros) {
        cout << "Número: " << numero << endl;
    }
    return 0;
}
```
<---Bucle con Rango Result--->
<---Ejemplo Completo--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    for (int i = 0; i < 5; ++i)
        cout << "For: " << i << endl;

    int j = 0;
    while (j < 5) { cout << "While: " << j << endl; ++j; }

    int k = 0;
    do { cout << "Do-While: " << k << endl; ++k; } while (k < 5);

    vector<int> nums = {10, 20, 30, 40, 50};
    for (int n : nums) cout << "Rango: " << n << endl;

    return 0;
}
```
<---Ejemplo Completo Result--->
