<---EXPLANATION--->
### Funciones con Tipo de Dato Deducido en el Retorno en C++

En C++14, se introdujo la capacidad de deducir el tipo de retorno de una función automáticamente utilizando la palabra clave `auto`. Esta característica simplifica la declaración de funciones, especialmente cuando el tipo de retorno es complicado o depende de los parámetros de la función. A partir de C++14, esta funcionalidad se amplía con `decltype(auto)`, que proporciona aún más flexibilidad.

#### `auto` para la Deducción del Tipo de Retorno

La palabra clave `auto` permite al compilador deducir el tipo de retorno de una función basándose en la expresión de retorno dentro de la función.

##### Sintaxis

```cpp
auto nombre_funcion(parametros) {
    // Cuerpo de la función
    return expresion;
}
```

##### Ejemplo Básico

```cpp
#include <iostream>
using namespace std;

auto sumar(int a, int b) {
    return a + b;
}

int main() {
    auto resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;
    return 0;
}
```

En este ejemplo, el compilador deduce que la función `sumar` devuelve un `int` porque la expresión `a + b` es de tipo `int`.

#### `decltype(auto)` para la Deducción del Tipo de Retorno

La palabra clave `decltype(auto)` se utiliza cuando se desea que el tipo de retorno sea exactamente el tipo deducido de la expresión de retorno, incluyendo referencias.

##### Sintaxis

```cpp
decltype(auto) nombre_funcion(parametros) {
    // Cuerpo de la función
    return expresion;
}
```

##### Ejemplo con `decltype(auto)`

```cpp
#include <iostream>
using namespace std;

int global = 10;

decltype(auto) obtenerGlobal() {
    return global;
}

decltype(auto) obtenerReferenciaGlobal() {
    return (global);
}

int main() {
    auto valor = obtenerGlobal();
    cout << "Valor: " << valor << endl;

    obtenerReferenciaGlobal() = 20;
    cout << "Nuevo valor global: " << global << endl;

    return 0;
}
```

En este ejemplo:
- `obtenerGlobal` devuelve una copia de `global`.
- `obtenerReferenciaGlobal` devuelve una referencia a `global`, permitiendo modificar la variable global.

#### Ventajas de Usar `auto` y `decltype(auto)`

1. **Simplicidad:** Simplifica la declaración de funciones, especialmente para tipos de retorno complejos.
2. **Flexibilidad:** Permite que el tipo de retorno se adapte automáticamente a cambios en el cuerpo de la función.
3. **Mantenimiento:** Reduce la necesidad de actualizar la declaración de la función si se cambia el tipo de retorno.

#### Ejemplos Adicionales

##### Función con Tipo de Retorno Complicado

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

auto encontrarMaximo(const vector<int>& vec) {
    return max_element(vec.begin(), vec.end());
}

int main() {
    vector<int> numeros = {1, 3, 5, 7, 9};
    auto it = encontrarMaximo(numeros);
    if (it != numeros.end()) {
        cout << "El valor máximo es: " << *it << endl;
    }
    return 0;
}
```

En este ejemplo, `encontrarMaximo` devuelve un iterador al elemento máximo del vector, y el tipo de retorno se deduce automáticamente.

##### Función que Devuelve un `std::pair`

```cpp
#include <iostream>
#include <utility>
using namespace std;

auto crearPar(int a, double b) {
    return make_pair(a, b);
}

int main() {
    auto p = crearPar(5, 3.14);
    cout << "Par: (" << p.first << ", " << p.second << ")" << endl;
    return 0;
}
```

En este ejemplo, `crearPar` devuelve un `std::pair<int, double>` y el tipo de retorno se deduce automáticamente.

##### Uso de `decltype(auto)` para Tipos de Retorno con Referencias

```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> vec = {1, 2, 3, 4, 5};

decltype(auto) obtenerElemento(size_t index) {
    return (vec[index]);
}

int main() {
    auto& elem = obtenerElemento(2);
    cout << "Elemento original: " << elem << endl;

    // Modificar el elemento
    elem = 10;
    cout << "Elemento modificado: " << vec[2] << endl;

    return 0;
}
```

En este ejemplo, `obtenerElemento` devuelve una referencia al elemento del vector, permitiendo modificar el elemento directamente.

### Trailing Return Type (C++11)

El *trailing return type* (tipo de retorno al final) es una sintaxis introducida en C++11 que permite especificar el tipo de retorno de una función después de la lista de parámetros, usando la flecha `->`. Esta sintaxis es especialmente útil en funciones template donde el tipo de retorno depende de los tipos de los parámetros, ya que en la posición tradicional (antes del nombre de la función) los parámetros aún no están declarados.

También se combina con `decltype` para deducir el tipo de retorno basándose en una expresión que involucra los parámetros.

##### Ejemplo de Trailing Return Type

```cpp
#include <iostream>
#include <vector>
using namespace std;

// Trailing return type: tipo de retorno al final
auto sumar(int a, double b) -> double {
    return a + b;
}

// Útil con templates donde el tipo depende de los parámetros
template<typename T, typename U>
auto multiplicar(T a, U b) -> decltype(a * b) {
    return a * b;
}

int main() {
    cout << sumar(3, 2.5) << endl;         // 5.5
    cout << multiplicar(3, 2.5) << endl;   // 7.5
    cout << multiplicar(4, 5) << endl;     // 20
    return 0;
}
```

En este ejemplo, `sumar` utiliza la sintaxis de trailing return type para indicar explícitamente que devuelve `double`. La función template `multiplicar` usa `decltype(a * b)` para deducir automáticamente el tipo de retorno según los tipos de los argumentos.

### Concepts y `auto` Restringido (C++20)

C++20 introduce los *concepts*, que permiten restringir los tipos que acepta una función template. Combinados con `auto` en los parámetros, los concepts proporcionan una forma clara y legible de especificar requisitos sobre los tipos, generando mensajes de error mucho más comprensibles que los templates tradicionales.

Con `auto` restringido, se puede anteponer un concept al parámetro `auto` para limitar los tipos aceptados. Además, se pueden crear concepts personalizados usando la palabra clave `concept` y expresiones `requires`.

##### Ejemplo de Concepts y `auto` Restringido

```cpp
#include <iostream>
#include <concepts>
#include <string>
using namespace std;

// auto restringido con concepts
auto sumarNumeros(integral auto a, integral auto b) {
    return a + b;
}

auto dividir(floating_point auto a, floating_point auto b) {
    return a / b;
}

// Concept personalizado
template<typename T>
concept Printable = requires(T t) {
    { cout << t } -> same_as<ostream&>;
};

auto formatear(Printable auto valor) {
    cout << "Valor: " << valor << endl;
    return valor;
}

int main() {
    cout << sumarNumeros(3, 4) << endl;     // OK
    // sumarNumeros(3.14, 2.7);              // ERROR: no es integral
    cout << dividir(10.0, 3.0) << endl;     // OK
    formatear(42);
    formatear("texto");
    return 0;
}
```

En este ejemplo, `sumarNumeros` solo acepta tipos integrales (`int`, `long`, etc.) y `dividir` solo acepta tipos de punto flotante (`float`, `double`). El concept personalizado `Printable` verifica que el tipo pueda ser impreso con `cout`.

### Conclusión

El uso de `auto` y `decltype(auto)` para deducir el tipo de retorno de funciones en C++ mejora la flexibilidad y simplicidad del código, especialmente para funciones con tipos de retorno complejos o cuando se requiere mantener la compatibilidad con referencias. Estas características permiten a los desarrolladores escribir código más claro y adaptable, facilitando el mantenimiento y la evolución del software.
<---FILES--->
Sintaxis
Sintaxis Result
Ejemplo Básico
Ejemplo Básico Result
Ejemplo con `decltype(auto)`
Ejemplo con `decltype(auto)` Result
Función con Tipo de Retorno Complicado
Función con Tipo de Retorno Complicado Result
Función que Devuelve un `std::pair`
Función que Devuelve un `std::pair` Result
Uso de `decltype(auto)` para Tipos de Retorno con Referencias
Uso de `decltype(auto)` para Tipos de Retorno con Referencias Result
Ejemplo de Trailing Return Type
Ejemplo de Trailing Return Type Result
Ejemplo de Concepts y `auto` Restringido
Ejemplo de Concepts y `auto` Restringido Result
<---Sintaxis--->
```cpp
decltype(auto) nombre_funcion(parametros) {
    // Cuerpo de la función
    return expresion;
}
<---Sintaxis Result--->
<---Ejemplo Básico--->
```cpp
#include <iostream>
using namespace std;

auto sumar(int a, int b) {
    return a + b;
}

int main() {
    auto resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;
    return 0;
}
<---Ejemplo Básico Result--->
<---Ejemplo con `decltype(auto)`--->
```cpp
#include <iostream>
using namespace std;

int global = 10;

decltype(auto) obtenerGlobal() {
    return global;
}

decltype(auto) obtenerReferenciaGlobal() {
    return (global);
}

int main() {
    auto valor = obtenerGlobal();
    cout << "Valor: " << valor << endl;

    obtenerReferenciaGlobal() = 20;
    cout << "Nuevo valor global: " << global << endl;

    return 0;
}
<---Ejemplo con `decltype(auto)` Result--->
<---Función con Tipo de Retorno Complicado--->
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

auto encontrarMaximo(const vector<int>& vec) {
    return max_element(vec.begin(), vec.end());
}

int main() {
    vector<int> numeros = {1, 3, 5, 7, 9};
    auto it = encontrarMaximo(numeros);
    if (it != numeros.end()) {
        cout << "El valor máximo es: " << *it << endl;
    }
    return 0;
}
<---Función con Tipo de Retorno Complicado Result--->
<---Función que Devuelve un `std::pair`--->
```cpp
#include <iostream>
#include <utility>
using namespace std;

auto crearPar(int a, double b) {
    return make_pair(a, b);
}

int main() {
    auto p = crearPar(5, 3.14);
    cout << "Par: (" << p.first << ", " << p.second << ")" << endl;
    return 0;
}
<---Función que Devuelve un `std::pair` Result--->
<---Uso de `decltype(auto)` para Tipos de Retorno con Referencias--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int> vec = {1, 2, 3, 4, 5};

decltype(auto) obtenerElemento(size_t index) {
    return (vec[index]);
}

int main() {
    auto& elem = obtenerElemento(2);
    cout << "Elemento original: " << elem << endl;

    // Modificar el elemento
    elem = 10;
    cout << "Elemento modificado: " << vec[2] << endl;

    return 0;
}
<---Uso de `decltype(auto)` para Tipos de Retorno con Referencias Result--->
<---Ejemplo de Trailing Return Type--->
```cpp
#include <iostream>
#include <vector>
using namespace std;

// Trailing return type: tipo de retorno al final
auto sumar(int a, double b) -> double {
    return a + b;
}

// Útil con templates donde el tipo depende de los parámetros
template<typename T, typename U>
auto multiplicar(T a, U b) -> decltype(a * b) {
    return a * b;
}

int main() {
    cout << sumar(3, 2.5) << endl;         // 5.5
    cout << multiplicar(3, 2.5) << endl;   // 7.5
    cout << multiplicar(4, 5) << endl;     // 20
    return 0;
}
<---Ejemplo de Trailing Return Type Result--->
<---Ejemplo de Concepts y `auto` Restringido--->
```cpp
#include <iostream>
#include <concepts>
#include <string>
using namespace std;

// auto restringido con concepts
auto sumarNumeros(integral auto a, integral auto b) {
    return a + b;
}

auto dividir(floating_point auto a, floating_point auto b) {
    return a / b;
}

// Concept personalizado
template<typename T>
concept Printable = requires(T t) {
    { cout << t } -> same_as<ostream&>;
};

auto formatear(Printable auto valor) {
    cout << "Valor: " << valor << endl;
    return valor;
}

int main() {
    cout << sumarNumeros(3, 4) << endl;     // OK
    // sumarNumeros(3.14, 2.7);              // ERROR: no es integral
    cout << dividir(10.0, 3.0) << endl;     // OK
    formatear(42);
    formatear("texto");
    return 0;
}
<---Ejemplo de Concepts y `auto` Restringido Result--->
