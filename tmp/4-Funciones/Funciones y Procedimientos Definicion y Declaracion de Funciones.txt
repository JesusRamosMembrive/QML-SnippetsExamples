<---EXPLANATION--->
### Funciones y Procedimientos en C++: Definición y Declaración de Funciones

Las funciones en C++ son bloques de código que realizan una tarea específica y pueden ser llamadas desde diferentes partes de un programa. Definir y declarar funciones es fundamental para estructurar y modularizar el código, facilitando la reutilización y el mantenimiento.

#### Declaración de Funciones

La declaración de una función (también conocida como prototipo de función) informa al compilador sobre la existencia de una función antes de su definición real. La declaración incluye el tipo de retorno, el nombre de la función y los tipos de parámetros.

##### Sintaxis de la Declaración de Funciones

```cpp
tipo_retorno nombre_funcion(lista_de_parametros);
```

- **tipo_retorno**: El tipo de dato que devuelve la función.
- **nombre_funcion**: El identificador de la función.
- **lista_de_parametros**: Los tipos y nombres de los parámetros que acepta la función.

##### Ejemplo de Declaración de Función

```cpp
int sumar(int a, int b);
void mostrarMensaje(string mensaje);
```

En este ejemplo:
- `int sumar(int a, int b);` declara una función que toma dos enteros y devuelve un entero.
- `void mostrarMensaje(string mensaje);` declara una función que toma una cadena y no devuelve nada.

#### Definición de Funciones

La definición de una función proporciona el cuerpo de la función, es decir, el bloque de código que se ejecuta cuando se llama a la función. La definición incluye la declaración de la función y el bloque de código asociado.

##### Sintaxis de la Definición de Funciones

```cpp
tipo_retorno nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
}
```

##### Ejemplo de Definición de Función

```cpp
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
```

En este ejemplo:
- `int sumar(int a, int b) { return a + b; }` define una función que suma dos enteros y devuelve el resultado.
- `void mostrarMensaje(string mensaje) { cout << mensaje << endl; }` define una función que muestra un mensaje en la consola.

#### Ejemplo Completo: Declaración y Definición de Funciones

```cpp
#include <iostream>
using namespace std;

// Declaraciones de funciones
int sumar(int a, int b);
void mostrarMensaje(string mensaje);

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;

    mostrarMensaje("Hola, mundo!");

    return 0;
}

// Definiciones de funciones
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
```

En este ejemplo completo:
- Las funciones `sumar` y `mostrarMensaje` se declaran antes del `main`.
- Las definiciones de las funciones `sumar` y `mostrarMensaje` proporcionan los cuerpos de las funciones después del `main`.

#### Funciones con Parámetros por Valor y por Referencia

En C++, los parámetros de las funciones pueden pasarse por valor o por referencia.

##### Parámetros por Valor

Los parámetros por valor se copian en los parámetros de la función. Los cambios en los parámetros dentro de la función no afectan a los argumentos originales.

```cpp
void incrementarPorValor(int x) {
    x++;
}

int main() {
    int numero = 5;
    incrementarPorValor(numero);
    cout << "Número después de incrementar por valor: " << numero << endl; // Salida: 5
    return 0;
}
```

##### Parámetros por Referencia

Los parámetros por referencia permiten que la función modifique los argumentos originales. Se utilizan referencias (`&`) en la lista de parámetros.

```cpp
void incrementarPorReferencia(int& x) {
    x++;
}

int main() {
    int numero = 5;
    incrementarPorReferencia(numero);
    cout << "Número después de incrementar por referencia: " << numero << endl; // Salida: 6
    return 0;
}
```

#### Sobrecarga de Funciones

C++ permite la sobrecarga de funciones, es decir, varias funciones pueden tener el mismo nombre pero diferentes listas de parámetros.

##### Ejemplo de Sobrecarga de Funciones

```cpp
#include <iostream>
using namespace std;

int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

int main() {
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    return 0;
}
```

### Atributo `[[nodiscard]]` (C++17)

El atributo `[[nodiscard]]` se aplica a funciones para indicar al compilador que el valor de retorno no debe ser ignorado. Si el programador llama a la función y descarta el resultado, el compilador emitirá una advertencia. Esto es útil para funciones donde ignorar el valor de retorno probablemente sea un error lógico, como cálculos matemáticos, validaciones o funciones que devuelven códigos de error.

##### Ejemplo de `[[nodiscard]]`

```cpp
#include <iostream>
using namespace std;

[[nodiscard]] int calcular(int a, int b) {
    return a + b;
}

int main() {
    // calcular(3, 4); // Warning: resultado descartado
    int r = calcular(3, 4); // Correcto
    cout << "Resultado: " << r << endl;
    return 0;
}
```

En este ejemplo, si se llama a `calcular(3, 4)` sin capturar el resultado, el compilador generará una advertencia indicando que el valor de retorno está siendo descartado.

### Funciones en Qt: `Q_INVOKABLE` y Slots

En el framework Qt, las funciones de clases C++ pueden exponerse al sistema de meta-objetos mediante dos mecanismos principales: `Q_INVOKABLE` y los slots.

- **`Q_INVOKABLE`**: Este macro permite que una función miembro sea invocable desde QML y desde el sistema de meta-objetos de Qt. Es ideal para funciones que necesitan ser llamadas desde la interfaz QML pero que no necesitan conectarse a señales.

- **Slots (`public slots`)**: Son funciones especiales que pueden conectarse a señales mediante el mecanismo signal-slot de Qt. También son invocables desde QML.

##### Ejemplo de `Q_INVOKABLE` y Slots

```cpp
#include <QObject>
#include <QString>
#include <QDebug>

class Motor : public QObject {
    Q_OBJECT
public:
    explicit Motor(QObject *parent = nullptr);

    // Q_INVOKABLE: callable desde QML
    Q_INVOKABLE int calcularRPM(int velocidad, int marcha) {
        return velocidad * marcha * 100;
    }

public slots:
    // Slot: se puede conectar a señales
    void encender() {
        qDebug() << "Motor encendido";
    }

signals:
    void temperaturaAlta(double temp);
};
```

> **Nota:** Tanto `Q_INVOKABLE` como los slots son invocables desde QML, pero solo los slots pueden conectarse directamente a señales mediante `QObject::connect()`. Si solo necesitas llamar la función desde QML sin conectarla a señales, `Q_INVOKABLE` es la opción más limpia.

### Conclusión

Las funciones son una parte esencial de la programación en C++. Comprender cómo declarar y definir funciones, así como las diferencias entre pasar parámetros por valor y por referencia, permite escribir código modular, reutilizable y fácil de mantener. La sobrecarga de funciones añade flexibilidad, permitiendo definir múltiples versiones de una función para manejar diferentes tipos de datos o cantidades de parámetros. Con C++17, el atributo `[[nodiscard]]` añade seguridad al advertir sobre valores de retorno ignorados. En el ecosistema Qt, `Q_INVOKABLE` y los slots extienden las funciones C++ al mundo QML y al sistema de señales. Con estas habilidades, los desarrolladores pueden estructurar mejor sus programas y resolver problemas de manera eficiente.
<---FILES--->
Sintaxis de la Declaración de Funciones
Sintaxis de la Declaración de Funciones Result
Ejemplo de Declaración de Función
Ejemplo de Declaración de Función Result
Sintaxis de la Definición de Funciones
Sintaxis de la Definición de Funciones Result
Ejemplo de Definición de Función
Ejemplo de Definición de Función Result
Parámetros por Valor
Parámetros por Valor Result
Parámetros por Referencia
Parámetros por Referencia Result
Ejemplo de Sobrecarga de Funciones
Ejemplo de Sobrecarga de Funciones Result
Ejemplo de nodiscard
Ejemplo de nodiscard Result
Ejemplo de Q_INVOKABLE y Slots
Ejemplo de Q_INVOKABLE y Slots Result
<---Sintaxis de la Declaración de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros);
<---Sintaxis de la Declaración de Funciones Result--->
<---Ejemplo de Declaración de Función--->
```cpp
int sumar(int a, int b);
void mostrarMensaje(string mensaje);
<---Ejemplo de Declaración de Función Result--->
<---Sintaxis de la Definición de Funciones--->
```cpp
tipo_retorno nombre_funcion(lista_de_parametros) {
    // Cuerpo de la función
}
<---Sintaxis de la Definición de Funciones Result--->
<---Ejemplo de Definición de Función--->
```cpp
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
```cpp
#include <iostream>
using namespace std;

// Declaraciones de funciones
int sumar(int a, int b);
void mostrarMensaje(string mensaje);

int main() {
    int resultado = sumar(5, 3);
    cout << "La suma es: " << resultado << endl;

    mostrarMensaje("Hola, mundo!");

    return 0;
}

// Definiciones de funciones
int sumar(int a, int b) {
    return a + b;
}

void mostrarMensaje(string mensaje) {
    cout << mensaje << endl;
}
<---Ejemplo de Definición de Función Result--->
<---Parámetros por Valor--->
```cpp
void incrementarPorValor(int x) {
    x++;
}

int main() {
    int numero = 5;
    incrementarPorValor(numero);
    cout << "Número después de incrementar por valor: " << numero << endl; // Salida: 5
    return 0;
}
<---Parámetros por Valor Result--->
<---Parámetros por Referencia--->
```cpp
void incrementarPorReferencia(int& x) {
    x++;
}

int main() {
    int numero = 5;
    incrementarPorReferencia(numero);
    cout << "Número después de incrementar por referencia: " << numero << endl; // Salida: 6
    return 0;
}
<---Parámetros por Referencia Result--->
<---Ejemplo de Sobrecarga de Funciones--->
```cpp
#include <iostream>
using namespace std;

int sumar(int a, int b) {
    return a + b;
}

double sumar(double a, double b) {
    return a + b;
}

int main() {
    cout << "Suma de enteros: " << sumar(3, 4) << endl;       // Llama a sumar(int, int)
    cout << "Suma de dobles: " << sumar(3.5, 2.5) << endl;    // Llama a sumar(double, double)
    return 0;
}
<---Ejemplo de Sobrecarga de Funciones Result--->
<---Ejemplo de nodiscard--->
```cpp
#include <iostream>
using namespace std;

[[nodiscard]] int calcular(int a, int b) {
    return a + b;
}

int main() {
    // calcular(3, 4); // Warning: resultado descartado
    int r = calcular(3, 4); // Correcto
    cout << "Resultado: " << r << endl;
    return 0;
}
<---Ejemplo de nodiscard Result--->
<---Ejemplo de Q_INVOKABLE y Slots--->
```cpp
#include <QObject>
#include <QString>
#include <QDebug>

class Motor : public QObject {
    Q_OBJECT
public:
    explicit Motor(QObject *parent = nullptr);

    // Q_INVOKABLE: callable desde QML
    Q_INVOKABLE int calcularRPM(int velocidad, int marcha) {
        return velocidad * marcha * 100;
    }

public slots:
    // Slot: se puede conectar a señales
    void encender() {
        qDebug() << "Motor encendido";
    }

signals:
    void temperaturaAlta(double temp);
};
<---Ejemplo de Q_INVOKABLE y Slots Result--->
