<---EXPLANATION--->
### Destructor en C++

En la programación orientada a objetos en C++, un destructor es una función especial que se llama automáticamente cuando un objeto de la clase sale del alcance o se elimina. Los destructores se utilizan principalmente para liberar recursos que el objeto pueda haber adquirido durante su ciclo de vida, como memoria dinámica, archivos abiertos, conexiones de red, etc.

#### Características del Destructor

1. **Mismo Nombre que la Clase:** El destructor tiene el mismo nombre que la clase, precedido por un tilde (`~`).
2. **Sin Parámetros ni Tipo de Retorno:** Un destructor no toma parámetros ni tiene un tipo de retorno.
3. **Automático:** Se llama automáticamente cuando el objeto sale del alcance o se elimina.

##### Sintaxis del Destructor

```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```

#### Ejemplo Básico de Destructor

```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
```

En este ejemplo, el destructor se llama automáticamente cuando los objetos `juan` y `maria` salen de su alcance.

#### Destructores y Recursos Dinámicos

Los destructores son especialmente importantes cuando una clase maneja recursos dinámicos, como memoria asignada dinámicamente, archivos o conexiones de red. El destructor asegura que estos recursos se liberen correctamente cuando el objeto ya no se necesita.

##### Ejemplo con Recursos Dinámicos

```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
```

En este ejemplo, el destructor de la clase `Array` se asegura de liberar la memoria asignada dinámicamente cuando el objeto `arr` se destruye.

#### Destructores en Clases Derivadas

En una jerarquía de herencia, los destructores de las clases base y derivadas se llaman en el orden correcto. Si una clase base tiene un destructor virtual, asegura que el destructor de la clase derivada se llame correctamente cuando se elimina un objeto a través de un puntero a la clase base.

##### Ejemplo con Herencia

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
```

En este ejemplo, el destructor de `Base` es virtual, asegurando que el destructor de `Derivada` se llame correctamente cuando el objeto se elimina a través de un puntero a la clase base.

#### Regla de Tres, Cinco y Cero

La "regla de tres" establece que si una clase necesita un destructor explícito, probablemente también necesite un constructor de copia y un operador de asignación de copia. La "regla de cinco" extiende esto a las operaciones de movimiento en C++11 y posteriores. La "regla de cero" sugiere usar tipos RAII (Resource Acquisition Is Initialization) para manejar recursos automáticamente, evitando la necesidad de destructores personalizados, constructores de copia y operadores de asignación.

##### Regla de Tres

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
```

##### Regla de Cinco

```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
```

### Destructores `= default` y `override` (C++11)

C++11 introduce dos especificadores importantes para destructores: `= default` le indica al compilador que genere la implementación por defecto del destructor, y `override` confirma explícitamente que el destructor sobrescribe un destructor virtual de la clase base. Usar `override` ayuda a detectar errores en tiempo de compilación si la clase base no tiene un destructor virtual.

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual ~Base() = default;  // Destructor virtual generado por el compilador
};

class Derivada : public Base {
    int* datos;
public:
    Derivada(int n) : datos(new int[n]) {}

    ~Derivada() override {  // override confirma que sobrescribe el virtual
        delete[] datos;
        cout << "Derivada destruida" << endl;
    }
};

int main() {
    Base* obj = new Derivada(100);
    delete obj;  // Llama correctamente a ~Derivada() gracias a virtual
    return 0;
}
```

**Puntos clave:**
- `= default` es útil cuando quieres que la clase base tenga un destructor virtual pero no necesitas lógica personalizada.
- `override` genera un error de compilación si la clase base no tiene un destructor virtual, evitando errores silenciosos.
- Se recomienda usar siempre `override` en destructores de clases derivadas que sobrescriben un destructor virtual.

### La Regla de Cero y RAII con Smart Pointers

La **Regla de Cero** establece que si una clase puede evitar definir destructor, constructor de copia, operador de asignación de copia, constructor de movimiento y operador de asignación de movimiento, entonces no debería definir ninguno de ellos. Esto se logra usando tipos RAII (Resource Acquisition Is Initialization) como `std::vector`, `std::string`, `std::unique_ptr` y `std::shared_ptr`, que gestionan automáticamente sus recursos.

```cpp
#include <iostream>
#include <memory>
#include <vector>
using namespace std;

// MAL: gestión manual de memoria (necesita destructor, copia, move...)
class ArrayManual {
    int* datos;
    int size;
public:
    ArrayManual(int s) : datos(new int[s]{}), size(s) {}
    ~ArrayManual() { delete[] datos; }
    // + constructor de copia, operador de asignación, move...
};

// BIEN: Regla de Cero con RAII
class ArrayModerno {
    vector<int> datos;  // vector gestiona su propia memoria
public:
    ArrayModerno(int s) : datos(s, 0) {}
    // No necesita destructor, constructor de copia, ni move
    // vector<int> se encarga de todo automáticamente

    int& operator[](int i) { return datos[i]; }
    int size() const { return datos.size(); }
};

// RAII con unique_ptr para recursos que no son contenedores
class Recurso {
    unique_ptr<int[]> datos;  // Se libera automáticamente
    int size;
public:
    Recurso(int s) : datos(make_unique<int[]>(s)), size(s) {}
    // No necesita destructor: unique_ptr lo gestiona
};

int main() {
    ArrayModerno arr(5);
    arr[0] = 42;
    cout << "Valor: " << arr[0] << ", Size: " << arr.size() << endl;
    return 0;
}
```

**Ventajas de la Regla de Cero:**
- Menos código que escribir y mantener.
- Elimina errores comunes como doble liberación, fugas de memoria y copias superficiales incorrectas.
- Los tipos RAII se encargan de la copia, el movimiento y la destrucción de manera correcta y eficiente automáticamente.

### Destructores en Qt: Parent-Child y `deleteLater()`

Qt implementa su propio modelo de gestión de memoria basado en la jerarquía padre-hijo de `QObject`. Cuando un objeto padre (`QObject`) se destruye, automáticamente destruye todos sus objetos hijos. Esto elimina la necesidad de gestionar manualmente la memoria para la mayoría de los objetos en una aplicación Qt.

```cpp
#include <QObject>
#include <QPushButton>
#include <QTimer>
#include <QDebug>

// Qt usa el modelo parent-child para gestión de memoria
// Cuando un QObject padre se destruye, destruye todos sus hijos

class Ventana : public QObject {
    Q_OBJECT
public:
    explicit Ventana(QObject *parent = nullptr) : QObject(parent) {
        // Los hijos se destruyen automáticamente con el padre
        auto* boton1 = new QPushButton("OK", this);     // this es el padre
        auto* boton2 = new QPushButton("Cancel", this);
        auto* timer = new QTimer(this);

        // No necesitas delete boton1, boton2, timer
        // Se destruyen cuando Ventana se destruye
    }

    ~Ventana() override {
        qDebug() << "Ventana destruida (hijos se destruyen automáticamente)";
    }
};

// deleteLater(): destrucción segura en el event loop
// Útil cuando un objeto necesita destruirse a sí mismo
// timer->deleteLater();  // Se destruirá cuando el control vuelva al event loop
// NO usar: delete this;  // Peligroso si hay eventos pendientes
```

**Puntos clave sobre destructores en Qt:**
- Siempre pasa `this` (o un padre apropiado) como parámetro `parent` al crear objetos `QObject` con `new`.
- Usa `deleteLater()` en lugar de `delete` cuando un objeto necesita destruirse durante el procesamiento de un evento (por ejemplo, en un slot).
- Los destructores de clases derivadas de `QObject` deben usar `override`.
- No uses `std::unique_ptr` para objetos `QObject` que tienen un padre, ya que el padre intentará destruirlos también, causando una doble liberación.

### Conclusión

Los destructores son una parte esencial de la administración de recursos en C++. Aseguran que los recursos adquiridos por un objeto se liberen adecuadamente cuando el objeto ya no se necesita. Entender cómo y cuándo implementar destructores, junto con las reglas de tres, cinco y cero, permite a los desarrolladores escribir código más seguro y eficiente, gestionando correctamente la memoria y otros recursos.
<---FILES--->
Sintaxis del Destructor
Sintaxis del Destructor Result
Ejemplo con Recursos Dinámicos
Ejemplo con Recursos Dinámicos Result
Ejemplo con Herencia
Ejemplo con Herencia Result
Regla de Tres
Regla de Tres Result
Regla de Cinco
Regla de Cinco Result
Destructores default y override (C++11)
Destructores default y override (C++11) Result
La Regla de Cero y RAII con Smart Pointers
La Regla de Cero y RAII con Smart Pointers Result
Destructores en Qt: Parent-Child y deleteLater()
Destructores en Qt: Parent-Child y deleteLater() Result
<---Sintaxis del Destructor--->
```cpp
class NombreClase {
public:
    // Constructor
    NombreClase();

    // Destructor
    ~NombreClase();

    // Otros métodos y atributos
};
```cpp
#include <iostream>
using namespace std;

class Persona {
public:
    string nombre;

    // Constructor
    Persona(string n) : nombre(n) {
        cout << "Constructor llamado para " << nombre << endl;
    }

    // Destructor
    ~Persona() {
        cout << "Destructor llamado para " << nombre << endl;
    }
};

int main() {
    Persona juan("Juan");
    {
        Persona maria("Maria");
    } // Destructor llamado para maria aquí

    cout << "Fin del main" << endl;
    return 0; // Destructor llamado para juan aquí
}
<---Sintaxis del Destructor Result--->
<---Ejemplo con Recursos Dinámicos--->
```cpp
#include <iostream>
using namespace std;

class Array {
private:
    int* data;
    int size;

public:
    // Constructor
    Array(int s) : size(s) {
        data = new int[size]; // Asignar memoria dinámica
        cout << "Array de tamaño " << size << " creado." << endl;
    }

    // Destructor
    ~Array() {
        delete[] data; // Liberar memoria dinámica
        cout << "Array de tamaño " << size << " destruido." << endl;
    }

    // Método para establecer un valor en el array
    void setValue(int index, int value) {
        if (index >= 0 && index < size) {
            data[index] = value;
        }
    }

    // Método para obtener un valor del array
    int getValue(int index) const {
        if (index >= 0 && index < size) {
            return data[index];
        }
        return -1; // Valor de error
    }
};

int main() {
    Array arr(5);
    arr.setValue(0, 10);
    arr.setValue(1, 20);
    cout << "Valor en la posición 0: " << arr.getValue(0) << endl;
    cout << "Valor en la posición 1: " << arr.getValue(1) << endl;

    return 0;
}
<---Ejemplo con Recursos Dinámicos Result--->
<---Ejemplo con Herencia--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    // Constructor
    Base() {
        cout << "Constructor de Base" << endl;
    }

    // Destructor virtual
    virtual ~Base() {
        cout << "Destructor de Base" << endl;
    }
};

class Derivada : public Base {
public:
    // Constructor
    Derivada() {
        cout << "Constructor de Derivada" << endl;
    }

    // Destructor
    ~Derivada() {
        cout << "Destructor de Derivada" << endl;
    }
};

int main() {
    Base* obj = new Derivada(); // Crear objeto de clase derivada
    delete obj; // Llamar al destructor virtual

    return 0;
}
<---Ejemplo con Herencia Result--->
<---Regla de Tres--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }
};
<---Regla de Tres Result--->
<---Regla de Cinco--->
```cpp
class Ejemplo {
private:
    int* data;

public:
    // Constructor
    Ejemplo(int size) {
        data = new int[size];
    }

    // Destructor
    ~Ejemplo() {
        delete[] data;
    }

    // Constructor de copia
    Ejemplo(const Ejemplo& other) {
        data = new int[other.size];
        // Copiar datos...
    }

    // Operador de asignación de copia
    Ejemplo& operator=(const Ejemplo& other) {
        if (this != &other) {
            delete[] data;
            data = new int[other.size];
            // Copiar datos...
        }
        return *this;
    }

    // Constructor de movimiento
    Ejemplo(Ejemplo&& other) noexcept : data(other.data) {
        other.data = nullptr;
    }

    // Operador de asignación de movimiento
    Ejemplo& operator=(Ejemplo&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }
};
<---Regla de Cinco Result--->
<---Destructores default y override (C++11)--->
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    virtual ~Base() = default;  // Destructor virtual generado por el compilador
};

class Derivada : public Base {
    int* datos;
public:
    Derivada(int n) : datos(new int[n]) {}

    ~Derivada() override {  // override confirma que sobrescribe el virtual
        delete[] datos;
        cout << "Derivada destruida" << endl;
    }
};

int main() {
    Base* obj = new Derivada(100);
    delete obj;  // Llama correctamente a ~Derivada() gracias a virtual
    return 0;
}
<---Destructores default y override (C++11) Result--->
<---La Regla de Cero y RAII con Smart Pointers--->
```cpp
#include <iostream>
#include <memory>
#include <vector>
using namespace std;

// MAL: gestión manual de memoria (necesita destructor, copia, move...)
class ArrayManual {
    int* datos;
    int size;
public:
    ArrayManual(int s) : datos(new int[s]{}), size(s) {}
    ~ArrayManual() { delete[] datos; }
    // + constructor de copia, operador de asignación, move...
};

// BIEN: Regla de Cero con RAII
class ArrayModerno {
    vector<int> datos;  // vector gestiona su propia memoria
public:
    ArrayModerno(int s) : datos(s, 0) {}
    // No necesita destructor, constructor de copia, ni move
    // vector<int> se encarga de todo automáticamente

    int& operator[](int i) { return datos[i]; }
    int size() const { return datos.size(); }
};

// RAII con unique_ptr para recursos que no son contenedores
class Recurso {
    unique_ptr<int[]> datos;  // Se libera automáticamente
    int size;
public:
    Recurso(int s) : datos(make_unique<int[]>(s)), size(s) {}
    // No necesita destructor: unique_ptr lo gestiona
};

int main() {
    ArrayModerno arr(5);
    arr[0] = 42;
    cout << "Valor: " << arr[0] << ", Size: " << arr.size() << endl;
    return 0;
}
<---La Regla de Cero y RAII con Smart Pointers Result--->
<---Destructores en Qt: Parent-Child y deleteLater()--->
```cpp
#include <QObject>
#include <QPushButton>
#include <QTimer>
#include <QDebug>

// Qt usa el modelo parent-child para gestión de memoria
// Cuando un QObject padre se destruye, destruye todos sus hijos

class Ventana : public QObject {
    Q_OBJECT
public:
    explicit Ventana(QObject *parent = nullptr) : QObject(parent) {
        // Los hijos se destruyen automáticamente con el padre
        auto* boton1 = new QPushButton("OK", this);     // this es el padre
        auto* boton2 = new QPushButton("Cancel", this);
        auto* timer = new QTimer(this);

        // No necesitas delete boton1, boton2, timer
        // Se destruyen cuando Ventana se destruye
    }

    ~Ventana() override {
        qDebug() << "Ventana destruida (hijos se destruyen automáticamente)";
    }
};

// deleteLater(): destrucción segura en el event loop
// Útil cuando un objeto necesita destruirse a sí mismo
// timer->deleteLater();  // Se destruirá cuando el control vuelva al event loop
// NO usar: delete this;  // Peligroso si hay eventos pendientes
<---Destructores en Qt: Parent-Child y deleteLater() Result--->