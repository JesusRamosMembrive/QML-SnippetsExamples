<---EXPLANATION--->
### Constexpr y Constinit en C++

C++ introduce `constexpr` y `constinit` como mecanismos para definir y asegurar constantes en tiempo de compilación. Estas dos palabras clave ayudan a mejorar la eficiencia y la seguridad del código al garantizar que ciertas expresiones sean evaluadas y ciertas variables sean inicializadas en tiempo de compilación.

#### 1. **`constexpr`**

`constexpr` se utiliza para definir variables y funciones que son evaluadas en tiempo de compilación. Esto garantiza que las expresiones `constexpr` sean constantes y permite optimizaciones más agresivas por parte del compilador.

##### Variables `constexpr`

Una variable `constexpr` debe ser inicializada con una expresión constante en tiempo de compilación.

```cpp
constexpr int tamañoArray = 10;
constexpr double pi = 3.14159;
```

##### Funciones `constexpr`

Una función `constexpr` puede ser evaluada en tiempo de compilación si sus argumentos son constantes. Si se llama a la función con valores que no son constantes, la función se evalúa en tiempo de ejecución.

```cpp
constexpr int cuadrado(int x) {
    return x * x;
}

int main() {
    constexpr int valor = cuadrado(5); // Evaluada en tiempo de compilación
    int resultado = cuadrado(5);       // Evaluada en tiempo de ejecución
    return 0;
}
```

#### 2. **`constinit`**

`constinit` se utiliza para garantizar que una variable de almacenamiento estático sea inicializada en tiempo de compilación. Esto es útil para evitar inicializaciones múltiples en el contexto de variables estáticas y garantiza que la inicialización ocurra antes de cualquier uso de la variable.

##### Ejemplo de `constinit`

```cpp
constinit int valorGlobal = 42; // Garantiza inicialización en tiempo de compilación

int main() {
    constinit static int valorEstatico = 100; // Garantiza inicialización en tiempo de compilación
    return 0;
}
```

### Comparación y Usos

- **`constexpr`** se utiliza tanto para variables como para funciones y asegura que las expresiones sean evaluadas en tiempo de compilación siempre que sea posible.
- **`constinit`** se utiliza para asegurar que una variable de almacenamiento estático se inicialice solo una vez en tiempo de compilación, evitando problemas de inicialización múltiple.

### Ejemplo Completo

A continuación, se muestra un ejemplo que utiliza tanto `constexpr` como `constinit` para declarar variables y funciones:

```cpp
#include <iostream>
using namespace std;

// Función constexpr
constexpr int suma(int a, int b) {
    return a + b;
}

// Variable constexpr
constexpr int valorConstante = 10;

// Variable constinit
constinit int contadorGlobal = 0;

int main() {
    // Uso de constexpr para evaluar en tiempo de compilación
    constexpr int resultado = suma(3, 4);
    cout << "Resultado constexpr: " << resultado << endl;

    // Uso de constinit para asegurar inicialización estática
    constinit static int contadorLocal = 100;
    contadorLocal++;
    cout << "Contador local: " << contadorLocal << endl;

    contadorGlobal++;
    cout << "Contador global: " << contadorGlobal << endl;

    return 0;
}
```

### Detalles Adicionales

#### Funciones `constexpr` y Limitaciones

- Las funciones `constexpr` pueden contener una sola sentencia `return` si están definidas en C++11, pero desde C++14, pueden contener más lógica, incluyendo bucles y condiciones.
- Las funciones `constexpr` no pueden tener efectos secundarios, como modificar variables globales o estáticas.

##### Ejemplo de Función `constexpr` Compleja (C++14 y Posterior)

```cpp
constexpr int factorial(int n) {
    int resultado = 1;
    for (int i = 1; i <= n; ++i) {
        resultado *= i;
    }
    return resultado;
}

int main() {
    constexpr int valorFactorial = factorial(5); // Evaluado en tiempo de compilación
    cout << "Factorial constexpr: " << valorFactorial << endl;
    return 0;
}
```

#### Uso de `constinit` en Contextos de Multithreading

El uso de `constinit` puede ser particularmente beneficioso en entornos de multithreading, donde asegurar que una variable estática se inicializa correctamente antes de su uso concurrente es crucial para evitar condiciones de carrera.

##### Ejemplo de `constinit` en Multithreading

```cpp
#include <iostream>
#include <thread>
#include <atomic>

constinit std::atomic<int> contadorGlobal{0};

void incrementarContador() {
    contadorGlobal++;
}

int main() {
    std::thread t1(incrementarContador);
    std::thread t2(incrementarContador);

    t1.join();
    t2.join();

    std::cout << "Contador global: " << contadorGlobal << std::endl;

    return 0;
}
```

### Conclusión

Tanto `constexpr` como `constinit` son herramientas poderosas en C++ que mejoran la seguridad y la eficiencia del código al garantizar la evaluación y la inicialización en tiempo de compilación. Utilizar estas palabras clave adecuadamente puede ayudar a prevenir errores y optimizar el rendimiento de los programas.

### `constexpr` y `consteval` en el Contexto de Qt

#### Limitaciones con tipos Qt

La mayoría de tipos Qt (`QString`, `QList`, `QVariant`) **no son `constexpr`** porque requieren asignación dinámica de memoria. Solo los tipos triviales y algunos wrappers funcionan:

```cpp
// OK: tipos primitivos y structs triviales
constexpr int MAX_REINTENTOS = 3;
constexpr qreal FACTOR_ESCALA = 1.5;
constexpr QPoint ORIGEN{0, 0};       // QPoint es constexpr desde Qt 6
constexpr QSize TAMANO{800, 600};    // QSize también

// ERROR: QString no es constexpr
// constexpr QString nombre = "test";  // No compila
// Alternativa:
static const QString NOMBRE = QStringLiteral("test");
```

#### `consteval` (C++20)

`consteval` es más estricto que `constexpr`: la función **siempre** se evalúa en compilación. Si no puede, es un error:

```cpp
consteval int cubo(int x) {
    return x * x * x;
}

constexpr int a = cubo(3);   // OK: 27 en compilación
// int b = cubo(variable);   // ERROR: no se puede evaluar en compilación
```

#### `static_assert` para validación en compilación

Complementa a `constexpr` verificando condiciones en compilación:

```cpp
constexpr int BUFFER_SIZE = 1024;
static_assert(BUFFER_SIZE >= 256, "Buffer demasiado pequeño");
static_assert(sizeof(qint32) == 4, "qint32 debe ser 4 bytes");
```

#### Patrón constexpr en enums de Qt

Qt define enums con valores constantes que se pueden usar en contextos `constexpr`:

```cpp
// Los valores de enum de Qt son constexpr por naturaleza
constexpr Qt::Alignment alineacion = Qt::AlignCenter | Qt::AlignVCenter;
constexpr Qt::WindowFlags flags = Qt::Window | Qt::FramelessWindowHint;
```

<---FILES--->
Variables `constexpr`
Variables `constexpr` Result
Funciones `constexpr`
Funciones `constexpr` Result
Ejemplo de `constinit`
Ejemplo de `constinit` Result
Ejemplo de Función `constexpr` Compleja (C++14 y Posterior)
Ejemplo de Función `constexpr` Compleja (C++14 y Posterior) Result
Ejemplo de `constinit` en Multithreading
Ejemplo de `constinit` en Multithreading Result
<---Variables `constexpr`--->
```cpp
constexpr int tamañoArray = 10;
constexpr double pi = 3.14159;
```
<---Variables `constexpr` Result--->
<---Funciones `constexpr`--->
```cpp
constexpr int cuadrado(int x) {
    return x * x;
}

int main() {
    constexpr int valor = cuadrado(5); // Evaluada en tiempo de compilación
    int resultado = cuadrado(5);       // Evaluada en tiempo de ejecución
    return 0;
}
```
<---Funciones `constexpr` Result--->
<---Ejemplo de `constinit`--->
```cpp
constinit int valorGlobal = 42;

int main() {
    constinit static int valorEstatico = 100;
    return 0;
}
```
<---Ejemplo de `constinit` Result--->
<---Ejemplo de Función `constexpr` Compleja (C++14 y Posterior)--->
```cpp
constexpr int factorial(int n) {
    int resultado = 1;
    for (int i = 1; i <= n; ++i) {
        resultado *= i;
    }
    return resultado;
}

int main() {
    constexpr int valorFactorial = factorial(5);
    cout << "Factorial constexpr: " << valorFactorial << endl;
    return 0;
}
```
<---Ejemplo de Función `constexpr` Compleja (C++14 y Posterior) Result--->
<---Ejemplo de `constinit` en Multithreading--->
```cpp
#include <iostream>
#include <thread>
#include <atomic>

constinit std::atomic<int> contadorGlobal{0};

void incrementarContador() {
    contadorGlobal++;
}

int main() {
    std::thread t1(incrementarContador);
    std::thread t2(incrementarContador);

    t1.join();
    t2.join();

    std::cout << "Contador global: " << contadorGlobal << std::endl;

    return 0;
}
```
<---Ejemplo de `constinit` en Multithreading Result--->
