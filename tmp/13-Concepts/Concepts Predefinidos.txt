<---EXPLANATION--->
### Concepts Predefinidos en C++

C++20 introdujo una serie de Concepts predefinidos en la biblioteca estándar, que cubren un amplio rango de propiedades y operaciones comunes. Estos Concepts predefinidos facilitan la creación de plantillas al proporcionar restricciones listas para usar que aseguran que los tipos cumplan con ciertos requisitos.

#### Lista de Concepts Predefinidos

Aquí hay algunos de los Concepts predefinidos más importantes:

1. `Same`
2. `DerivedFrom`
3. `ConvertibleTo`
4. `Common`
5. `Integral`
6. `SignedIntegral`
7. `UnsignedIntegral`
8. `FloatingPoint`
9. `Swappable`
10. `DefaultConstructible`
11. `MoveConstructible`
12. `CopyConstructible`

### Ejemplos de Uso de Concepts Predefinidos

#### 1. Concept `Same`

El Concept `Same` verifica si dos tipos son el mismo.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta argumentos del mismo tipo
template<std::same_as<int> T>
void imprimir(T valor) {
    std::cout << valor << std::endl;
}

int main() {
    imprimir(42);  // Funciona: 42 es un int

    // imprimir(42.0);  // Error de compilación: 42.0 es un double
}
```

#### 2. Concept `DerivedFrom`

El Concept `DerivedFrom` verifica si un tipo es derivado de otro.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

class Base {};
class Derivada : public Base {};

// Función plantilla que solo acepta tipos derivados de Base
template<std::derived_from<Base> T>
void mostrarBase(const T&) {
    std::cout << "Derivado de Base" << std::endl;
}

int main() {
    Base b;
    Derivada d;

    mostrarBase(d);  // Funciona: Derivada es derivada de Base

    // mostrarBase(b);  // Error de compilación: Base no es derivada de Base
}
```

#### 3. Concept `ConvertibleTo`

El Concept `ConvertibleTo` verifica si un tipo puede ser convertido a otro.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos convertibles a int
template<std::convertible_to<int> T>
void convertir(T valor) {
    int convertido = static_cast<int>(valor);
    std::cout << convertido << std::endl;
}

int main() {
    convertir(42);     // Funciona: int es convertible a int
    convertir(42.0);   // Funciona: double es convertible a int

    // convertir("42");  // Error de compilación: const char* no es convertible a int
}
```

#### 4. Concept `Common`

El Concept `Common` verifica si hay un tipo común entre dos tipos dados.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos con un tipo común
template<std::common_with<int> T>
void sumarComun(T a, T b) {
    std::cout << (a + b) << std::endl;
}

int main() {
    sumarComun(3, 5);   // Funciona: int es común con int
    sumarComun(3.0, 5); // Funciona: double es común con int

    // sumarComun("3", 5);  // Error de compilación: const char* no es común con int
}
```

#### 5. Concept `Integral`

El Concept `Integral` verifica si un tipo es un tipo integral.

##### Ejemplo

```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    int a = 5, b = 3;
    std::cout << multiplicar(a, b) << std::endl;  // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << multiplicar(x, y) << std::endl;  // Error de compilación: double no es un tipo integral
}
```

### Otros Concepts Predefinidos

- **SignedIntegral**: Verifica si un tipo es un entero con signo.
- **UnsignedIntegral**: Verifica si un tipo es un entero sin signo.
- **FloatingPoint**: Verifica si un tipo es un punto flotante.
- **Swappable**: Verifica si dos objetos pueden intercambiarse.
- **DefaultConstructible**: Verifica si un tipo puede ser construido por defecto.
- **MoveConstructible**: Verifica si un tipo puede ser movido.
- **CopyConstructible**: Verifica si un tipo puede ser copiado.

### Uso de Concepts Predefinidos con Qt

Los Concepts predefinidos son ideales para restringir plantillas que interactúan con las jerarquías de clases y tipos de datos de Qt.

#### `std::derived_from` con `QObject`

Podemos restringir una clase genérica para que solo trabaje con objetos que puedan participar en el sistema de señales y slots.

```cpp
#include <concepts>
#include <QObject>
#include <QWidget>

// Solo acepta clases que hereden de QObject
template<std::derived_from<QObject> T>
class GestorQt {
    T* objeto;
public:
    GestorQt(T* o) : objeto(o) {}
};

void test() {
    GestorQt<QWidget> g1(new QWidget()); // OK: QWidget hereda de QObject
    // GestorQt<int> g2(new int(5));     // ERROR en compilación
}
```

#### `std::convertible_to` con `QString`

Asegura que un parámetro genérico pueda ser representado como una cadena de Qt, lo cual es útil para funciones de interfaz de usuario.

```cpp
#include <concepts>
#include <QString>
#include <QMessageBox>

// Acepta cualquier tipo que se pueda convertir implícitamente a QString
void mostrarAlerta(std::convertible_to<QString> auto mensaje) {
    QMessageBox::information(nullptr, "Alerta", mensaje);
}

void ejemplo() {
    mostrarAlerta("Operación exitosa"); // OK: const char* es convertible a QString
    mostrarAlerta(QString("Error 404")); // OK: QString es convertible a QString
}
```

### Conclusión

Los Concepts predefinidos en C++20 son una herramienta poderosa para imponer restricciones de tipos en plantillas. Estos Concepts proporcionan una manera clara y concisa de especificar requisitos de tipos, mejorando la seguridad y legibilidad del código. Al utilizar estos Concepts, puede asegurarse de que sus plantillas solo acepten tipos adecuados y evitar errores de compilación difíciles de diagnosticar.
<---FILES--->
Ejemplo
Ejemplo Result
<---Ejemplo--->
```cpp
#include <concepts>
#include <iostream>

// Función plantilla que solo acepta tipos integrales
template<std::integral T>
T multiplicar(T a, T b) {
    return a * b;
}

int main() {
    int a = 5, b = 3;
    std::cout << multiplicar(a, b) << std::endl;  // Funciona: int es un tipo integral

    // double x = 5.0, y = 3.0;
    // std::cout << multiplicar(x, y) << std::endl;  // Error de compilación: double no es un tipo integral
}
<---Ejemplo Result--->
